// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod rewind_viewer {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod fbs {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_COMMAND: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_COMMAND: u8 = 9;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_COMMAND: [Command; 10] = [
  Command::NONE,
  Command::Circle,
  Command::Rectangle,
  Command::Triangle,
  Command::Polyline,
  Command::LogText,
  Command::Popup,
  Command::PopupRound,
  Command::Options,
  Command::EndFrame,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Command(pub u8);
#[allow(non_upper_case_globals)]
impl Command {
  pub const NONE: Self = Self(0);
  pub const Circle: Self = Self(1);
  pub const Rectangle: Self = Self(2);
  pub const Triangle: Self = Self(3);
  pub const Polyline: Self = Self(4);
  pub const LogText: Self = Self(5);
  pub const Popup: Self = Self(6);
  pub const PopupRound: Self = Self(7);
  pub const Options: Self = Self(8);
  pub const EndFrame: Self = Self(9);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 9;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::Circle,
    Self::Rectangle,
    Self::Triangle,
    Self::Polyline,
    Self::LogText,
    Self::Popup,
    Self::PopupRound,
    Self::Options,
    Self::EndFrame,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::Circle => Some("Circle"),
      Self::Rectangle => Some("Rectangle"),
      Self::Triangle => Some("Triangle"),
      Self::Polyline => Some("Polyline"),
      Self::LogText => Some("LogText"),
      Self::Popup => Some("Popup"),
      Self::PopupRound => Some("PopupRound"),
      Self::Options => Some("Options"),
      Self::EndFrame => Some("EndFrame"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Command {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Command {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Command {
    type Output = Command;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Command {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Command {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Command {}
pub struct CommandUnionTableOffset {}

#[allow(clippy::upper_case_acronyms)]
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub enum CommandT {
  NONE,
  Circle(Box<CircleT>),
  Rectangle(Box<RectangleT>),
  Triangle(Box<TriangleT>),
  Polyline(Box<PolylineT>),
  LogText(Box<LogTextT>),
  Popup(Box<PopupT>),
  PopupRound(Box<PopupRoundT>),
  Options(Box<OptionsT>),
  EndFrame(Box<EndFrameT>),
}
impl Default for CommandT {
  fn default() -> Self {
    Self::NONE
  }
}
impl CommandT {
  pub fn command_type(&self) -> Command {
    match self {
      Self::NONE => Command::NONE,
      Self::Circle(_) => Command::Circle,
      Self::Rectangle(_) => Command::Rectangle,
      Self::Triangle(_) => Command::Triangle,
      Self::Polyline(_) => Command::Polyline,
      Self::LogText(_) => Command::LogText,
      Self::Popup(_) => Command::Popup,
      Self::PopupRound(_) => Command::PopupRound,
      Self::Options(_) => Command::Options,
      Self::EndFrame(_) => Command::EndFrame,
    }
  }
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(&self, fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>) -> Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>> {
    match self {
      Self::NONE => None,
      Self::Circle(v) => Some(v.pack(fbb).as_union_value()),
      Self::Rectangle(v) => Some(v.pack(fbb).as_union_value()),
      Self::Triangle(v) => Some(v.pack(fbb).as_union_value()),
      Self::Polyline(v) => Some(v.pack(fbb).as_union_value()),
      Self::LogText(v) => Some(v.pack(fbb).as_union_value()),
      Self::Popup(v) => Some(v.pack(fbb).as_union_value()),
      Self::PopupRound(v) => Some(v.pack(fbb).as_union_value()),
      Self::Options(v) => Some(v.pack(fbb).as_union_value()),
      Self::EndFrame(v) => Some(v.pack(fbb).as_union_value()),
    }
  }
  /// If the union variant matches, return the owned CircleT, setting the union to NONE.
  pub fn take_circle(&mut self) -> Option<Box<CircleT>> {
    if let Self::Circle(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Circle(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the CircleT.
  pub fn as_circle(&self) -> Option<&CircleT> {
    if let Self::Circle(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the CircleT.
  pub fn as_circle_mut(&mut self) -> Option<&mut CircleT> {
    if let Self::Circle(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned RectangleT, setting the union to NONE.
  pub fn take_rectangle(&mut self) -> Option<Box<RectangleT>> {
    if let Self::Rectangle(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Rectangle(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the RectangleT.
  pub fn as_rectangle(&self) -> Option<&RectangleT> {
    if let Self::Rectangle(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the RectangleT.
  pub fn as_rectangle_mut(&mut self) -> Option<&mut RectangleT> {
    if let Self::Rectangle(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned TriangleT, setting the union to NONE.
  pub fn take_triangle(&mut self) -> Option<Box<TriangleT>> {
    if let Self::Triangle(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Triangle(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the TriangleT.
  pub fn as_triangle(&self) -> Option<&TriangleT> {
    if let Self::Triangle(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the TriangleT.
  pub fn as_triangle_mut(&mut self) -> Option<&mut TriangleT> {
    if let Self::Triangle(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned PolylineT, setting the union to NONE.
  pub fn take_polyline(&mut self) -> Option<Box<PolylineT>> {
    if let Self::Polyline(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Polyline(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the PolylineT.
  pub fn as_polyline(&self) -> Option<&PolylineT> {
    if let Self::Polyline(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the PolylineT.
  pub fn as_polyline_mut(&mut self) -> Option<&mut PolylineT> {
    if let Self::Polyline(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned LogTextT, setting the union to NONE.
  pub fn take_log_text(&mut self) -> Option<Box<LogTextT>> {
    if let Self::LogText(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::LogText(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the LogTextT.
  pub fn as_log_text(&self) -> Option<&LogTextT> {
    if let Self::LogText(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the LogTextT.
  pub fn as_log_text_mut(&mut self) -> Option<&mut LogTextT> {
    if let Self::LogText(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned PopupT, setting the union to NONE.
  pub fn take_popup(&mut self) -> Option<Box<PopupT>> {
    if let Self::Popup(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Popup(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the PopupT.
  pub fn as_popup(&self) -> Option<&PopupT> {
    if let Self::Popup(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the PopupT.
  pub fn as_popup_mut(&mut self) -> Option<&mut PopupT> {
    if let Self::Popup(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned PopupRoundT, setting the union to NONE.
  pub fn take_popup_round(&mut self) -> Option<Box<PopupRoundT>> {
    if let Self::PopupRound(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::PopupRound(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the PopupRoundT.
  pub fn as_popup_round(&self) -> Option<&PopupRoundT> {
    if let Self::PopupRound(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the PopupRoundT.
  pub fn as_popup_round_mut(&mut self) -> Option<&mut PopupRoundT> {
    if let Self::PopupRound(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned OptionsT, setting the union to NONE.
  pub fn take_options(&mut self) -> Option<Box<OptionsT>> {
    if let Self::Options(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Options(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the OptionsT.
  pub fn as_options(&self) -> Option<&OptionsT> {
    if let Self::Options(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the OptionsT.
  pub fn as_options_mut(&mut self) -> Option<&mut OptionsT> {
    if let Self::Options(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned EndFrameT, setting the union to NONE.
  pub fn take_end_frame(&mut self) -> Option<Box<EndFrameT>> {
    if let Self::EndFrame(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::EndFrame(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the EndFrameT.
  pub fn as_end_frame(&self) -> Option<&EndFrameT> {
    if let Self::EndFrame(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the EndFrameT.
  pub fn as_end_frame_mut(&mut self) -> Option<&mut EndFrameT> {
    if let Self::EndFrame(v) = self { Some(v.as_mut()) } else { None }
  }
}
// struct Vector2f, aligned to 4
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Vector2f(pub [u8; 8]);
impl Default for Vector2f { 
  fn default() -> Self { 
    Self([0; 8])
  }
}
impl core::fmt::Debug for Vector2f {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("Vector2f")
      .field("x", &self.x())
      .field("y", &self.y())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Vector2f {}
impl<'a> flatbuffers::Follow<'a> for Vector2f {
  type Inner = &'a Vector2f;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Vector2f>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Vector2f {
  type Inner = &'a Vector2f;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Vector2f>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Vector2f {
    type Output = Vector2f;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Vector2f as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Vector2f {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Vector2f {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    x: f32,
    y: f32,
  ) -> Self {
    let mut s = Self([0; 8]);
    s.set_x(x);
    s.set_y(y);
    s
  }

  pub fn x(&self) -> f32 {
    let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_x(&mut self, x: f32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn y(&self) -> f32 {
    let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[4..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_y(&mut self, x: f32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[4..].as_mut_ptr(),
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn unpack(&self) -> Vector2fT {
    Vector2fT {
      x: self.x(),
      y: self.y(),
    }
  }
}

#[derive(Debug, Clone, PartialEq, Default)]
pub struct Vector2fT {
  pub x: f32,
  pub y: f32,
}
impl Vector2fT {
  pub fn pack(&self) -> Vector2f {
    Vector2f::new(
      self.x,
      self.y,
    )
  }
}

pub enum ColorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Color<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Color<'a> {
  type Inner = Color<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Color<'a> {
  pub const VT_VALUE: flatbuffers::VOffsetT = 4;
  pub const VT_FILL: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Color { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ColorArgs
  ) -> flatbuffers::WIPOffset<Color<'bldr>> {
    let mut builder = ColorBuilder::new(_fbb);
    builder.add_value(args.value);
    builder.add_fill(args.fill);
    builder.finish()
  }

  pub fn unpack(&self) -> ColorT {
    let value = self.value();
    let fill = self.fill();
    ColorT {
      value,
      fill,
    }
  }

  #[inline]
  pub fn value(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Color::VT_VALUE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn fill(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Color::VT_FILL, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Color<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("value", Self::VT_VALUE, false)?
     .visit_field::<bool>("fill", Self::VT_FILL, false)?
     .finish();
    Ok(())
  }
}
pub struct ColorArgs {
    pub value: u32,
    pub fill: bool,
}
impl<'a> Default for ColorArgs {
  #[inline]
  fn default() -> Self {
    ColorArgs {
      value: 0,
      fill: false,
    }
  }
}

pub struct ColorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ColorBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_value(&mut self, value: u32) {
    self.fbb_.push_slot::<u32>(Color::VT_VALUE, value, 0);
  }
  #[inline]
  pub fn add_fill(&mut self, fill: bool) {
    self.fbb_.push_slot::<bool>(Color::VT_FILL, fill, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ColorBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ColorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Color<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Color<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Color");
      ds.field("value", &self.value());
      ds.field("fill", &self.fill());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ColorT {
  pub value: u32,
  pub fill: bool,
}
impl Default for ColorT {
  fn default() -> Self {
    Self {
      value: 0,
      fill: false,
    }
  }
}
impl ColorT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Color<'b>> {
    let value = self.value;
    let fill = self.fill;
    Color::create(_fbb, &ColorArgs{
      value,
      fill,
    })
  }
}
pub enum CircleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Circle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Circle<'a> {
  type Inner = Circle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Circle<'a> {
  pub const VT_COLOR: flatbuffers::VOffsetT = 4;
  pub const VT_CENTER: flatbuffers::VOffsetT = 6;
  pub const VT_RADIUS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Circle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CircleArgs<'args>
  ) -> flatbuffers::WIPOffset<Circle<'bldr>> {
    let mut builder = CircleBuilder::new(_fbb);
    builder.add_radius(args.radius);
    if let Some(x) = args.center { builder.add_center(x); }
    if let Some(x) = args.color { builder.add_color(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> CircleT {
    let color = {
      let x = self.color();
      Box::new(x.unpack())
    };
    let center = {
      let x = self.center();
      x.unpack()
    };
    let radius = self.radius();
    CircleT {
      color,
      center,
      radius,
    }
  }

  #[inline]
  pub fn color(&self) -> Color<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Color>>(Circle::VT_COLOR, None).unwrap()}
  }
  #[inline]
  pub fn center(&self) -> &'a Vector2f {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector2f>(Circle::VT_CENTER, None).unwrap()}
  }
  #[inline]
  pub fn radius(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Circle::VT_RADIUS, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Circle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Color>>("color", Self::VT_COLOR, true)?
     .visit_field::<Vector2f>("center", Self::VT_CENTER, true)?
     .visit_field::<f32>("radius", Self::VT_RADIUS, false)?
     .finish();
    Ok(())
  }
}
pub struct CircleArgs<'a> {
    pub color: Option<flatbuffers::WIPOffset<Color<'a>>>,
    pub center: Option<&'a Vector2f>,
    pub radius: f32,
}
impl<'a> Default for CircleArgs<'a> {
  #[inline]
  fn default() -> Self {
    CircleArgs {
      color: None, // required field
      center: None, // required field
      radius: 0.0,
    }
  }
}

pub struct CircleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CircleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_color(&mut self, color: flatbuffers::WIPOffset<Color<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Color>>(Circle::VT_COLOR, color);
  }
  #[inline]
  pub fn add_center(&mut self, center: &Vector2f) {
    self.fbb_.push_slot_always::<&Vector2f>(Circle::VT_CENTER, center);
  }
  #[inline]
  pub fn add_radius(&mut self, radius: f32) {
    self.fbb_.push_slot::<f32>(Circle::VT_RADIUS, radius, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CircleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CircleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Circle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Circle::VT_COLOR,"color");
    self.fbb_.required(o, Circle::VT_CENTER,"center");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Circle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Circle");
      ds.field("color", &self.color());
      ds.field("center", &self.center());
      ds.field("radius", &self.radius());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CircleT {
  pub color: Box<ColorT>,
  pub center: Vector2fT,
  pub radius: f32,
}
impl Default for CircleT {
  fn default() -> Self {
    Self {
      color: Default::default(),
      center: Default::default(),
      radius: 0.0,
    }
  }
}
impl CircleT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Circle<'b>> {
    let color = Some({
      let x = &self.color;
      x.pack(_fbb)
    });
    let center_tmp = Some(self.center.pack());
    let center = center_tmp.as_ref();
    let radius = self.radius;
    Circle::create(_fbb, &CircleArgs{
      color,
      center,
      radius,
    })
  }
}
pub enum RectangleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Rectangle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Rectangle<'a> {
  type Inner = Rectangle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Rectangle<'a> {
  pub const VT_COLOR: flatbuffers::VOffsetT = 4;
  pub const VT_POSITION: flatbuffers::VOffsetT = 6;
  pub const VT_SIZE_: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Rectangle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RectangleArgs<'args>
  ) -> flatbuffers::WIPOffset<Rectangle<'bldr>> {
    let mut builder = RectangleBuilder::new(_fbb);
    if let Some(x) = args.size_ { builder.add_size_(x); }
    if let Some(x) = args.position { builder.add_position(x); }
    if let Some(x) = args.color { builder.add_color(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> RectangleT {
    let color = {
      let x = self.color();
      Box::new(x.unpack())
    };
    let position = {
      let x = self.position();
      x.unpack()
    };
    let size_ = {
      let x = self.size_();
      x.unpack()
    };
    RectangleT {
      color,
      position,
      size_,
    }
  }

  #[inline]
  pub fn color(&self) -> Color<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Color>>(Rectangle::VT_COLOR, None).unwrap()}
  }
  #[inline]
  pub fn position(&self) -> &'a Vector2f {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector2f>(Rectangle::VT_POSITION, None).unwrap()}
  }
  #[inline]
  pub fn size_(&self) -> &'a Vector2f {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector2f>(Rectangle::VT_SIZE_, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Rectangle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Color>>("color", Self::VT_COLOR, true)?
     .visit_field::<Vector2f>("position", Self::VT_POSITION, true)?
     .visit_field::<Vector2f>("size_", Self::VT_SIZE_, true)?
     .finish();
    Ok(())
  }
}
pub struct RectangleArgs<'a> {
    pub color: Option<flatbuffers::WIPOffset<Color<'a>>>,
    pub position: Option<&'a Vector2f>,
    pub size_: Option<&'a Vector2f>,
}
impl<'a> Default for RectangleArgs<'a> {
  #[inline]
  fn default() -> Self {
    RectangleArgs {
      color: None, // required field
      position: None, // required field
      size_: None, // required field
    }
  }
}

pub struct RectangleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RectangleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_color(&mut self, color: flatbuffers::WIPOffset<Color<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Color>>(Rectangle::VT_COLOR, color);
  }
  #[inline]
  pub fn add_position(&mut self, position: &Vector2f) {
    self.fbb_.push_slot_always::<&Vector2f>(Rectangle::VT_POSITION, position);
  }
  #[inline]
  pub fn add_size_(&mut self, size_: &Vector2f) {
    self.fbb_.push_slot_always::<&Vector2f>(Rectangle::VT_SIZE_, size_);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RectangleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RectangleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Rectangle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Rectangle::VT_COLOR,"color");
    self.fbb_.required(o, Rectangle::VT_POSITION,"position");
    self.fbb_.required(o, Rectangle::VT_SIZE_,"size_");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Rectangle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Rectangle");
      ds.field("color", &self.color());
      ds.field("position", &self.position());
      ds.field("size_", &self.size_());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct RectangleT {
  pub color: Box<ColorT>,
  pub position: Vector2fT,
  pub size_: Vector2fT,
}
impl Default for RectangleT {
  fn default() -> Self {
    Self {
      color: Default::default(),
      position: Default::default(),
      size_: Default::default(),
    }
  }
}
impl RectangleT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Rectangle<'b>> {
    let color = Some({
      let x = &self.color;
      x.pack(_fbb)
    });
    let position_tmp = Some(self.position.pack());
    let position = position_tmp.as_ref();
    let size__tmp = Some(self.size_.pack());
    let size_ = size__tmp.as_ref();
    Rectangle::create(_fbb, &RectangleArgs{
      color,
      position,
      size_,
    })
  }
}
pub enum TriangleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Triangle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Triangle<'a> {
  type Inner = Triangle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Triangle<'a> {
  pub const VT_COLOR: flatbuffers::VOffsetT = 4;
  pub const VT_POINTS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Triangle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TriangleArgs<'args>
  ) -> flatbuffers::WIPOffset<Triangle<'bldr>> {
    let mut builder = TriangleBuilder::new(_fbb);
    if let Some(x) = args.points { builder.add_points(x); }
    if let Some(x) = args.color { builder.add_color(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> TriangleT {
    let color = {
      let x = self.color();
      Box::new(x.unpack())
    };
    let points = {
      let x = self.points();
      x.iter().map(|t| t.unpack()).collect()
    };
    TriangleT {
      color,
      points,
    }
  }

  #[inline]
  pub fn color(&self) -> Color<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Color>>(Triangle::VT_COLOR, None).unwrap()}
  }
  #[inline]
  pub fn points(&self) -> flatbuffers::Vector<'a, Vector2f> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Vector2f>>>(Triangle::VT_POINTS, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Triangle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Color>>("color", Self::VT_COLOR, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Vector2f>>>("points", Self::VT_POINTS, true)?
     .finish();
    Ok(())
  }
}
pub struct TriangleArgs<'a> {
    pub color: Option<flatbuffers::WIPOffset<Color<'a>>>,
    pub points: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Vector2f>>>,
}
impl<'a> Default for TriangleArgs<'a> {
  #[inline]
  fn default() -> Self {
    TriangleArgs {
      color: None, // required field
      points: None, // required field
    }
  }
}

pub struct TriangleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TriangleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_color(&mut self, color: flatbuffers::WIPOffset<Color<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Color>>(Triangle::VT_COLOR, color);
  }
  #[inline]
  pub fn add_points(&mut self, points: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Vector2f>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Triangle::VT_POINTS, points);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TriangleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TriangleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Triangle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Triangle::VT_COLOR,"color");
    self.fbb_.required(o, Triangle::VT_POINTS,"points");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Triangle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Triangle");
      ds.field("color", &self.color());
      ds.field("points", &self.points());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct TriangleT {
  pub color: Box<ColorT>,
  pub points: Vec<Vector2fT>,
}
impl Default for TriangleT {
  fn default() -> Self {
    Self {
      color: Default::default(),
      points: Default::default(),
    }
  }
}
impl TriangleT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Triangle<'b>> {
    let color = Some({
      let x = &self.color;
      x.pack(_fbb)
    });
    let points = Some({
      let x = &self.points;
      let w: Vec<_> = x.iter().map(|t| t.pack()).collect();_fbb.create_vector(&w)
    });
    Triangle::create(_fbb, &TriangleArgs{
      color,
      points,
    })
  }
}
pub enum PolylineOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Polyline<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Polyline<'a> {
  type Inner = Polyline<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Polyline<'a> {
  pub const VT_COLOR: flatbuffers::VOffsetT = 4;
  pub const VT_POINTS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Polyline { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PolylineArgs<'args>
  ) -> flatbuffers::WIPOffset<Polyline<'bldr>> {
    let mut builder = PolylineBuilder::new(_fbb);
    if let Some(x) = args.points { builder.add_points(x); }
    if let Some(x) = args.color { builder.add_color(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> PolylineT {
    let color = {
      let x = self.color();
      Box::new(x.unpack())
    };
    let points = {
      let x = self.points();
      x.iter().map(|t| t.unpack()).collect()
    };
    PolylineT {
      color,
      points,
    }
  }

  #[inline]
  pub fn color(&self) -> Color<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Color>>(Polyline::VT_COLOR, None).unwrap()}
  }
  #[inline]
  pub fn points(&self) -> flatbuffers::Vector<'a, Vector2f> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Vector2f>>>(Polyline::VT_POINTS, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Polyline<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Color>>("color", Self::VT_COLOR, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Vector2f>>>("points", Self::VT_POINTS, true)?
     .finish();
    Ok(())
  }
}
pub struct PolylineArgs<'a> {
    pub color: Option<flatbuffers::WIPOffset<Color<'a>>>,
    pub points: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Vector2f>>>,
}
impl<'a> Default for PolylineArgs<'a> {
  #[inline]
  fn default() -> Self {
    PolylineArgs {
      color: None, // required field
      points: None, // required field
    }
  }
}

pub struct PolylineBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PolylineBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_color(&mut self, color: flatbuffers::WIPOffset<Color<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Color>>(Polyline::VT_COLOR, color);
  }
  #[inline]
  pub fn add_points(&mut self, points: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Vector2f>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Polyline::VT_POINTS, points);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PolylineBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PolylineBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Polyline<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Polyline::VT_COLOR,"color");
    self.fbb_.required(o, Polyline::VT_POINTS,"points");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Polyline<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Polyline");
      ds.field("color", &self.color());
      ds.field("points", &self.points());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct PolylineT {
  pub color: Box<ColorT>,
  pub points: Vec<Vector2fT>,
}
impl Default for PolylineT {
  fn default() -> Self {
    Self {
      color: Default::default(),
      points: Default::default(),
    }
  }
}
impl PolylineT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Polyline<'b>> {
    let color = Some({
      let x = &self.color;
      x.pack(_fbb)
    });
    let points = Some({
      let x = &self.points;
      let w: Vec<_> = x.iter().map(|t| t.pack()).collect();_fbb.create_vector(&w)
    });
    Polyline::create(_fbb, &PolylineArgs{
      color,
      points,
    })
  }
}
pub enum LogTextOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LogText<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LogText<'a> {
  type Inner = LogText<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LogText<'a> {
  pub const VT_TEXT: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LogText { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LogTextArgs<'args>
  ) -> flatbuffers::WIPOffset<LogText<'bldr>> {
    let mut builder = LogTextBuilder::new(_fbb);
    if let Some(x) = args.text { builder.add_text(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> LogTextT {
    let text = {
      let x = self.text();
      x.to_string()
    };
    LogTextT {
      text,
    }
  }

  #[inline]
  pub fn text(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogText::VT_TEXT, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for LogText<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("text", Self::VT_TEXT, true)?
     .finish();
    Ok(())
  }
}
pub struct LogTextArgs<'a> {
    pub text: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for LogTextArgs<'a> {
  #[inline]
  fn default() -> Self {
    LogTextArgs {
      text: None, // required field
    }
  }
}

pub struct LogTextBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LogTextBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_text(&mut self, text: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogText::VT_TEXT, text);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LogTextBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LogTextBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LogText<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, LogText::VT_TEXT,"text");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LogText<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LogText");
      ds.field("text", &self.text());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct LogTextT {
  pub text: String,
}
impl Default for LogTextT {
  fn default() -> Self {
    Self {
      text: "".to_string(),
    }
  }
}
impl LogTextT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<LogText<'b>> {
    let text = Some({
      let x = &self.text;
      _fbb.create_string(x)
    });
    LogText::create(_fbb, &LogTextArgs{
      text,
    })
  }
}
pub enum PopupOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Popup<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Popup<'a> {
  type Inner = Popup<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Popup<'a> {
  pub const VT_TEXT: flatbuffers::VOffsetT = 4;
  pub const VT_AREA_POSITION: flatbuffers::VOffsetT = 6;
  pub const VT_AREA_SIZE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Popup { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PopupArgs<'args>
  ) -> flatbuffers::WIPOffset<Popup<'bldr>> {
    let mut builder = PopupBuilder::new(_fbb);
    if let Some(x) = args.area_size { builder.add_area_size(x); }
    if let Some(x) = args.area_position { builder.add_area_position(x); }
    if let Some(x) = args.text { builder.add_text(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> PopupT {
    let text = {
      let x = self.text();
      x.to_string()
    };
    let area_position = {
      let x = self.area_position();
      x.unpack()
    };
    let area_size = {
      let x = self.area_size();
      x.unpack()
    };
    PopupT {
      text,
      area_position,
      area_size,
    }
  }

  #[inline]
  pub fn text(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Popup::VT_TEXT, None).unwrap()}
  }
  #[inline]
  pub fn area_position(&self) -> &'a Vector2f {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector2f>(Popup::VT_AREA_POSITION, None).unwrap()}
  }
  #[inline]
  pub fn area_size(&self) -> &'a Vector2f {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector2f>(Popup::VT_AREA_SIZE, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Popup<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("text", Self::VT_TEXT, true)?
     .visit_field::<Vector2f>("area_position", Self::VT_AREA_POSITION, true)?
     .visit_field::<Vector2f>("area_size", Self::VT_AREA_SIZE, true)?
     .finish();
    Ok(())
  }
}
pub struct PopupArgs<'a> {
    pub text: Option<flatbuffers::WIPOffset<&'a str>>,
    pub area_position: Option<&'a Vector2f>,
    pub area_size: Option<&'a Vector2f>,
}
impl<'a> Default for PopupArgs<'a> {
  #[inline]
  fn default() -> Self {
    PopupArgs {
      text: None, // required field
      area_position: None, // required field
      area_size: None, // required field
    }
  }
}

pub struct PopupBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PopupBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_text(&mut self, text: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Popup::VT_TEXT, text);
  }
  #[inline]
  pub fn add_area_position(&mut self, area_position: &Vector2f) {
    self.fbb_.push_slot_always::<&Vector2f>(Popup::VT_AREA_POSITION, area_position);
  }
  #[inline]
  pub fn add_area_size(&mut self, area_size: &Vector2f) {
    self.fbb_.push_slot_always::<&Vector2f>(Popup::VT_AREA_SIZE, area_size);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PopupBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PopupBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Popup<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Popup::VT_TEXT,"text");
    self.fbb_.required(o, Popup::VT_AREA_POSITION,"area_position");
    self.fbb_.required(o, Popup::VT_AREA_SIZE,"area_size");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Popup<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Popup");
      ds.field("text", &self.text());
      ds.field("area_position", &self.area_position());
      ds.field("area_size", &self.area_size());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct PopupT {
  pub text: String,
  pub area_position: Vector2fT,
  pub area_size: Vector2fT,
}
impl Default for PopupT {
  fn default() -> Self {
    Self {
      text: "".to_string(),
      area_position: Default::default(),
      area_size: Default::default(),
    }
  }
}
impl PopupT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Popup<'b>> {
    let text = Some({
      let x = &self.text;
      _fbb.create_string(x)
    });
    let area_position_tmp = Some(self.area_position.pack());
    let area_position = area_position_tmp.as_ref();
    let area_size_tmp = Some(self.area_size.pack());
    let area_size = area_size_tmp.as_ref();
    Popup::create(_fbb, &PopupArgs{
      text,
      area_position,
      area_size,
    })
  }
}
pub enum PopupRoundOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PopupRound<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PopupRound<'a> {
  type Inner = PopupRound<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PopupRound<'a> {
  pub const VT_TEXT: flatbuffers::VOffsetT = 4;
  pub const VT_AREA_CENTER: flatbuffers::VOffsetT = 6;
  pub const VT_AREA_RADIUS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PopupRound { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PopupRoundArgs<'args>
  ) -> flatbuffers::WIPOffset<PopupRound<'bldr>> {
    let mut builder = PopupRoundBuilder::new(_fbb);
    builder.add_area_radius(args.area_radius);
    if let Some(x) = args.area_center { builder.add_area_center(x); }
    if let Some(x) = args.text { builder.add_text(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> PopupRoundT {
    let text = {
      let x = self.text();
      x.to_string()
    };
    let area_center = {
      let x = self.area_center();
      x.unpack()
    };
    let area_radius = self.area_radius();
    PopupRoundT {
      text,
      area_center,
      area_radius,
    }
  }

  #[inline]
  pub fn text(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PopupRound::VT_TEXT, None).unwrap()}
  }
  #[inline]
  pub fn area_center(&self) -> &'a Vector2f {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector2f>(PopupRound::VT_AREA_CENTER, None).unwrap()}
  }
  #[inline]
  pub fn area_radius(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(PopupRound::VT_AREA_RADIUS, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for PopupRound<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("text", Self::VT_TEXT, true)?
     .visit_field::<Vector2f>("area_center", Self::VT_AREA_CENTER, true)?
     .visit_field::<f32>("area_radius", Self::VT_AREA_RADIUS, false)?
     .finish();
    Ok(())
  }
}
pub struct PopupRoundArgs<'a> {
    pub text: Option<flatbuffers::WIPOffset<&'a str>>,
    pub area_center: Option<&'a Vector2f>,
    pub area_radius: f32,
}
impl<'a> Default for PopupRoundArgs<'a> {
  #[inline]
  fn default() -> Self {
    PopupRoundArgs {
      text: None, // required field
      area_center: None, // required field
      area_radius: 0.0,
    }
  }
}

pub struct PopupRoundBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PopupRoundBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_text(&mut self, text: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PopupRound::VT_TEXT, text);
  }
  #[inline]
  pub fn add_area_center(&mut self, area_center: &Vector2f) {
    self.fbb_.push_slot_always::<&Vector2f>(PopupRound::VT_AREA_CENTER, area_center);
  }
  #[inline]
  pub fn add_area_radius(&mut self, area_radius: f32) {
    self.fbb_.push_slot::<f32>(PopupRound::VT_AREA_RADIUS, area_radius, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PopupRoundBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PopupRoundBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PopupRound<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, PopupRound::VT_TEXT,"text");
    self.fbb_.required(o, PopupRound::VT_AREA_CENTER,"area_center");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PopupRound<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PopupRound");
      ds.field("text", &self.text());
      ds.field("area_center", &self.area_center());
      ds.field("area_radius", &self.area_radius());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct PopupRoundT {
  pub text: String,
  pub area_center: Vector2fT,
  pub area_radius: f32,
}
impl Default for PopupRoundT {
  fn default() -> Self {
    Self {
      text: "".to_string(),
      area_center: Default::default(),
      area_radius: 0.0,
    }
  }
}
impl PopupRoundT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<PopupRound<'b>> {
    let text = Some({
      let x = &self.text;
      _fbb.create_string(x)
    });
    let area_center_tmp = Some(self.area_center.pack());
    let area_center = area_center_tmp.as_ref();
    let area_radius = self.area_radius;
    PopupRound::create(_fbb, &PopupRoundArgs{
      text,
      area_center,
      area_radius,
    })
  }
}
pub enum LayerOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Layer<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Layer<'a> {
  type Inner = Layer<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Layer<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_USE_PERMANENT_FRAME: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Layer { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LayerArgs
  ) -> flatbuffers::WIPOffset<Layer<'bldr>> {
    let mut builder = LayerBuilder::new(_fbb);
    builder.add_id(args.id);
    builder.add_use_permanent_frame(args.use_permanent_frame);
    builder.finish()
  }

  pub fn unpack(&self) -> LayerT {
    let id = self.id();
    let use_permanent_frame = self.use_permanent_frame();
    LayerT {
      id,
      use_permanent_frame,
    }
  }

  #[inline]
  pub fn id(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Layer::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn use_permanent_frame(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Layer::VT_USE_PERMANENT_FRAME, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Layer<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("id", Self::VT_ID, false)?
     .visit_field::<bool>("use_permanent_frame", Self::VT_USE_PERMANENT_FRAME, false)?
     .finish();
    Ok(())
  }
}
pub struct LayerArgs {
    pub id: u32,
    pub use_permanent_frame: bool,
}
impl<'a> Default for LayerArgs {
  #[inline]
  fn default() -> Self {
    LayerArgs {
      id: 0,
      use_permanent_frame: false,
    }
  }
}

pub struct LayerBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LayerBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: u32) {
    self.fbb_.push_slot::<u32>(Layer::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_use_permanent_frame(&mut self, use_permanent_frame: bool) {
    self.fbb_.push_slot::<bool>(Layer::VT_USE_PERMANENT_FRAME, use_permanent_frame, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LayerBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LayerBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Layer<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Layer<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Layer");
      ds.field("id", &self.id());
      ds.field("use_permanent_frame", &self.use_permanent_frame());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct LayerT {
  pub id: u32,
  pub use_permanent_frame: bool,
}
impl Default for LayerT {
  fn default() -> Self {
    Self {
      id: 0,
      use_permanent_frame: false,
    }
  }
}
impl LayerT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Layer<'b>> {
    let id = self.id;
    let use_permanent_frame = self.use_permanent_frame;
    Layer::create(_fbb, &LayerArgs{
      id,
      use_permanent_frame,
    })
  }
}
pub enum MapOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Map<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Map<'a> {
  type Inner = Map<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Map<'a> {
  pub const VT_WIDTH: flatbuffers::VOffsetT = 4;
  pub const VT_HEIGHT: flatbuffers::VOffsetT = 6;
  pub const VT_X_GRID: flatbuffers::VOffsetT = 8;
  pub const VT_Y_GRID: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Map { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MapArgs
  ) -> flatbuffers::WIPOffset<Map<'bldr>> {
    let mut builder = MapBuilder::new(_fbb);
    builder.add_y_grid(args.y_grid);
    builder.add_x_grid(args.x_grid);
    builder.add_height(args.height);
    builder.add_width(args.width);
    builder.finish()
  }

  pub fn unpack(&self) -> MapT {
    let width = self.width();
    let height = self.height();
    let x_grid = self.x_grid();
    let y_grid = self.y_grid();
    MapT {
      width,
      height,
      x_grid,
      y_grid,
    }
  }

  #[inline]
  pub fn width(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Map::VT_WIDTH, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn height(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Map::VT_HEIGHT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn x_grid(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Map::VT_X_GRID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn y_grid(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Map::VT_Y_GRID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Map<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>("width", Self::VT_WIDTH, false)?
     .visit_field::<f32>("height", Self::VT_HEIGHT, false)?
     .visit_field::<u32>("x_grid", Self::VT_X_GRID, false)?
     .visit_field::<u32>("y_grid", Self::VT_Y_GRID, false)?
     .finish();
    Ok(())
  }
}
pub struct MapArgs {
    pub width: f32,
    pub height: f32,
    pub x_grid: u32,
    pub y_grid: u32,
}
impl<'a> Default for MapArgs {
  #[inline]
  fn default() -> Self {
    MapArgs {
      width: 0.0,
      height: 0.0,
      x_grid: 0,
      y_grid: 0,
    }
  }
}

pub struct MapBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MapBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_width(&mut self, width: f32) {
    self.fbb_.push_slot::<f32>(Map::VT_WIDTH, width, 0.0);
  }
  #[inline]
  pub fn add_height(&mut self, height: f32) {
    self.fbb_.push_slot::<f32>(Map::VT_HEIGHT, height, 0.0);
  }
  #[inline]
  pub fn add_x_grid(&mut self, x_grid: u32) {
    self.fbb_.push_slot::<u32>(Map::VT_X_GRID, x_grid, 0);
  }
  #[inline]
  pub fn add_y_grid(&mut self, y_grid: u32) {
    self.fbb_.push_slot::<u32>(Map::VT_Y_GRID, y_grid, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MapBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MapBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Map<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Map<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Map");
      ds.field("width", &self.width());
      ds.field("height", &self.height());
      ds.field("x_grid", &self.x_grid());
      ds.field("y_grid", &self.y_grid());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MapT {
  pub width: f32,
  pub height: f32,
  pub x_grid: u32,
  pub y_grid: u32,
}
impl Default for MapT {
  fn default() -> Self {
    Self {
      width: 0.0,
      height: 0.0,
      x_grid: 0,
      y_grid: 0,
    }
  }
}
impl MapT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Map<'b>> {
    let width = self.width;
    let height = self.height;
    let x_grid = self.x_grid;
    let y_grid = self.y_grid;
    Map::create(_fbb, &MapArgs{
      width,
      height,
      x_grid,
      y_grid,
    })
  }
}
pub enum OptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Options<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Options<'a> {
  type Inner = Options<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Options<'a> {
  pub const VT_MAP: flatbuffers::VOffsetT = 4;
  pub const VT_LAYER: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Options { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args OptionsArgs<'args>
  ) -> flatbuffers::WIPOffset<Options<'bldr>> {
    let mut builder = OptionsBuilder::new(_fbb);
    if let Some(x) = args.layer { builder.add_layer(x); }
    if let Some(x) = args.map { builder.add_map(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> OptionsT {
    let map = self.map().map(|x| {
      Box::new(x.unpack())
    });
    let layer = self.layer().map(|x| {
      Box::new(x.unpack())
    });
    OptionsT {
      map,
      layer,
    }
  }

  #[inline]
  pub fn map(&self) -> Option<Map<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Map>>(Options::VT_MAP, None)}
  }
  #[inline]
  pub fn layer(&self) -> Option<Layer<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Layer>>(Options::VT_LAYER, None)}
  }
}

impl flatbuffers::Verifiable for Options<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Map>>("map", Self::VT_MAP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Layer>>("layer", Self::VT_LAYER, false)?
     .finish();
    Ok(())
  }
}
pub struct OptionsArgs<'a> {
    pub map: Option<flatbuffers::WIPOffset<Map<'a>>>,
    pub layer: Option<flatbuffers::WIPOffset<Layer<'a>>>,
}
impl<'a> Default for OptionsArgs<'a> {
  #[inline]
  fn default() -> Self {
    OptionsArgs {
      map: None,
      layer: None,
    }
  }
}

pub struct OptionsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> OptionsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_map(&mut self, map: flatbuffers::WIPOffset<Map<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Map>>(Options::VT_MAP, map);
  }
  #[inline]
  pub fn add_layer(&mut self, layer: flatbuffers::WIPOffset<Layer<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Layer>>(Options::VT_LAYER, layer);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> OptionsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    OptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Options<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Options<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Options");
      ds.field("map", &self.map());
      ds.field("layer", &self.layer());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct OptionsT {
  pub map: Option<Box<MapT>>,
  pub layer: Option<Box<LayerT>>,
}
impl Default for OptionsT {
  fn default() -> Self {
    Self {
      map: None,
      layer: None,
    }
  }
}
impl OptionsT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Options<'b>> {
    let map = self.map.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let layer = self.layer.as_ref().map(|x|{
      x.pack(_fbb)
    });
    Options::create(_fbb, &OptionsArgs{
      map,
      layer,
    })
  }
}
pub enum EndFrameOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct EndFrame<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EndFrame<'a> {
  type Inner = EndFrame<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> EndFrame<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EndFrame { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    _args: &'args EndFrameArgs
  ) -> flatbuffers::WIPOffset<EndFrame<'bldr>> {
    let mut builder = EndFrameBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> EndFrameT {
    EndFrameT {
    }
  }
}

impl flatbuffers::Verifiable for EndFrame<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct EndFrameArgs {
}
impl<'a> Default for EndFrameArgs {
  #[inline]
  fn default() -> Self {
    EndFrameArgs {
    }
  }
}

pub struct EndFrameBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EndFrameBuilder<'a, 'b, A> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> EndFrameBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    EndFrameBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EndFrame<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EndFrame<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EndFrame");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct EndFrameT {
}
impl Default for EndFrameT {
  fn default() -> Self {
    Self {
    }
  }
}
impl EndFrameT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<EndFrame<'b>> {
    EndFrame::create(_fbb, &EndFrameArgs{
    })
  }
}
pub enum RewindMessageOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RewindMessage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RewindMessage<'a> {
  type Inner = RewindMessage<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RewindMessage<'a> {
  pub const VT_COMMAND_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_COMMAND: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RewindMessage { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RewindMessageArgs
  ) -> flatbuffers::WIPOffset<RewindMessage<'bldr>> {
    let mut builder = RewindMessageBuilder::new(_fbb);
    if let Some(x) = args.command { builder.add_command(x); }
    builder.add_command_type(args.command_type);
    builder.finish()
  }

  pub fn unpack(&self) -> RewindMessageT {
    let command = match self.command_type() {
      Command::NONE => CommandT::NONE,
      Command::Circle => CommandT::Circle(Box::new(
        self.command_as_circle()
            .expect("Invalid union table, expected `Command::Circle`.")
            .unpack()
      )),
      Command::Rectangle => CommandT::Rectangle(Box::new(
        self.command_as_rectangle()
            .expect("Invalid union table, expected `Command::Rectangle`.")
            .unpack()
      )),
      Command::Triangle => CommandT::Triangle(Box::new(
        self.command_as_triangle()
            .expect("Invalid union table, expected `Command::Triangle`.")
            .unpack()
      )),
      Command::Polyline => CommandT::Polyline(Box::new(
        self.command_as_polyline()
            .expect("Invalid union table, expected `Command::Polyline`.")
            .unpack()
      )),
      Command::LogText => CommandT::LogText(Box::new(
        self.command_as_log_text()
            .expect("Invalid union table, expected `Command::LogText`.")
            .unpack()
      )),
      Command::Popup => CommandT::Popup(Box::new(
        self.command_as_popup()
            .expect("Invalid union table, expected `Command::Popup`.")
            .unpack()
      )),
      Command::PopupRound => CommandT::PopupRound(Box::new(
        self.command_as_popup_round()
            .expect("Invalid union table, expected `Command::PopupRound`.")
            .unpack()
      )),
      Command::Options => CommandT::Options(Box::new(
        self.command_as_options()
            .expect("Invalid union table, expected `Command::Options`.")
            .unpack()
      )),
      Command::EndFrame => CommandT::EndFrame(Box::new(
        self.command_as_end_frame()
            .expect("Invalid union table, expected `Command::EndFrame`.")
            .unpack()
      )),
      _ => CommandT::NONE,
    };
    RewindMessageT {
      command,
    }
  }

  #[inline]
  pub fn command_type(&self) -> Command {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Command>(RewindMessage::VT_COMMAND_TYPE, Some(Command::NONE)).unwrap()}
  }
  #[inline]
  pub fn command(&self) -> flatbuffers::Table<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(RewindMessage::VT_COMMAND, None).unwrap()}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_circle(&self) -> Option<Circle<'a>> {
    if self.command_type() == Command::Circle {
      let u = self.command();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Circle::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_rectangle(&self) -> Option<Rectangle<'a>> {
    if self.command_type() == Command::Rectangle {
      let u = self.command();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Rectangle::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_triangle(&self) -> Option<Triangle<'a>> {
    if self.command_type() == Command::Triangle {
      let u = self.command();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Triangle::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_polyline(&self) -> Option<Polyline<'a>> {
    if self.command_type() == Command::Polyline {
      let u = self.command();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Polyline::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_log_text(&self) -> Option<LogText<'a>> {
    if self.command_type() == Command::LogText {
      let u = self.command();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { LogText::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_popup(&self) -> Option<Popup<'a>> {
    if self.command_type() == Command::Popup {
      let u = self.command();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Popup::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_popup_round(&self) -> Option<PopupRound<'a>> {
    if self.command_type() == Command::PopupRound {
      let u = self.command();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { PopupRound::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_options(&self) -> Option<Options<'a>> {
    if self.command_type() == Command::Options {
      let u = self.command();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Options::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_end_frame(&self) -> Option<EndFrame<'a>> {
    if self.command_type() == Command::EndFrame {
      let u = self.command();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { EndFrame::init_from_table(u) })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for RewindMessage<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<Command, _>("command_type", Self::VT_COMMAND_TYPE, "command", Self::VT_COMMAND, true, |key, v, pos| {
        match key {
          Command::Circle => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Circle>>("Command::Circle", pos),
          Command::Rectangle => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Rectangle>>("Command::Rectangle", pos),
          Command::Triangle => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Triangle>>("Command::Triangle", pos),
          Command::Polyline => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Polyline>>("Command::Polyline", pos),
          Command::LogText => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogText>>("Command::LogText", pos),
          Command::Popup => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Popup>>("Command::Popup", pos),
          Command::PopupRound => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PopupRound>>("Command::PopupRound", pos),
          Command::Options => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Options>>("Command::Options", pos),
          Command::EndFrame => v.verify_union_variant::<flatbuffers::ForwardsUOffset<EndFrame>>("Command::EndFrame", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct RewindMessageArgs {
    pub command_type: Command,
    pub command: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for RewindMessageArgs {
  #[inline]
  fn default() -> Self {
    RewindMessageArgs {
      command_type: Command::NONE,
      command: None, // required field
    }
  }
}

pub struct RewindMessageBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RewindMessageBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_command_type(&mut self, command_type: Command) {
    self.fbb_.push_slot::<Command>(RewindMessage::VT_COMMAND_TYPE, command_type, Command::NONE);
  }
  #[inline]
  pub fn add_command(&mut self, command: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RewindMessage::VT_COMMAND, command);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RewindMessageBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RewindMessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RewindMessage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, RewindMessage::VT_COMMAND,"command");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RewindMessage<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RewindMessage");
      ds.field("command_type", &self.command_type());
      match self.command_type() {
        Command::Circle => {
          if let Some(x) = self.command_as_circle() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Command::Rectangle => {
          if let Some(x) = self.command_as_rectangle() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Command::Triangle => {
          if let Some(x) = self.command_as_triangle() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Command::Polyline => {
          if let Some(x) = self.command_as_polyline() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Command::LogText => {
          if let Some(x) = self.command_as_log_text() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Command::Popup => {
          if let Some(x) = self.command_as_popup() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Command::PopupRound => {
          if let Some(x) = self.command_as_popup_round() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Command::Options => {
          if let Some(x) = self.command_as_options() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Command::EndFrame => {
          if let Some(x) = self.command_as_end_frame() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("command", &x)
        },
      };
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct RewindMessageT {
  pub command: CommandT,
}
impl Default for RewindMessageT {
  fn default() -> Self {
    Self {
      command: CommandT::NONE,
    }
  }
}
impl RewindMessageT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<RewindMessage<'b>> {
    let command_type = self.command.command_type();
    let command = self.command.pack(_fbb);
    RewindMessage::create(_fbb, &RewindMessageArgs{
      command_type,
      command,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `RewindMessage`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_rewind_message_unchecked`.
pub fn root_as_rewind_message(buf: &[u8]) -> Result<RewindMessage, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<RewindMessage>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `RewindMessage` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_rewind_message_unchecked`.
pub fn size_prefixed_root_as_rewind_message(buf: &[u8]) -> Result<RewindMessage, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<RewindMessage>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `RewindMessage` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_rewind_message_unchecked`.
pub fn root_as_rewind_message_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<RewindMessage<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<RewindMessage<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `RewindMessage` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_rewind_message_unchecked`.
pub fn size_prefixed_root_as_rewind_message_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<RewindMessage<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<RewindMessage<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a RewindMessage and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `RewindMessage`.
pub unsafe fn root_as_rewind_message_unchecked(buf: &[u8]) -> RewindMessage {
  flatbuffers::root_unchecked::<RewindMessage>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed RewindMessage and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `RewindMessage`.
pub unsafe fn size_prefixed_root_as_rewind_message_unchecked(buf: &[u8]) -> RewindMessage {
  flatbuffers::size_prefixed_root_unchecked::<RewindMessage>(buf)
}
#[inline]
pub fn finish_rewind_message_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<RewindMessage<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_rewind_message_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<RewindMessage<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod fbs
}  // pub mod rewind_viewer

