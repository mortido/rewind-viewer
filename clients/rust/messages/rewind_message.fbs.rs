// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use crate::vector2f.fbs::*;
use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod rewind_viewer {

  use crate::vector2f.fbs::*;
  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod fbs {

  use crate::vector2f.fbs::*;
  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_COMMAND: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_COMMAND: u8 = 17;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_COMMAND: [Command; 18] = [
  Command::NONE,
  Command::Arc,
  Command::CameraView,
  Command::Circle,
  Command::CircleSegment,
  Command::LogText,
  Command::Options,
  Command::Polyline,
  Command::Popup,
  Command::PopupRound,
  Command::ReadEvents,
  Command::Rectangle,
  Command::Subscribe,
  Command::Tiles,
  Command::Triangle,
  Command::Unsubscribe,
  Command::Primitives,
  Command::EndFrame,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Command(pub u8);
#[allow(non_upper_case_globals)]
impl Command {
  pub const NONE: Self = Self(0);
  pub const Arc: Self = Self(1);
  pub const CameraView: Self = Self(2);
  pub const Circle: Self = Self(3);
  pub const CircleSegment: Self = Self(4);
  pub const LogText: Self = Self(5);
  pub const Options: Self = Self(6);
  pub const Polyline: Self = Self(7);
  pub const Popup: Self = Self(8);
  pub const PopupRound: Self = Self(9);
  pub const ReadEvents: Self = Self(10);
  pub const Rectangle: Self = Self(11);
  pub const Subscribe: Self = Self(12);
  pub const Tiles: Self = Self(13);
  pub const Triangle: Self = Self(14);
  pub const Unsubscribe: Self = Self(15);
  pub const Primitives: Self = Self(16);
  pub const EndFrame: Self = Self(17);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 17;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::Arc,
    Self::CameraView,
    Self::Circle,
    Self::CircleSegment,
    Self::LogText,
    Self::Options,
    Self::Polyline,
    Self::Popup,
    Self::PopupRound,
    Self::ReadEvents,
    Self::Rectangle,
    Self::Subscribe,
    Self::Tiles,
    Self::Triangle,
    Self::Unsubscribe,
    Self::Primitives,
    Self::EndFrame,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::Arc => Some("Arc"),
      Self::CameraView => Some("CameraView"),
      Self::Circle => Some("Circle"),
      Self::CircleSegment => Some("CircleSegment"),
      Self::LogText => Some("LogText"),
      Self::Options => Some("Options"),
      Self::Polyline => Some("Polyline"),
      Self::Popup => Some("Popup"),
      Self::PopupRound => Some("PopupRound"),
      Self::ReadEvents => Some("ReadEvents"),
      Self::Rectangle => Some("Rectangle"),
      Self::Subscribe => Some("Subscribe"),
      Self::Tiles => Some("Tiles"),
      Self::Triangle => Some("Triangle"),
      Self::Unsubscribe => Some("Unsubscribe"),
      Self::Primitives => Some("Primitives"),
      Self::EndFrame => Some("EndFrame"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Command {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Command {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Command {
    type Output = Command;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Command {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Command {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Command {}
pub struct CommandUnionTableOffset {}

pub enum ColorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Color<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Color<'a> {
  type Inner = Color<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Color<'a> {
  pub const VT_VALUE: flatbuffers::VOffsetT = 4;
  pub const VT_FILL: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Color { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ColorArgs
  ) -> flatbuffers::WIPOffset<Color<'bldr>> {
    let mut builder = ColorBuilder::new(_fbb);
    builder.add_value(args.value);
    builder.add_fill(args.fill);
    builder.finish()
  }


  #[inline]
  pub fn value(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Color::VT_VALUE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn fill(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Color::VT_FILL, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Color<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("value", Self::VT_VALUE, false)?
     .visit_field::<bool>("fill", Self::VT_FILL, false)?
     .finish();
    Ok(())
  }
}
pub struct ColorArgs {
    pub value: u32,
    pub fill: bool,
}
impl<'a> Default for ColorArgs {
  #[inline]
  fn default() -> Self {
    ColorArgs {
      value: 0,
      fill: false,
    }
  }
}

pub struct ColorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ColorBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_value(&mut self, value: u32) {
    self.fbb_.push_slot::<u32>(Color::VT_VALUE, value, 0);
  }
  #[inline]
  pub fn add_fill(&mut self, fill: bool) {
    self.fbb_.push_slot::<bool>(Color::VT_FILL, fill, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ColorBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ColorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Color<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Color<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Color");
      ds.field("value", &self.value());
      ds.field("fill", &self.fill());
      ds.finish()
  }
}
pub enum CircleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Circle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Circle<'a> {
  type Inner = Circle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Circle<'a> {
  pub const VT_COLOR: flatbuffers::VOffsetT = 4;
  pub const VT_CENTER: flatbuffers::VOffsetT = 6;
  pub const VT_RADIUS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Circle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CircleArgs<'args>
  ) -> flatbuffers::WIPOffset<Circle<'bldr>> {
    let mut builder = CircleBuilder::new(_fbb);
    builder.add_radius(args.radius);
    if let Some(x) = args.center { builder.add_center(x); }
    if let Some(x) = args.color { builder.add_color(x); }
    builder.finish()
  }


  #[inline]
  pub fn color(&self) -> Option<Color<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Color>>(Circle::VT_COLOR, None)}
  }
  #[inline]
  pub fn center(&self) -> &'a Vector2f {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector2f>(Circle::VT_CENTER, None).unwrap()}
  }
  #[inline]
  pub fn radius(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Circle::VT_RADIUS, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Circle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Color>>("color", Self::VT_COLOR, false)?
     .visit_field::<Vector2f>("center", Self::VT_CENTER, true)?
     .visit_field::<f32>("radius", Self::VT_RADIUS, false)?
     .finish();
    Ok(())
  }
}
pub struct CircleArgs<'a> {
    pub color: Option<flatbuffers::WIPOffset<Color<'a>>>,
    pub center: Option<&'a Vector2f>,
    pub radius: f32,
}
impl<'a> Default for CircleArgs<'a> {
  #[inline]
  fn default() -> Self {
    CircleArgs {
      color: None,
      center: None, // required field
      radius: 0.0,
    }
  }
}

pub struct CircleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CircleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_color(&mut self, color: flatbuffers::WIPOffset<Color<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Color>>(Circle::VT_COLOR, color);
  }
  #[inline]
  pub fn add_center(&mut self, center: &Vector2f) {
    self.fbb_.push_slot_always::<&Vector2f>(Circle::VT_CENTER, center);
  }
  #[inline]
  pub fn add_radius(&mut self, radius: f32) {
    self.fbb_.push_slot::<f32>(Circle::VT_RADIUS, radius, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CircleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CircleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Circle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Circle::VT_CENTER,"center");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Circle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Circle");
      ds.field("color", &self.color());
      ds.field("center", &self.center());
      ds.field("radius", &self.radius());
      ds.finish()
  }
}
pub enum ArcOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Arc<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Arc<'a> {
  type Inner = Arc<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Arc<'a> {
  pub const VT_COLOR: flatbuffers::VOffsetT = 4;
  pub const VT_CENTER: flatbuffers::VOffsetT = 6;
  pub const VT_RADIUS: flatbuffers::VOffsetT = 8;
  pub const VT_START_ANGLE: flatbuffers::VOffsetT = 10;
  pub const VT_END_ANGLE: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Arc { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ArcArgs<'args>
  ) -> flatbuffers::WIPOffset<Arc<'bldr>> {
    let mut builder = ArcBuilder::new(_fbb);
    builder.add_end_angle(args.end_angle);
    builder.add_start_angle(args.start_angle);
    builder.add_radius(args.radius);
    if let Some(x) = args.center { builder.add_center(x); }
    if let Some(x) = args.color { builder.add_color(x); }
    builder.finish()
  }


  #[inline]
  pub fn color(&self) -> Option<Color<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Color>>(Arc::VT_COLOR, None)}
  }
  #[inline]
  pub fn center(&self) -> &'a Vector2f {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector2f>(Arc::VT_CENTER, None).unwrap()}
  }
  #[inline]
  pub fn radius(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Arc::VT_RADIUS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn start_angle(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Arc::VT_START_ANGLE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn end_angle(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Arc::VT_END_ANGLE, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Arc<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Color>>("color", Self::VT_COLOR, false)?
     .visit_field::<Vector2f>("center", Self::VT_CENTER, true)?
     .visit_field::<f32>("radius", Self::VT_RADIUS, false)?
     .visit_field::<f32>("start_angle", Self::VT_START_ANGLE, false)?
     .visit_field::<f32>("end_angle", Self::VT_END_ANGLE, false)?
     .finish();
    Ok(())
  }
}
pub struct ArcArgs<'a> {
    pub color: Option<flatbuffers::WIPOffset<Color<'a>>>,
    pub center: Option<&'a Vector2f>,
    pub radius: f32,
    pub start_angle: f32,
    pub end_angle: f32,
}
impl<'a> Default for ArcArgs<'a> {
  #[inline]
  fn default() -> Self {
    ArcArgs {
      color: None,
      center: None, // required field
      radius: 0.0,
      start_angle: 0.0,
      end_angle: 0.0,
    }
  }
}

pub struct ArcBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ArcBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_color(&mut self, color: flatbuffers::WIPOffset<Color<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Color>>(Arc::VT_COLOR, color);
  }
  #[inline]
  pub fn add_center(&mut self, center: &Vector2f) {
    self.fbb_.push_slot_always::<&Vector2f>(Arc::VT_CENTER, center);
  }
  #[inline]
  pub fn add_radius(&mut self, radius: f32) {
    self.fbb_.push_slot::<f32>(Arc::VT_RADIUS, radius, 0.0);
  }
  #[inline]
  pub fn add_start_angle(&mut self, start_angle: f32) {
    self.fbb_.push_slot::<f32>(Arc::VT_START_ANGLE, start_angle, 0.0);
  }
  #[inline]
  pub fn add_end_angle(&mut self, end_angle: f32) {
    self.fbb_.push_slot::<f32>(Arc::VT_END_ANGLE, end_angle, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ArcBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ArcBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Arc<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Arc::VT_CENTER,"center");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Arc<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Arc");
      ds.field("color", &self.color());
      ds.field("center", &self.center());
      ds.field("radius", &self.radius());
      ds.field("start_angle", &self.start_angle());
      ds.field("end_angle", &self.end_angle());
      ds.finish()
  }
}
pub enum CircleSegmentOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CircleSegment<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CircleSegment<'a> {
  type Inner = CircleSegment<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CircleSegment<'a> {
  pub const VT_COLOR: flatbuffers::VOffsetT = 4;
  pub const VT_CENTER: flatbuffers::VOffsetT = 6;
  pub const VT_RADIUS: flatbuffers::VOffsetT = 8;
  pub const VT_START_ANGLE: flatbuffers::VOffsetT = 10;
  pub const VT_END_ANGLE: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CircleSegment { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CircleSegmentArgs<'args>
  ) -> flatbuffers::WIPOffset<CircleSegment<'bldr>> {
    let mut builder = CircleSegmentBuilder::new(_fbb);
    builder.add_end_angle(args.end_angle);
    builder.add_start_angle(args.start_angle);
    builder.add_radius(args.radius);
    if let Some(x) = args.center { builder.add_center(x); }
    if let Some(x) = args.color { builder.add_color(x); }
    builder.finish()
  }


  #[inline]
  pub fn color(&self) -> Option<Color<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Color>>(CircleSegment::VT_COLOR, None)}
  }
  #[inline]
  pub fn center(&self) -> &'a Vector2f {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector2f>(CircleSegment::VT_CENTER, None).unwrap()}
  }
  #[inline]
  pub fn radius(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(CircleSegment::VT_RADIUS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn start_angle(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(CircleSegment::VT_START_ANGLE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn end_angle(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(CircleSegment::VT_END_ANGLE, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for CircleSegment<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Color>>("color", Self::VT_COLOR, false)?
     .visit_field::<Vector2f>("center", Self::VT_CENTER, true)?
     .visit_field::<f32>("radius", Self::VT_RADIUS, false)?
     .visit_field::<f32>("start_angle", Self::VT_START_ANGLE, false)?
     .visit_field::<f32>("end_angle", Self::VT_END_ANGLE, false)?
     .finish();
    Ok(())
  }
}
pub struct CircleSegmentArgs<'a> {
    pub color: Option<flatbuffers::WIPOffset<Color<'a>>>,
    pub center: Option<&'a Vector2f>,
    pub radius: f32,
    pub start_angle: f32,
    pub end_angle: f32,
}
impl<'a> Default for CircleSegmentArgs<'a> {
  #[inline]
  fn default() -> Self {
    CircleSegmentArgs {
      color: None,
      center: None, // required field
      radius: 0.0,
      start_angle: 0.0,
      end_angle: 0.0,
    }
  }
}

pub struct CircleSegmentBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CircleSegmentBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_color(&mut self, color: flatbuffers::WIPOffset<Color<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Color>>(CircleSegment::VT_COLOR, color);
  }
  #[inline]
  pub fn add_center(&mut self, center: &Vector2f) {
    self.fbb_.push_slot_always::<&Vector2f>(CircleSegment::VT_CENTER, center);
  }
  #[inline]
  pub fn add_radius(&mut self, radius: f32) {
    self.fbb_.push_slot::<f32>(CircleSegment::VT_RADIUS, radius, 0.0);
  }
  #[inline]
  pub fn add_start_angle(&mut self, start_angle: f32) {
    self.fbb_.push_slot::<f32>(CircleSegment::VT_START_ANGLE, start_angle, 0.0);
  }
  #[inline]
  pub fn add_end_angle(&mut self, end_angle: f32) {
    self.fbb_.push_slot::<f32>(CircleSegment::VT_END_ANGLE, end_angle, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CircleSegmentBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CircleSegmentBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CircleSegment<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, CircleSegment::VT_CENTER,"center");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CircleSegment<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CircleSegment");
      ds.field("color", &self.color());
      ds.field("center", &self.center());
      ds.field("radius", &self.radius());
      ds.field("start_angle", &self.start_angle());
      ds.field("end_angle", &self.end_angle());
      ds.finish()
  }
}
pub enum TilesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Tiles<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Tiles<'a> {
  type Inner = Tiles<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Tiles<'a> {
  pub const VT_POSITION: flatbuffers::VOffsetT = 4;
  pub const VT_CELL_SIZE: flatbuffers::VOffsetT = 6;
  pub const VT_ROW_SIZE: flatbuffers::VOffsetT = 8;
  pub const VT_COLORS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Tiles { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TilesArgs<'args>
  ) -> flatbuffers::WIPOffset<Tiles<'bldr>> {
    let mut builder = TilesBuilder::new(_fbb);
    if let Some(x) = args.colors { builder.add_colors(x); }
    if let Some(x) = args.cell_size { builder.add_cell_size(x); }
    if let Some(x) = args.position { builder.add_position(x); }
    builder.add_row_size(args.row_size);
    builder.finish()
  }


  #[inline]
  pub fn position(&self) -> &'a Vector2f {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector2f>(Tiles::VT_POSITION, None).unwrap()}
  }
  #[inline]
  pub fn cell_size(&self) -> &'a Vector2f {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector2f>(Tiles::VT_CELL_SIZE, None).unwrap()}
  }
  #[inline]
  pub fn row_size(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(Tiles::VT_ROW_SIZE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn colors(&self) -> flatbuffers::Vector<'a, u32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(Tiles::VT_COLORS, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Tiles<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Vector2f>("position", Self::VT_POSITION, true)?
     .visit_field::<Vector2f>("cell_size", Self::VT_CELL_SIZE, true)?
     .visit_field::<u16>("row_size", Self::VT_ROW_SIZE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("colors", Self::VT_COLORS, true)?
     .finish();
    Ok(())
  }
}
pub struct TilesArgs<'a> {
    pub position: Option<&'a Vector2f>,
    pub cell_size: Option<&'a Vector2f>,
    pub row_size: u16,
    pub colors: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
}
impl<'a> Default for TilesArgs<'a> {
  #[inline]
  fn default() -> Self {
    TilesArgs {
      position: None, // required field
      cell_size: None, // required field
      row_size: 0,
      colors: None, // required field
    }
  }
}

pub struct TilesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TilesBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_position(&mut self, position: &Vector2f) {
    self.fbb_.push_slot_always::<&Vector2f>(Tiles::VT_POSITION, position);
  }
  #[inline]
  pub fn add_cell_size(&mut self, cell_size: &Vector2f) {
    self.fbb_.push_slot_always::<&Vector2f>(Tiles::VT_CELL_SIZE, cell_size);
  }
  #[inline]
  pub fn add_row_size(&mut self, row_size: u16) {
    self.fbb_.push_slot::<u16>(Tiles::VT_ROW_SIZE, row_size, 0);
  }
  #[inline]
  pub fn add_colors(&mut self, colors: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Tiles::VT_COLORS, colors);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TilesBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TilesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Tiles<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Tiles::VT_POSITION,"position");
    self.fbb_.required(o, Tiles::VT_CELL_SIZE,"cell_size");
    self.fbb_.required(o, Tiles::VT_COLORS,"colors");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Tiles<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Tiles");
      ds.field("position", &self.position());
      ds.field("cell_size", &self.cell_size());
      ds.field("row_size", &self.row_size());
      ds.field("colors", &self.colors());
      ds.finish()
  }
}
pub enum RectangleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Rectangle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Rectangle<'a> {
  type Inner = Rectangle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Rectangle<'a> {
  pub const VT_COLOR: flatbuffers::VOffsetT = 4;
  pub const VT_POSITION: flatbuffers::VOffsetT = 6;
  pub const VT_SIZE_: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Rectangle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RectangleArgs<'args>
  ) -> flatbuffers::WIPOffset<Rectangle<'bldr>> {
    let mut builder = RectangleBuilder::new(_fbb);
    if let Some(x) = args.size_ { builder.add_size_(x); }
    if let Some(x) = args.position { builder.add_position(x); }
    if let Some(x) = args.color { builder.add_color(x); }
    builder.finish()
  }


  #[inline]
  pub fn color(&self) -> Option<Color<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Color>>(Rectangle::VT_COLOR, None)}
  }
  #[inline]
  pub fn position(&self) -> &'a Vector2f {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector2f>(Rectangle::VT_POSITION, None).unwrap()}
  }
  #[inline]
  pub fn size_(&self) -> &'a Vector2f {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector2f>(Rectangle::VT_SIZE_, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Rectangle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Color>>("color", Self::VT_COLOR, false)?
     .visit_field::<Vector2f>("position", Self::VT_POSITION, true)?
     .visit_field::<Vector2f>("size_", Self::VT_SIZE_, true)?
     .finish();
    Ok(())
  }
}
pub struct RectangleArgs<'a> {
    pub color: Option<flatbuffers::WIPOffset<Color<'a>>>,
    pub position: Option<&'a Vector2f>,
    pub size_: Option<&'a Vector2f>,
}
impl<'a> Default for RectangleArgs<'a> {
  #[inline]
  fn default() -> Self {
    RectangleArgs {
      color: None,
      position: None, // required field
      size_: None, // required field
    }
  }
}

pub struct RectangleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RectangleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_color(&mut self, color: flatbuffers::WIPOffset<Color<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Color>>(Rectangle::VT_COLOR, color);
  }
  #[inline]
  pub fn add_position(&mut self, position: &Vector2f) {
    self.fbb_.push_slot_always::<&Vector2f>(Rectangle::VT_POSITION, position);
  }
  #[inline]
  pub fn add_size_(&mut self, size_: &Vector2f) {
    self.fbb_.push_slot_always::<&Vector2f>(Rectangle::VT_SIZE_, size_);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RectangleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RectangleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Rectangle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Rectangle::VT_POSITION,"position");
    self.fbb_.required(o, Rectangle::VT_SIZE_,"size_");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Rectangle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Rectangle");
      ds.field("color", &self.color());
      ds.field("position", &self.position());
      ds.field("size_", &self.size_());
      ds.finish()
  }
}
pub enum TriangleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Triangle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Triangle<'a> {
  type Inner = Triangle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Triangle<'a> {
  pub const VT_COLOR: flatbuffers::VOffsetT = 4;
  pub const VT_POINTS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Triangle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TriangleArgs<'args>
  ) -> flatbuffers::WIPOffset<Triangle<'bldr>> {
    let mut builder = TriangleBuilder::new(_fbb);
    if let Some(x) = args.points { builder.add_points(x); }
    if let Some(x) = args.color { builder.add_color(x); }
    builder.finish()
  }


  #[inline]
  pub fn color(&self) -> Option<Color<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Color>>(Triangle::VT_COLOR, None)}
  }
  #[inline]
  pub fn points(&self) -> flatbuffers::Vector<'a, Vector2f> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Vector2f>>>(Triangle::VT_POINTS, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Triangle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Color>>("color", Self::VT_COLOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Vector2f>>>("points", Self::VT_POINTS, true)?
     .finish();
    Ok(())
  }
}
pub struct TriangleArgs<'a> {
    pub color: Option<flatbuffers::WIPOffset<Color<'a>>>,
    pub points: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Vector2f>>>,
}
impl<'a> Default for TriangleArgs<'a> {
  #[inline]
  fn default() -> Self {
    TriangleArgs {
      color: None,
      points: None, // required field
    }
  }
}

pub struct TriangleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TriangleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_color(&mut self, color: flatbuffers::WIPOffset<Color<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Color>>(Triangle::VT_COLOR, color);
  }
  #[inline]
  pub fn add_points(&mut self, points: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Vector2f>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Triangle::VT_POINTS, points);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TriangleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TriangleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Triangle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Triangle::VT_POINTS,"points");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Triangle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Triangle");
      ds.field("color", &self.color());
      ds.field("points", &self.points());
      ds.finish()
  }
}
pub enum PolylineOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Polyline<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Polyline<'a> {
  type Inner = Polyline<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Polyline<'a> {
  pub const VT_COLOR: flatbuffers::VOffsetT = 4;
  pub const VT_POINTS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Polyline { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PolylineArgs<'args>
  ) -> flatbuffers::WIPOffset<Polyline<'bldr>> {
    let mut builder = PolylineBuilder::new(_fbb);
    if let Some(x) = args.points { builder.add_points(x); }
    if let Some(x) = args.color { builder.add_color(x); }
    builder.finish()
  }


  #[inline]
  pub fn color(&self) -> Option<Color<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Color>>(Polyline::VT_COLOR, None)}
  }
  #[inline]
  pub fn points(&self) -> flatbuffers::Vector<'a, Vector2f> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Vector2f>>>(Polyline::VT_POINTS, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Polyline<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Color>>("color", Self::VT_COLOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Vector2f>>>("points", Self::VT_POINTS, true)?
     .finish();
    Ok(())
  }
}
pub struct PolylineArgs<'a> {
    pub color: Option<flatbuffers::WIPOffset<Color<'a>>>,
    pub points: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Vector2f>>>,
}
impl<'a> Default for PolylineArgs<'a> {
  #[inline]
  fn default() -> Self {
    PolylineArgs {
      color: None,
      points: None, // required field
    }
  }
}

pub struct PolylineBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PolylineBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_color(&mut self, color: flatbuffers::WIPOffset<Color<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Color>>(Polyline::VT_COLOR, color);
  }
  #[inline]
  pub fn add_points(&mut self, points: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Vector2f>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Polyline::VT_POINTS, points);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PolylineBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PolylineBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Polyline<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Polyline::VT_POINTS,"points");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Polyline<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Polyline");
      ds.field("color", &self.color());
      ds.field("points", &self.points());
      ds.finish()
  }
}
pub enum LogTextOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LogText<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LogText<'a> {
  type Inner = LogText<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LogText<'a> {
  pub const VT_TEXT: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LogText { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LogTextArgs<'args>
  ) -> flatbuffers::WIPOffset<LogText<'bldr>> {
    let mut builder = LogTextBuilder::new(_fbb);
    if let Some(x) = args.text { builder.add_text(x); }
    builder.finish()
  }


  #[inline]
  pub fn text(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogText::VT_TEXT, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for LogText<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("text", Self::VT_TEXT, true)?
     .finish();
    Ok(())
  }
}
pub struct LogTextArgs<'a> {
    pub text: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for LogTextArgs<'a> {
  #[inline]
  fn default() -> Self {
    LogTextArgs {
      text: None, // required field
    }
  }
}

pub struct LogTextBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LogTextBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_text(&mut self, text: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogText::VT_TEXT, text);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LogTextBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LogTextBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LogText<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, LogText::VT_TEXT,"text");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LogText<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LogText");
      ds.field("text", &self.text());
      ds.finish()
  }
}
pub enum PopupOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Popup<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Popup<'a> {
  type Inner = Popup<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Popup<'a> {
  pub const VT_TEXT: flatbuffers::VOffsetT = 4;
  pub const VT_AREA_POSITION: flatbuffers::VOffsetT = 6;
  pub const VT_AREA_SIZE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Popup { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PopupArgs<'args>
  ) -> flatbuffers::WIPOffset<Popup<'bldr>> {
    let mut builder = PopupBuilder::new(_fbb);
    if let Some(x) = args.area_size { builder.add_area_size(x); }
    if let Some(x) = args.area_position { builder.add_area_position(x); }
    if let Some(x) = args.text { builder.add_text(x); }
    builder.finish()
  }


  #[inline]
  pub fn text(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Popup::VT_TEXT, None).unwrap()}
  }
  #[inline]
  pub fn area_position(&self) -> &'a Vector2f {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector2f>(Popup::VT_AREA_POSITION, None).unwrap()}
  }
  #[inline]
  pub fn area_size(&self) -> &'a Vector2f {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector2f>(Popup::VT_AREA_SIZE, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Popup<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("text", Self::VT_TEXT, true)?
     .visit_field::<Vector2f>("area_position", Self::VT_AREA_POSITION, true)?
     .visit_field::<Vector2f>("area_size", Self::VT_AREA_SIZE, true)?
     .finish();
    Ok(())
  }
}
pub struct PopupArgs<'a> {
    pub text: Option<flatbuffers::WIPOffset<&'a str>>,
    pub area_position: Option<&'a Vector2f>,
    pub area_size: Option<&'a Vector2f>,
}
impl<'a> Default for PopupArgs<'a> {
  #[inline]
  fn default() -> Self {
    PopupArgs {
      text: None, // required field
      area_position: None, // required field
      area_size: None, // required field
    }
  }
}

pub struct PopupBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PopupBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_text(&mut self, text: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Popup::VT_TEXT, text);
  }
  #[inline]
  pub fn add_area_position(&mut self, area_position: &Vector2f) {
    self.fbb_.push_slot_always::<&Vector2f>(Popup::VT_AREA_POSITION, area_position);
  }
  #[inline]
  pub fn add_area_size(&mut self, area_size: &Vector2f) {
    self.fbb_.push_slot_always::<&Vector2f>(Popup::VT_AREA_SIZE, area_size);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PopupBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PopupBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Popup<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Popup::VT_TEXT,"text");
    self.fbb_.required(o, Popup::VT_AREA_POSITION,"area_position");
    self.fbb_.required(o, Popup::VT_AREA_SIZE,"area_size");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Popup<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Popup");
      ds.field("text", &self.text());
      ds.field("area_position", &self.area_position());
      ds.field("area_size", &self.area_size());
      ds.finish()
  }
}
pub enum PopupRoundOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PopupRound<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PopupRound<'a> {
  type Inner = PopupRound<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PopupRound<'a> {
  pub const VT_TEXT: flatbuffers::VOffsetT = 4;
  pub const VT_AREA_CENTER: flatbuffers::VOffsetT = 6;
  pub const VT_AREA_RADIUS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PopupRound { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PopupRoundArgs<'args>
  ) -> flatbuffers::WIPOffset<PopupRound<'bldr>> {
    let mut builder = PopupRoundBuilder::new(_fbb);
    builder.add_area_radius(args.area_radius);
    if let Some(x) = args.area_center { builder.add_area_center(x); }
    if let Some(x) = args.text { builder.add_text(x); }
    builder.finish()
  }


  #[inline]
  pub fn text(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PopupRound::VT_TEXT, None).unwrap()}
  }
  #[inline]
  pub fn area_center(&self) -> &'a Vector2f {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector2f>(PopupRound::VT_AREA_CENTER, None).unwrap()}
  }
  #[inline]
  pub fn area_radius(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(PopupRound::VT_AREA_RADIUS, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for PopupRound<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("text", Self::VT_TEXT, true)?
     .visit_field::<Vector2f>("area_center", Self::VT_AREA_CENTER, true)?
     .visit_field::<f32>("area_radius", Self::VT_AREA_RADIUS, false)?
     .finish();
    Ok(())
  }
}
pub struct PopupRoundArgs<'a> {
    pub text: Option<flatbuffers::WIPOffset<&'a str>>,
    pub area_center: Option<&'a Vector2f>,
    pub area_radius: f32,
}
impl<'a> Default for PopupRoundArgs<'a> {
  #[inline]
  fn default() -> Self {
    PopupRoundArgs {
      text: None, // required field
      area_center: None, // required field
      area_radius: 0.0,
    }
  }
}

pub struct PopupRoundBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PopupRoundBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_text(&mut self, text: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PopupRound::VT_TEXT, text);
  }
  #[inline]
  pub fn add_area_center(&mut self, area_center: &Vector2f) {
    self.fbb_.push_slot_always::<&Vector2f>(PopupRound::VT_AREA_CENTER, area_center);
  }
  #[inline]
  pub fn add_area_radius(&mut self, area_radius: f32) {
    self.fbb_.push_slot::<f32>(PopupRound::VT_AREA_RADIUS, area_radius, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PopupRoundBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PopupRoundBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PopupRound<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, PopupRound::VT_TEXT,"text");
    self.fbb_.required(o, PopupRound::VT_AREA_CENTER,"area_center");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PopupRound<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PopupRound");
      ds.field("text", &self.text());
      ds.field("area_center", &self.area_center());
      ds.field("area_radius", &self.area_radius());
      ds.finish()
  }
}
pub enum CameraViewOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CameraView<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CameraView<'a> {
  type Inner = CameraView<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CameraView<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_POSITION: flatbuffers::VOffsetT = 6;
  pub const VT_VIEW_RADIUS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CameraView { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CameraViewArgs<'args>
  ) -> flatbuffers::WIPOffset<CameraView<'bldr>> {
    let mut builder = CameraViewBuilder::new(_fbb);
    builder.add_view_radius(args.view_radius);
    if let Some(x) = args.position { builder.add_position(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CameraView::VT_NAME, None).unwrap()}
  }
  #[inline]
  pub fn position(&self) -> &'a Vector2f {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector2f>(CameraView::VT_POSITION, None).unwrap()}
  }
  #[inline]
  pub fn view_radius(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(CameraView::VT_VIEW_RADIUS, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for CameraView<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, true)?
     .visit_field::<Vector2f>("position", Self::VT_POSITION, true)?
     .visit_field::<f32>("view_radius", Self::VT_VIEW_RADIUS, false)?
     .finish();
    Ok(())
  }
}
pub struct CameraViewArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub position: Option<&'a Vector2f>,
    pub view_radius: f32,
}
impl<'a> Default for CameraViewArgs<'a> {
  #[inline]
  fn default() -> Self {
    CameraViewArgs {
      name: None, // required field
      position: None, // required field
      view_radius: 0.0,
    }
  }
}

pub struct CameraViewBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CameraViewBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CameraView::VT_NAME, name);
  }
  #[inline]
  pub fn add_position(&mut self, position: &Vector2f) {
    self.fbb_.push_slot_always::<&Vector2f>(CameraView::VT_POSITION, position);
  }
  #[inline]
  pub fn add_view_radius(&mut self, view_radius: f32) {
    self.fbb_.push_slot::<f32>(CameraView::VT_VIEW_RADIUS, view_radius, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CameraViewBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CameraViewBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CameraView<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, CameraView::VT_NAME,"name");
    self.fbb_.required(o, CameraView::VT_POSITION,"position");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CameraView<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CameraView");
      ds.field("name", &self.name());
      ds.field("position", &self.position());
      ds.field("view_radius", &self.view_radius());
      ds.finish()
  }
}
pub enum LayerOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Layer<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Layer<'a> {
  type Inner = Layer<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Layer<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_USE_PERMANENT_FRAME: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Layer { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LayerArgs
  ) -> flatbuffers::WIPOffset<Layer<'bldr>> {
    let mut builder = LayerBuilder::new(_fbb);
    builder.add_id(args.id);
    builder.add_use_permanent_frame(args.use_permanent_frame);
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Layer::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn use_permanent_frame(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Layer::VT_USE_PERMANENT_FRAME, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Layer<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("id", Self::VT_ID, false)?
     .visit_field::<bool>("use_permanent_frame", Self::VT_USE_PERMANENT_FRAME, false)?
     .finish();
    Ok(())
  }
}
pub struct LayerArgs {
    pub id: u32,
    pub use_permanent_frame: bool,
}
impl<'a> Default for LayerArgs {
  #[inline]
  fn default() -> Self {
    LayerArgs {
      id: 0,
      use_permanent_frame: false,
    }
  }
}

pub struct LayerBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LayerBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: u32) {
    self.fbb_.push_slot::<u32>(Layer::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_use_permanent_frame(&mut self, use_permanent_frame: bool) {
    self.fbb_.push_slot::<bool>(Layer::VT_USE_PERMANENT_FRAME, use_permanent_frame, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LayerBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LayerBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Layer<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Layer<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Layer");
      ds.field("id", &self.id());
      ds.field("use_permanent_frame", &self.use_permanent_frame());
      ds.finish()
  }
}
pub enum MapOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Map<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Map<'a> {
  type Inner = Map<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Map<'a> {
  pub const VT_POSITION: flatbuffers::VOffsetT = 4;
  pub const VT_SIZE_: flatbuffers::VOffsetT = 6;
  pub const VT_X_GRID: flatbuffers::VOffsetT = 8;
  pub const VT_Y_GRID: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Map { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MapArgs<'args>
  ) -> flatbuffers::WIPOffset<Map<'bldr>> {
    let mut builder = MapBuilder::new(_fbb);
    if let Some(x) = args.size_ { builder.add_size_(x); }
    if let Some(x) = args.position { builder.add_position(x); }
    builder.add_y_grid(args.y_grid);
    builder.add_x_grid(args.x_grid);
    builder.finish()
  }


  #[inline]
  pub fn position(&self) -> &'a Vector2f {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector2f>(Map::VT_POSITION, None).unwrap()}
  }
  #[inline]
  pub fn size_(&self) -> &'a Vector2f {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector2f>(Map::VT_SIZE_, None).unwrap()}
  }
  #[inline]
  pub fn x_grid(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(Map::VT_X_GRID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn y_grid(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(Map::VT_Y_GRID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Map<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Vector2f>("position", Self::VT_POSITION, true)?
     .visit_field::<Vector2f>("size_", Self::VT_SIZE_, true)?
     .visit_field::<u16>("x_grid", Self::VT_X_GRID, false)?
     .visit_field::<u16>("y_grid", Self::VT_Y_GRID, false)?
     .finish();
    Ok(())
  }
}
pub struct MapArgs<'a> {
    pub position: Option<&'a Vector2f>,
    pub size_: Option<&'a Vector2f>,
    pub x_grid: u16,
    pub y_grid: u16,
}
impl<'a> Default for MapArgs<'a> {
  #[inline]
  fn default() -> Self {
    MapArgs {
      position: None, // required field
      size_: None, // required field
      x_grid: 0,
      y_grid: 0,
    }
  }
}

pub struct MapBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MapBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_position(&mut self, position: &Vector2f) {
    self.fbb_.push_slot_always::<&Vector2f>(Map::VT_POSITION, position);
  }
  #[inline]
  pub fn add_size_(&mut self, size_: &Vector2f) {
    self.fbb_.push_slot_always::<&Vector2f>(Map::VT_SIZE_, size_);
  }
  #[inline]
  pub fn add_x_grid(&mut self, x_grid: u16) {
    self.fbb_.push_slot::<u16>(Map::VT_X_GRID, x_grid, 0);
  }
  #[inline]
  pub fn add_y_grid(&mut self, y_grid: u16) {
    self.fbb_.push_slot::<u16>(Map::VT_Y_GRID, y_grid, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MapBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MapBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Map<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Map::VT_POSITION,"position");
    self.fbb_.required(o, Map::VT_SIZE_,"size_");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Map<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Map");
      ds.field("position", &self.position());
      ds.field("size_", &self.size_());
      ds.field("x_grid", &self.x_grid());
      ds.field("y_grid", &self.y_grid());
      ds.finish()
  }
}
pub enum OptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Options<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Options<'a> {
  type Inner = Options<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Options<'a> {
  pub const VT_MAP: flatbuffers::VOffsetT = 4;
  pub const VT_LAYER: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Options { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args OptionsArgs<'args>
  ) -> flatbuffers::WIPOffset<Options<'bldr>> {
    let mut builder = OptionsBuilder::new(_fbb);
    if let Some(x) = args.layer { builder.add_layer(x); }
    if let Some(x) = args.map { builder.add_map(x); }
    builder.finish()
  }


  #[inline]
  pub fn map(&self) -> Option<Map<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Map>>(Options::VT_MAP, None)}
  }
  #[inline]
  pub fn layer(&self) -> Option<Layer<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Layer>>(Options::VT_LAYER, None)}
  }
}

impl flatbuffers::Verifiable for Options<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Map>>("map", Self::VT_MAP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Layer>>("layer", Self::VT_LAYER, false)?
     .finish();
    Ok(())
  }
}
pub struct OptionsArgs<'a> {
    pub map: Option<flatbuffers::WIPOffset<Map<'a>>>,
    pub layer: Option<flatbuffers::WIPOffset<Layer<'a>>>,
}
impl<'a> Default for OptionsArgs<'a> {
  #[inline]
  fn default() -> Self {
    OptionsArgs {
      map: None,
      layer: None,
    }
  }
}

pub struct OptionsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> OptionsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_map(&mut self, map: flatbuffers::WIPOffset<Map<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Map>>(Options::VT_MAP, map);
  }
  #[inline]
  pub fn add_layer(&mut self, layer: flatbuffers::WIPOffset<Layer<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Layer>>(Options::VT_LAYER, layer);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> OptionsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    OptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Options<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Options<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Options");
      ds.field("map", &self.map());
      ds.field("layer", &self.layer());
      ds.finish()
  }
}
pub enum SubscribeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Subscribe<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Subscribe<'a> {
  type Inner = Subscribe<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Subscribe<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_KEY: flatbuffers::VOffsetT = 6;
  pub const VT_CONTINUOUS: flatbuffers::VOffsetT = 8;
  pub const VT_CAPTURE_MOUSE: flatbuffers::VOffsetT = 10;
  pub const VT_MIN_POSITION_CHANGE: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Subscribe { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SubscribeArgs<'args>
  ) -> flatbuffers::WIPOffset<Subscribe<'bldr>> {
    let mut builder = SubscribeBuilder::new(_fbb);
    builder.add_min_position_change(args.min_position_change);
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_capture_mouse(args.capture_mouse);
    builder.add_continuous(args.continuous);
    builder.add_key(args.key);
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Subscribe::VT_NAME, None)}
  }
  #[inline]
  pub fn key(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(Subscribe::VT_KEY, Some(0)).unwrap()}
  }
  #[inline]
  pub fn continuous(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Subscribe::VT_CONTINUOUS, Some(false)).unwrap()}
  }
  #[inline]
  pub fn capture_mouse(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Subscribe::VT_CAPTURE_MOUSE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn min_position_change(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Subscribe::VT_MIN_POSITION_CHANGE, Some(0.001)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Subscribe<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<i8>("key", Self::VT_KEY, false)?
     .visit_field::<bool>("continuous", Self::VT_CONTINUOUS, false)?
     .visit_field::<bool>("capture_mouse", Self::VT_CAPTURE_MOUSE, false)?
     .visit_field::<f32>("min_position_change", Self::VT_MIN_POSITION_CHANGE, false)?
     .finish();
    Ok(())
  }
}
pub struct SubscribeArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub key: i8,
    pub continuous: bool,
    pub capture_mouse: bool,
    pub min_position_change: f32,
}
impl<'a> Default for SubscribeArgs<'a> {
  #[inline]
  fn default() -> Self {
    SubscribeArgs {
      name: None,
      key: 0,
      continuous: false,
      capture_mouse: false,
      min_position_change: 0.001,
    }
  }
}

pub struct SubscribeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SubscribeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Subscribe::VT_NAME, name);
  }
  #[inline]
  pub fn add_key(&mut self, key: i8) {
    self.fbb_.push_slot::<i8>(Subscribe::VT_KEY, key, 0);
  }
  #[inline]
  pub fn add_continuous(&mut self, continuous: bool) {
    self.fbb_.push_slot::<bool>(Subscribe::VT_CONTINUOUS, continuous, false);
  }
  #[inline]
  pub fn add_capture_mouse(&mut self, capture_mouse: bool) {
    self.fbb_.push_slot::<bool>(Subscribe::VT_CAPTURE_MOUSE, capture_mouse, false);
  }
  #[inline]
  pub fn add_min_position_change(&mut self, min_position_change: f32) {
    self.fbb_.push_slot::<f32>(Subscribe::VT_MIN_POSITION_CHANGE, min_position_change, 0.001);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SubscribeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SubscribeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Subscribe<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Subscribe<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Subscribe");
      ds.field("name", &self.name());
      ds.field("key", &self.key());
      ds.field("continuous", &self.continuous());
      ds.field("capture_mouse", &self.capture_mouse());
      ds.field("min_position_change", &self.min_position_change());
      ds.finish()
  }
}
pub enum UnsubscribeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Unsubscribe<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Unsubscribe<'a> {
  type Inner = Unsubscribe<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Unsubscribe<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Unsubscribe { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args UnsubscribeArgs
  ) -> flatbuffers::WIPOffset<Unsubscribe<'bldr>> {
    let mut builder = UnsubscribeBuilder::new(_fbb);
    builder.add_key(args.key);
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(Unsubscribe::VT_KEY, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Unsubscribe<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i8>("key", Self::VT_KEY, false)?
     .finish();
    Ok(())
  }
}
pub struct UnsubscribeArgs {
    pub key: i8,
}
impl<'a> Default for UnsubscribeArgs {
  #[inline]
  fn default() -> Self {
    UnsubscribeArgs {
      key: 0,
    }
  }
}

pub struct UnsubscribeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> UnsubscribeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: i8) {
    self.fbb_.push_slot::<i8>(Unsubscribe::VT_KEY, key, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> UnsubscribeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    UnsubscribeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Unsubscribe<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Unsubscribe<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Unsubscribe");
      ds.field("key", &self.key());
      ds.finish()
  }
}
pub enum ReadEventsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ReadEvents<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReadEvents<'a> {
  type Inner = ReadEvents<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ReadEvents<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ReadEvents { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    _args: &'args ReadEventsArgs
  ) -> flatbuffers::WIPOffset<ReadEvents<'bldr>> {
    let mut builder = ReadEventsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for ReadEvents<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct ReadEventsArgs {
}
impl<'a> Default for ReadEventsArgs {
  #[inline]
  fn default() -> Self {
    ReadEventsArgs {
    }
  }
}

pub struct ReadEventsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ReadEventsBuilder<'a, 'b, A> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ReadEventsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ReadEventsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ReadEvents<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ReadEvents<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ReadEvents");
      ds.finish()
  }
}
pub enum EndFrameOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct EndFrame<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EndFrame<'a> {
  type Inner = EndFrame<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> EndFrame<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EndFrame { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    _args: &'args EndFrameArgs
  ) -> flatbuffers::WIPOffset<EndFrame<'bldr>> {
    let mut builder = EndFrameBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for EndFrame<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct EndFrameArgs {
}
impl<'a> Default for EndFrameArgs {
  #[inline]
  fn default() -> Self {
    EndFrameArgs {
    }
  }
}

pub struct EndFrameBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EndFrameBuilder<'a, 'b, A> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> EndFrameBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    EndFrameBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EndFrame<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EndFrame<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EndFrame");
      ds.finish()
  }
}
pub enum ColorPointOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ColorPoint<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ColorPoint<'a> {
  type Inner = ColorPoint<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ColorPoint<'a> {
  pub const VT_COLOR: flatbuffers::VOffsetT = 4;
  pub const VT_POSITION: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ColorPoint { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ColorPointArgs<'args>
  ) -> flatbuffers::WIPOffset<ColorPoint<'bldr>> {
    let mut builder = ColorPointBuilder::new(_fbb);
    if let Some(x) = args.position { builder.add_position(x); }
    builder.add_color(args.color);
    builder.finish()
  }


  #[inline]
  pub fn color(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ColorPoint::VT_COLOR, Some(0)).unwrap()}
  }
  #[inline]
  pub fn position(&self) -> &'a Vector2f {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector2f>(ColorPoint::VT_POSITION, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for ColorPoint<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("color", Self::VT_COLOR, false)?
     .visit_field::<Vector2f>("position", Self::VT_POSITION, true)?
     .finish();
    Ok(())
  }
}
pub struct ColorPointArgs<'a> {
    pub color: u32,
    pub position: Option<&'a Vector2f>,
}
impl<'a> Default for ColorPointArgs<'a> {
  #[inline]
  fn default() -> Self {
    ColorPointArgs {
      color: 0,
      position: None, // required field
    }
  }
}

pub struct ColorPointBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ColorPointBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_color(&mut self, color: u32) {
    self.fbb_.push_slot::<u32>(ColorPoint::VT_COLOR, color, 0);
  }
  #[inline]
  pub fn add_position(&mut self, position: &Vector2f) {
    self.fbb_.push_slot_always::<&Vector2f>(ColorPoint::VT_POSITION, position);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ColorPointBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ColorPointBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ColorPoint<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, ColorPoint::VT_POSITION,"position");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ColorPoint<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ColorPoint");
      ds.field("color", &self.color());
      ds.field("position", &self.position());
      ds.finish()
  }
}
pub enum PrimitiveStorageOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PrimitiveStorage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PrimitiveStorage<'a> {
  type Inner = PrimitiveStorage<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PrimitiveStorage<'a> {
  pub const VT_COLOR_VERTEXES: flatbuffers::VOffsetT = 4;
  pub const VT_COLOR_CIRCLES: flatbuffers::VOffsetT = 6;
  pub const VT_VERTEXES: flatbuffers::VOffsetT = 8;
  pub const VT_CIRCLES: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PrimitiveStorage { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PrimitiveStorageArgs<'args>
  ) -> flatbuffers::WIPOffset<PrimitiveStorage<'bldr>> {
    let mut builder = PrimitiveStorageBuilder::new(_fbb);
    if let Some(x) = args.circles { builder.add_circles(x); }
    if let Some(x) = args.vertexes { builder.add_vertexes(x); }
    if let Some(x) = args.color_circles { builder.add_color_circles(x); }
    if let Some(x) = args.color_vertexes { builder.add_color_vertexes(x); }
    builder.finish()
  }


  #[inline]
  pub fn color_vertexes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ColorPoint<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ColorPoint>>>>(PrimitiveStorage::VT_COLOR_VERTEXES, None)}
  }
  #[inline]
  pub fn color_circles(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CircleSegment<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CircleSegment>>>>(PrimitiveStorage::VT_COLOR_CIRCLES, None)}
  }
  #[inline]
  pub fn vertexes(&self) -> Option<flatbuffers::Vector<'a, Vector2f>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Vector2f>>>(PrimitiveStorage::VT_VERTEXES, None)}
  }
  #[inline]
  pub fn circles(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CircleSegment<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CircleSegment>>>>(PrimitiveStorage::VT_CIRCLES, None)}
  }
}

impl flatbuffers::Verifiable for PrimitiveStorage<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ColorPoint>>>>("color_vertexes", Self::VT_COLOR_VERTEXES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CircleSegment>>>>("color_circles", Self::VT_COLOR_CIRCLES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Vector2f>>>("vertexes", Self::VT_VERTEXES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CircleSegment>>>>("circles", Self::VT_CIRCLES, false)?
     .finish();
    Ok(())
  }
}
pub struct PrimitiveStorageArgs<'a> {
    pub color_vertexes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ColorPoint<'a>>>>>,
    pub color_circles: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CircleSegment<'a>>>>>,
    pub vertexes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Vector2f>>>,
    pub circles: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CircleSegment<'a>>>>>,
}
impl<'a> Default for PrimitiveStorageArgs<'a> {
  #[inline]
  fn default() -> Self {
    PrimitiveStorageArgs {
      color_vertexes: None,
      color_circles: None,
      vertexes: None,
      circles: None,
    }
  }
}

pub struct PrimitiveStorageBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PrimitiveStorageBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_color_vertexes(&mut self, color_vertexes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ColorPoint<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PrimitiveStorage::VT_COLOR_VERTEXES, color_vertexes);
  }
  #[inline]
  pub fn add_color_circles(&mut self, color_circles: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CircleSegment<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PrimitiveStorage::VT_COLOR_CIRCLES, color_circles);
  }
  #[inline]
  pub fn add_vertexes(&mut self, vertexes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Vector2f>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PrimitiveStorage::VT_VERTEXES, vertexes);
  }
  #[inline]
  pub fn add_circles(&mut self, circles: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CircleSegment<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PrimitiveStorage::VT_CIRCLES, circles);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PrimitiveStorageBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PrimitiveStorageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PrimitiveStorage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PrimitiveStorage<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PrimitiveStorage");
      ds.field("color_vertexes", &self.color_vertexes());
      ds.field("color_circles", &self.color_circles());
      ds.field("vertexes", &self.vertexes());
      ds.field("circles", &self.circles());
      ds.finish()
  }
}
pub enum PrimitiveIndicesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PrimitiveIndices<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PrimitiveIndices<'a> {
  type Inner = PrimitiveIndices<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PrimitiveIndices<'a> {
  pub const VT_STENCIL_CIRCLES: flatbuffers::VOffsetT = 4;
  pub const VT_STENCIL_SEGMENTS: flatbuffers::VOffsetT = 6;
  pub const VT_STENCIL_TRIANGLES: flatbuffers::VOffsetT = 8;
  pub const VT_FILLED_CIRCLES: flatbuffers::VOffsetT = 10;
  pub const VT_FILLED_SEGMENTS: flatbuffers::VOffsetT = 12;
  pub const VT_THIN_CIRCLES: flatbuffers::VOffsetT = 14;
  pub const VT_TRIANGLES: flatbuffers::VOffsetT = 16;
  pub const VT_LINES: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PrimitiveIndices { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PrimitiveIndicesArgs<'args>
  ) -> flatbuffers::WIPOffset<PrimitiveIndices<'bldr>> {
    let mut builder = PrimitiveIndicesBuilder::new(_fbb);
    if let Some(x) = args.lines { builder.add_lines(x); }
    if let Some(x) = args.triangles { builder.add_triangles(x); }
    if let Some(x) = args.thin_circles { builder.add_thin_circles(x); }
    if let Some(x) = args.filled_segments { builder.add_filled_segments(x); }
    if let Some(x) = args.filled_circles { builder.add_filled_circles(x); }
    if let Some(x) = args.stencil_triangles { builder.add_stencil_triangles(x); }
    if let Some(x) = args.stencil_segments { builder.add_stencil_segments(x); }
    if let Some(x) = args.stencil_circles { builder.add_stencil_circles(x); }
    builder.finish()
  }


  #[inline]
  pub fn stencil_circles(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(PrimitiveIndices::VT_STENCIL_CIRCLES, None)}
  }
  #[inline]
  pub fn stencil_segments(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(PrimitiveIndices::VT_STENCIL_SEGMENTS, None)}
  }
  #[inline]
  pub fn stencil_triangles(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(PrimitiveIndices::VT_STENCIL_TRIANGLES, None)}
  }
  #[inline]
  pub fn filled_circles(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(PrimitiveIndices::VT_FILLED_CIRCLES, None)}
  }
  #[inline]
  pub fn filled_segments(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(PrimitiveIndices::VT_FILLED_SEGMENTS, None)}
  }
  #[inline]
  pub fn thin_circles(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(PrimitiveIndices::VT_THIN_CIRCLES, None)}
  }
  #[inline]
  pub fn triangles(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(PrimitiveIndices::VT_TRIANGLES, None)}
  }
  #[inline]
  pub fn lines(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(PrimitiveIndices::VT_LINES, None)}
  }
}

impl flatbuffers::Verifiable for PrimitiveIndices<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("stencil_circles", Self::VT_STENCIL_CIRCLES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("stencil_segments", Self::VT_STENCIL_SEGMENTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("stencil_triangles", Self::VT_STENCIL_TRIANGLES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("filled_circles", Self::VT_FILLED_CIRCLES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("filled_segments", Self::VT_FILLED_SEGMENTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("thin_circles", Self::VT_THIN_CIRCLES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("triangles", Self::VT_TRIANGLES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("lines", Self::VT_LINES, false)?
     .finish();
    Ok(())
  }
}
pub struct PrimitiveIndicesArgs<'a> {
    pub stencil_circles: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub stencil_segments: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub stencil_triangles: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub filled_circles: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub filled_segments: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub thin_circles: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub triangles: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub lines: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
}
impl<'a> Default for PrimitiveIndicesArgs<'a> {
  #[inline]
  fn default() -> Self {
    PrimitiveIndicesArgs {
      stencil_circles: None,
      stencil_segments: None,
      stencil_triangles: None,
      filled_circles: None,
      filled_segments: None,
      thin_circles: None,
      triangles: None,
      lines: None,
    }
  }
}

pub struct PrimitiveIndicesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PrimitiveIndicesBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_stencil_circles(&mut self, stencil_circles: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PrimitiveIndices::VT_STENCIL_CIRCLES, stencil_circles);
  }
  #[inline]
  pub fn add_stencil_segments(&mut self, stencil_segments: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PrimitiveIndices::VT_STENCIL_SEGMENTS, stencil_segments);
  }
  #[inline]
  pub fn add_stencil_triangles(&mut self, stencil_triangles: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PrimitiveIndices::VT_STENCIL_TRIANGLES, stencil_triangles);
  }
  #[inline]
  pub fn add_filled_circles(&mut self, filled_circles: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PrimitiveIndices::VT_FILLED_CIRCLES, filled_circles);
  }
  #[inline]
  pub fn add_filled_segments(&mut self, filled_segments: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PrimitiveIndices::VT_FILLED_SEGMENTS, filled_segments);
  }
  #[inline]
  pub fn add_thin_circles(&mut self, thin_circles: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PrimitiveIndices::VT_THIN_CIRCLES, thin_circles);
  }
  #[inline]
  pub fn add_triangles(&mut self, triangles: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PrimitiveIndices::VT_TRIANGLES, triangles);
  }
  #[inline]
  pub fn add_lines(&mut self, lines: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PrimitiveIndices::VT_LINES, lines);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PrimitiveIndicesBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PrimitiveIndicesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PrimitiveIndices<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PrimitiveIndices<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PrimitiveIndices");
      ds.field("stencil_circles", &self.stencil_circles());
      ds.field("stencil_segments", &self.stencil_segments());
      ds.field("stencil_triangles", &self.stencil_triangles());
      ds.field("filled_circles", &self.filled_circles());
      ds.field("filled_segments", &self.filled_segments());
      ds.field("thin_circles", &self.thin_circles());
      ds.field("triangles", &self.triangles());
      ds.field("lines", &self.lines());
      ds.finish()
  }
}
pub enum PrimitivesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Primitives<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Primitives<'a> {
  type Inner = Primitives<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Primitives<'a> {
  pub const VT_STORAGE: flatbuffers::VOffsetT = 4;
  pub const VT_INDICES: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Primitives { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PrimitivesArgs<'args>
  ) -> flatbuffers::WIPOffset<Primitives<'bldr>> {
    let mut builder = PrimitivesBuilder::new(_fbb);
    if let Some(x) = args.indices { builder.add_indices(x); }
    if let Some(x) = args.storage { builder.add_storage(x); }
    builder.finish()
  }


  #[inline]
  pub fn storage(&self) -> PrimitiveStorage<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<PrimitiveStorage>>(Primitives::VT_STORAGE, None).unwrap()}
  }
  #[inline]
  pub fn indices(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PrimitiveIndices<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PrimitiveIndices>>>>(Primitives::VT_INDICES, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Primitives<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<PrimitiveStorage>>("storage", Self::VT_STORAGE, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<PrimitiveIndices>>>>("indices", Self::VT_INDICES, true)?
     .finish();
    Ok(())
  }
}
pub struct PrimitivesArgs<'a> {
    pub storage: Option<flatbuffers::WIPOffset<PrimitiveStorage<'a>>>,
    pub indices: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PrimitiveIndices<'a>>>>>,
}
impl<'a> Default for PrimitivesArgs<'a> {
  #[inline]
  fn default() -> Self {
    PrimitivesArgs {
      storage: None, // required field
      indices: None, // required field
    }
  }
}

pub struct PrimitivesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PrimitivesBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_storage(&mut self, storage: flatbuffers::WIPOffset<PrimitiveStorage<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<PrimitiveStorage>>(Primitives::VT_STORAGE, storage);
  }
  #[inline]
  pub fn add_indices(&mut self, indices: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<PrimitiveIndices<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Primitives::VT_INDICES, indices);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PrimitivesBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PrimitivesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Primitives<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Primitives::VT_STORAGE,"storage");
    self.fbb_.required(o, Primitives::VT_INDICES,"indices");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Primitives<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Primitives");
      ds.field("storage", &self.storage());
      ds.field("indices", &self.indices());
      ds.finish()
  }
}
pub enum RewindMessageOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RewindMessage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RewindMessage<'a> {
  type Inner = RewindMessage<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RewindMessage<'a> {
  pub const VT_COMMAND_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_COMMAND: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RewindMessage { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RewindMessageArgs
  ) -> flatbuffers::WIPOffset<RewindMessage<'bldr>> {
    let mut builder = RewindMessageBuilder::new(_fbb);
    if let Some(x) = args.command { builder.add_command(x); }
    builder.add_command_type(args.command_type);
    builder.finish()
  }


  #[inline]
  pub fn command_type(&self) -> Command {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Command>(RewindMessage::VT_COMMAND_TYPE, Some(Command::NONE)).unwrap()}
  }
  #[inline]
  pub fn command(&self) -> flatbuffers::Table<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(RewindMessage::VT_COMMAND, None).unwrap()}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_arc(&self) -> Option<Arc<'a>> {
    if self.command_type() == Command::Arc {
      let u = self.command();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Arc::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_camera_view(&self) -> Option<CameraView<'a>> {
    if self.command_type() == Command::CameraView {
      let u = self.command();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { CameraView::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_circle(&self) -> Option<Circle<'a>> {
    if self.command_type() == Command::Circle {
      let u = self.command();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Circle::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_circle_segment(&self) -> Option<CircleSegment<'a>> {
    if self.command_type() == Command::CircleSegment {
      let u = self.command();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { CircleSegment::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_log_text(&self) -> Option<LogText<'a>> {
    if self.command_type() == Command::LogText {
      let u = self.command();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { LogText::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_options(&self) -> Option<Options<'a>> {
    if self.command_type() == Command::Options {
      let u = self.command();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Options::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_polyline(&self) -> Option<Polyline<'a>> {
    if self.command_type() == Command::Polyline {
      let u = self.command();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Polyline::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_popup(&self) -> Option<Popup<'a>> {
    if self.command_type() == Command::Popup {
      let u = self.command();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Popup::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_popup_round(&self) -> Option<PopupRound<'a>> {
    if self.command_type() == Command::PopupRound {
      let u = self.command();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { PopupRound::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_read_events(&self) -> Option<ReadEvents<'a>> {
    if self.command_type() == Command::ReadEvents {
      let u = self.command();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { ReadEvents::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_rectangle(&self) -> Option<Rectangle<'a>> {
    if self.command_type() == Command::Rectangle {
      let u = self.command();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Rectangle::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_subscribe(&self) -> Option<Subscribe<'a>> {
    if self.command_type() == Command::Subscribe {
      let u = self.command();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Subscribe::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_tiles(&self) -> Option<Tiles<'a>> {
    if self.command_type() == Command::Tiles {
      let u = self.command();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Tiles::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_triangle(&self) -> Option<Triangle<'a>> {
    if self.command_type() == Command::Triangle {
      let u = self.command();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Triangle::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_unsubscribe(&self) -> Option<Unsubscribe<'a>> {
    if self.command_type() == Command::Unsubscribe {
      let u = self.command();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Unsubscribe::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_primitives(&self) -> Option<Primitives<'a>> {
    if self.command_type() == Command::Primitives {
      let u = self.command();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Primitives::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_end_frame(&self) -> Option<EndFrame<'a>> {
    if self.command_type() == Command::EndFrame {
      let u = self.command();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { EndFrame::init_from_table(u) })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for RewindMessage<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<Command, _>("command_type", Self::VT_COMMAND_TYPE, "command", Self::VT_COMMAND, true, |key, v, pos| {
        match key {
          Command::Arc => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Arc>>("Command::Arc", pos),
          Command::CameraView => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CameraView>>("Command::CameraView", pos),
          Command::Circle => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Circle>>("Command::Circle", pos),
          Command::CircleSegment => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CircleSegment>>("Command::CircleSegment", pos),
          Command::LogText => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogText>>("Command::LogText", pos),
          Command::Options => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Options>>("Command::Options", pos),
          Command::Polyline => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Polyline>>("Command::Polyline", pos),
          Command::Popup => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Popup>>("Command::Popup", pos),
          Command::PopupRound => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PopupRound>>("Command::PopupRound", pos),
          Command::ReadEvents => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReadEvents>>("Command::ReadEvents", pos),
          Command::Rectangle => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Rectangle>>("Command::Rectangle", pos),
          Command::Subscribe => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Subscribe>>("Command::Subscribe", pos),
          Command::Tiles => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Tiles>>("Command::Tiles", pos),
          Command::Triangle => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Triangle>>("Command::Triangle", pos),
          Command::Unsubscribe => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Unsubscribe>>("Command::Unsubscribe", pos),
          Command::Primitives => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Primitives>>("Command::Primitives", pos),
          Command::EndFrame => v.verify_union_variant::<flatbuffers::ForwardsUOffset<EndFrame>>("Command::EndFrame", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct RewindMessageArgs {
    pub command_type: Command,
    pub command: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for RewindMessageArgs {
  #[inline]
  fn default() -> Self {
    RewindMessageArgs {
      command_type: Command::NONE,
      command: None, // required field
    }
  }
}

pub struct RewindMessageBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RewindMessageBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_command_type(&mut self, command_type: Command) {
    self.fbb_.push_slot::<Command>(RewindMessage::VT_COMMAND_TYPE, command_type, Command::NONE);
  }
  #[inline]
  pub fn add_command(&mut self, command: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RewindMessage::VT_COMMAND, command);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RewindMessageBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RewindMessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RewindMessage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, RewindMessage::VT_COMMAND,"command");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RewindMessage<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RewindMessage");
      ds.field("command_type", &self.command_type());
      match self.command_type() {
        Command::Arc => {
          if let Some(x) = self.command_as_arc() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Command::CameraView => {
          if let Some(x) = self.command_as_camera_view() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Command::Circle => {
          if let Some(x) = self.command_as_circle() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Command::CircleSegment => {
          if let Some(x) = self.command_as_circle_segment() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Command::LogText => {
          if let Some(x) = self.command_as_log_text() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Command::Options => {
          if let Some(x) = self.command_as_options() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Command::Polyline => {
          if let Some(x) = self.command_as_polyline() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Command::Popup => {
          if let Some(x) = self.command_as_popup() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Command::PopupRound => {
          if let Some(x) = self.command_as_popup_round() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Command::ReadEvents => {
          if let Some(x) = self.command_as_read_events() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Command::Rectangle => {
          if let Some(x) = self.command_as_rectangle() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Command::Subscribe => {
          if let Some(x) = self.command_as_subscribe() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Command::Tiles => {
          if let Some(x) = self.command_as_tiles() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Command::Triangle => {
          if let Some(x) = self.command_as_triangle() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Command::Unsubscribe => {
          if let Some(x) = self.command_as_unsubscribe() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Command::Primitives => {
          if let Some(x) = self.command_as_primitives() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Command::EndFrame => {
          if let Some(x) = self.command_as_end_frame() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("command", &x)
        },
      };
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `RewindMessage`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_rewind_message_unchecked`.
pub fn root_as_rewind_message(buf: &[u8]) -> Result<RewindMessage, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<RewindMessage>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `RewindMessage` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_rewind_message_unchecked`.
pub fn size_prefixed_root_as_rewind_message(buf: &[u8]) -> Result<RewindMessage, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<RewindMessage>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `RewindMessage` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_rewind_message_unchecked`.
pub fn root_as_rewind_message_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<RewindMessage<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<RewindMessage<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `RewindMessage` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_rewind_message_unchecked`.
pub fn size_prefixed_root_as_rewind_message_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<RewindMessage<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<RewindMessage<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a RewindMessage and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `RewindMessage`.
pub unsafe fn root_as_rewind_message_unchecked(buf: &[u8]) -> RewindMessage {
  flatbuffers::root_unchecked::<RewindMessage>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed RewindMessage and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `RewindMessage`.
pub unsafe fn size_prefixed_root_as_rewind_message_unchecked(buf: &[u8]) -> RewindMessage {
  flatbuffers::size_prefixed_root_unchecked::<RewindMessage>(buf)
}
#[inline]
pub fn finish_rewind_message_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<RewindMessage<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_rewind_message_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<RewindMessage<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod fbs
}  // pub mod rewind_viewer

