// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use crate::primitives.fbs::*;
use crate::vector2f.fbs::*;
use crate::actions.fbs::*;
use crate::auxiliary.fbs::*;
use crate::ui.fbs::*;
use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod rewind_viewer {

  use crate::primitives.fbs::*;
  use crate::vector2f.fbs::*;
  use crate::actions.fbs::*;
  use crate::auxiliary.fbs::*;
  use crate::ui.fbs::*;
  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod fbs {

  use crate::primitives.fbs::*;
  use crate::vector2f.fbs::*;
  use crate::actions.fbs::*;
  use crate::auxiliary.fbs::*;
  use crate::ui.fbs::*;
  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_COMMAND: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_COMMAND: u8 = 23;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_COMMAND: [Command; 24] = [
  Command::NONE,
  Command::Subscribe,
  Command::Unsubscribe,
  Command::CreateAction,
  Command::RemoveAction,
  Command::ReadEvents,
  Command::Layer,
  Command::Map,
  Command::EndFrame,
  Command::Arc,
  Command::Circle,
  Command::CircleSegment,
  Command::Polyline,
  Command::Rectangle,
  Command::Tiles,
  Command::Triangle,
  Command::StartProto,
  Command::EndProto,
  Command::DrawProto,
  Command::LogText,
  Command::Popup,
  Command::PopupRound,
  Command::CameraView,
  Command::Text,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Command(pub u8);
#[allow(non_upper_case_globals)]
impl Command {
  pub const NONE: Self = Self(0);
  pub const Subscribe: Self = Self(1);
  pub const Unsubscribe: Self = Self(2);
  pub const CreateAction: Self = Self(3);
  pub const RemoveAction: Self = Self(4);
  pub const ReadEvents: Self = Self(5);
  pub const Layer: Self = Self(6);
  pub const Map: Self = Self(7);
  pub const EndFrame: Self = Self(8);
  pub const Arc: Self = Self(9);
  pub const Circle: Self = Self(10);
  pub const CircleSegment: Self = Self(11);
  pub const Polyline: Self = Self(12);
  pub const Rectangle: Self = Self(13);
  pub const Tiles: Self = Self(14);
  pub const Triangle: Self = Self(15);
  pub const StartProto: Self = Self(16);
  pub const EndProto: Self = Self(17);
  pub const DrawProto: Self = Self(18);
  pub const LogText: Self = Self(19);
  pub const Popup: Self = Self(20);
  pub const PopupRound: Self = Self(21);
  pub const CameraView: Self = Self(22);
  pub const Text: Self = Self(23);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 23;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::Subscribe,
    Self::Unsubscribe,
    Self::CreateAction,
    Self::RemoveAction,
    Self::ReadEvents,
    Self::Layer,
    Self::Map,
    Self::EndFrame,
    Self::Arc,
    Self::Circle,
    Self::CircleSegment,
    Self::Polyline,
    Self::Rectangle,
    Self::Tiles,
    Self::Triangle,
    Self::StartProto,
    Self::EndProto,
    Self::DrawProto,
    Self::LogText,
    Self::Popup,
    Self::PopupRound,
    Self::CameraView,
    Self::Text,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::Subscribe => Some("Subscribe"),
      Self::Unsubscribe => Some("Unsubscribe"),
      Self::CreateAction => Some("CreateAction"),
      Self::RemoveAction => Some("RemoveAction"),
      Self::ReadEvents => Some("ReadEvents"),
      Self::Layer => Some("Layer"),
      Self::Map => Some("Map"),
      Self::EndFrame => Some("EndFrame"),
      Self::Arc => Some("Arc"),
      Self::Circle => Some("Circle"),
      Self::CircleSegment => Some("CircleSegment"),
      Self::Polyline => Some("Polyline"),
      Self::Rectangle => Some("Rectangle"),
      Self::Tiles => Some("Tiles"),
      Self::Triangle => Some("Triangle"),
      Self::StartProto => Some("StartProto"),
      Self::EndProto => Some("EndProto"),
      Self::DrawProto => Some("DrawProto"),
      Self::LogText => Some("LogText"),
      Self::Popup => Some("Popup"),
      Self::PopupRound => Some("PopupRound"),
      Self::CameraView => Some("CameraView"),
      Self::Text => Some("Text"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Command {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Command {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Command {
    type Output = Command;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Command {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Command {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Command {}
pub struct CommandUnionTableOffset {}

pub enum RewindMessageOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RewindMessage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RewindMessage<'a> {
  type Inner = RewindMessage<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RewindMessage<'a> {
  pub const VT_COMMAND_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_COMMAND: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RewindMessage { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RewindMessageArgs
  ) -> flatbuffers::WIPOffset<RewindMessage<'bldr>> {
    let mut builder = RewindMessageBuilder::new(_fbb);
    if let Some(x) = args.command { builder.add_command(x); }
    builder.add_command_type(args.command_type);
    builder.finish()
  }


  #[inline]
  pub fn command_type(&self) -> Command {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Command>(RewindMessage::VT_COMMAND_TYPE, Some(Command::NONE)).unwrap()}
  }
  #[inline]
  pub fn command(&self) -> flatbuffers::Table<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(RewindMessage::VT_COMMAND, None).unwrap()}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_subscribe(&self) -> Option<Subscribe<'a>> {
    if self.command_type() == Command::Subscribe {
      let u = self.command();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Subscribe::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_unsubscribe(&self) -> Option<Unsubscribe<'a>> {
    if self.command_type() == Command::Unsubscribe {
      let u = self.command();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Unsubscribe::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_create_action(&self) -> Option<CreateAction<'a>> {
    if self.command_type() == Command::CreateAction {
      let u = self.command();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { CreateAction::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_remove_action(&self) -> Option<RemoveAction<'a>> {
    if self.command_type() == Command::RemoveAction {
      let u = self.command();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { RemoveAction::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_read_events(&self) -> Option<ReadEvents<'a>> {
    if self.command_type() == Command::ReadEvents {
      let u = self.command();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { ReadEvents::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_layer(&self) -> Option<Layer<'a>> {
    if self.command_type() == Command::Layer {
      let u = self.command();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Layer::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_map(&self) -> Option<Map<'a>> {
    if self.command_type() == Command::Map {
      let u = self.command();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Map::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_end_frame(&self) -> Option<EndFrame<'a>> {
    if self.command_type() == Command::EndFrame {
      let u = self.command();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { EndFrame::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_arc(&self) -> Option<Arc<'a>> {
    if self.command_type() == Command::Arc {
      let u = self.command();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Arc::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_circle(&self) -> Option<Circle<'a>> {
    if self.command_type() == Command::Circle {
      let u = self.command();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Circle::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_circle_segment(&self) -> Option<CircleSegment<'a>> {
    if self.command_type() == Command::CircleSegment {
      let u = self.command();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { CircleSegment::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_polyline(&self) -> Option<Polyline<'a>> {
    if self.command_type() == Command::Polyline {
      let u = self.command();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Polyline::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_rectangle(&self) -> Option<Rectangle<'a>> {
    if self.command_type() == Command::Rectangle {
      let u = self.command();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Rectangle::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_tiles(&self) -> Option<Tiles<'a>> {
    if self.command_type() == Command::Tiles {
      let u = self.command();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Tiles::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_triangle(&self) -> Option<Triangle<'a>> {
    if self.command_type() == Command::Triangle {
      let u = self.command();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Triangle::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_start_proto(&self) -> Option<StartProto<'a>> {
    if self.command_type() == Command::StartProto {
      let u = self.command();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { StartProto::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_end_proto(&self) -> Option<EndProto<'a>> {
    if self.command_type() == Command::EndProto {
      let u = self.command();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { EndProto::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_draw_proto(&self) -> Option<DrawProto<'a>> {
    if self.command_type() == Command::DrawProto {
      let u = self.command();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { DrawProto::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_log_text(&self) -> Option<LogText<'a>> {
    if self.command_type() == Command::LogText {
      let u = self.command();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { LogText::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_popup(&self) -> Option<Popup<'a>> {
    if self.command_type() == Command::Popup {
      let u = self.command();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Popup::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_popup_round(&self) -> Option<PopupRound<'a>> {
    if self.command_type() == Command::PopupRound {
      let u = self.command();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { PopupRound::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_camera_view(&self) -> Option<CameraView<'a>> {
    if self.command_type() == Command::CameraView {
      let u = self.command();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { CameraView::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_text(&self) -> Option<Text<'a>> {
    if self.command_type() == Command::Text {
      let u = self.command();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { Text::init_from_table(u) })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for RewindMessage<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<Command, _>("command_type", Self::VT_COMMAND_TYPE, "command", Self::VT_COMMAND, true, |key, v, pos| {
        match key {
          Command::Subscribe => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Subscribe>>("Command::Subscribe", pos),
          Command::Unsubscribe => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Unsubscribe>>("Command::Unsubscribe", pos),
          Command::CreateAction => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CreateAction>>("Command::CreateAction", pos),
          Command::RemoveAction => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RemoveAction>>("Command::RemoveAction", pos),
          Command::ReadEvents => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReadEvents>>("Command::ReadEvents", pos),
          Command::Layer => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Layer>>("Command::Layer", pos),
          Command::Map => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Map>>("Command::Map", pos),
          Command::EndFrame => v.verify_union_variant::<flatbuffers::ForwardsUOffset<EndFrame>>("Command::EndFrame", pos),
          Command::Arc => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Arc>>("Command::Arc", pos),
          Command::Circle => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Circle>>("Command::Circle", pos),
          Command::CircleSegment => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CircleSegment>>("Command::CircleSegment", pos),
          Command::Polyline => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Polyline>>("Command::Polyline", pos),
          Command::Rectangle => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Rectangle>>("Command::Rectangle", pos),
          Command::Tiles => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Tiles>>("Command::Tiles", pos),
          Command::Triangle => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Triangle>>("Command::Triangle", pos),
          Command::StartProto => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StartProto>>("Command::StartProto", pos),
          Command::EndProto => v.verify_union_variant::<flatbuffers::ForwardsUOffset<EndProto>>("Command::EndProto", pos),
          Command::DrawProto => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DrawProto>>("Command::DrawProto", pos),
          Command::LogText => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogText>>("Command::LogText", pos),
          Command::Popup => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Popup>>("Command::Popup", pos),
          Command::PopupRound => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PopupRound>>("Command::PopupRound", pos),
          Command::CameraView => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CameraView>>("Command::CameraView", pos),
          Command::Text => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Text>>("Command::Text", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct RewindMessageArgs {
    pub command_type: Command,
    pub command: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for RewindMessageArgs {
  #[inline]
  fn default() -> Self {
    RewindMessageArgs {
      command_type: Command::NONE,
      command: None, // required field
    }
  }
}

pub struct RewindMessageBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RewindMessageBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_command_type(&mut self, command_type: Command) {
    self.fbb_.push_slot::<Command>(RewindMessage::VT_COMMAND_TYPE, command_type, Command::NONE);
  }
  #[inline]
  pub fn add_command(&mut self, command: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RewindMessage::VT_COMMAND, command);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RewindMessageBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RewindMessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RewindMessage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, RewindMessage::VT_COMMAND,"command");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RewindMessage<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RewindMessage");
      ds.field("command_type", &self.command_type());
      match self.command_type() {
        Command::Subscribe => {
          if let Some(x) = self.command_as_subscribe() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Command::Unsubscribe => {
          if let Some(x) = self.command_as_unsubscribe() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Command::CreateAction => {
          if let Some(x) = self.command_as_create_action() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Command::RemoveAction => {
          if let Some(x) = self.command_as_remove_action() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Command::ReadEvents => {
          if let Some(x) = self.command_as_read_events() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Command::Layer => {
          if let Some(x) = self.command_as_layer() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Command::Map => {
          if let Some(x) = self.command_as_map() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Command::EndFrame => {
          if let Some(x) = self.command_as_end_frame() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Command::Arc => {
          if let Some(x) = self.command_as_arc() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Command::Circle => {
          if let Some(x) = self.command_as_circle() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Command::CircleSegment => {
          if let Some(x) = self.command_as_circle_segment() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Command::Polyline => {
          if let Some(x) = self.command_as_polyline() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Command::Rectangle => {
          if let Some(x) = self.command_as_rectangle() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Command::Tiles => {
          if let Some(x) = self.command_as_tiles() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Command::Triangle => {
          if let Some(x) = self.command_as_triangle() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Command::StartProto => {
          if let Some(x) = self.command_as_start_proto() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Command::EndProto => {
          if let Some(x) = self.command_as_end_proto() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Command::DrawProto => {
          if let Some(x) = self.command_as_draw_proto() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Command::LogText => {
          if let Some(x) = self.command_as_log_text() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Command::Popup => {
          if let Some(x) = self.command_as_popup() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Command::PopupRound => {
          if let Some(x) = self.command_as_popup_round() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Command::CameraView => {
          if let Some(x) = self.command_as_camera_view() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Command::Text => {
          if let Some(x) = self.command_as_text() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("command", &x)
        },
      };
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `RewindMessage`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_rewind_message_unchecked`.
pub fn root_as_rewind_message(buf: &[u8]) -> Result<RewindMessage, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<RewindMessage>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `RewindMessage` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_rewind_message_unchecked`.
pub fn size_prefixed_root_as_rewind_message(buf: &[u8]) -> Result<RewindMessage, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<RewindMessage>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `RewindMessage` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_rewind_message_unchecked`.
pub fn root_as_rewind_message_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<RewindMessage<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<RewindMessage<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `RewindMessage` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_rewind_message_unchecked`.
pub fn size_prefixed_root_as_rewind_message_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<RewindMessage<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<RewindMessage<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a RewindMessage and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `RewindMessage`.
pub unsafe fn root_as_rewind_message_unchecked(buf: &[u8]) -> RewindMessage {
  flatbuffers::root_unchecked::<RewindMessage>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed RewindMessage and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `RewindMessage`.
pub unsafe fn size_prefixed_root_as_rewind_message_unchecked(buf: &[u8]) -> RewindMessage {
  flatbuffers::size_prefixed_root_unchecked::<RewindMessage>(buf)
}
#[inline]
pub fn finish_rewind_message_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<RewindMessage<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_rewind_message_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<RewindMessage<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod fbs
}  // pub mod rewind_viewer

