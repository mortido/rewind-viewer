// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use crate::vector2f.fbs::*;
use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod rewind_viewer {

  use crate::vector2f.fbs::*;
  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod fbs {

  use crate::vector2f.fbs::*;
  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

pub enum ColorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Color<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Color<'a> {
  type Inner = Color<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Color<'a> {
  pub const VT_VALUE: flatbuffers::VOffsetT = 4;
  pub const VT_FILL: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Color { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ColorArgs
  ) -> flatbuffers::WIPOffset<Color<'bldr>> {
    let mut builder = ColorBuilder::new(_fbb);
    builder.add_value(args.value);
    builder.add_fill(args.fill);
    builder.finish()
  }


  #[inline]
  pub fn value(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Color::VT_VALUE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn fill(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Color::VT_FILL, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Color<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("value", Self::VT_VALUE, false)?
     .visit_field::<bool>("fill", Self::VT_FILL, false)?
     .finish();
    Ok(())
  }
}
pub struct ColorArgs {
    pub value: u32,
    pub fill: bool,
}
impl<'a> Default for ColorArgs {
  #[inline]
  fn default() -> Self {
    ColorArgs {
      value: 0,
      fill: false,
    }
  }
}

pub struct ColorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ColorBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_value(&mut self, value: u32) {
    self.fbb_.push_slot::<u32>(Color::VT_VALUE, value, 0);
  }
  #[inline]
  pub fn add_fill(&mut self, fill: bool) {
    self.fbb_.push_slot::<bool>(Color::VT_FILL, fill, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ColorBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ColorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Color<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Color<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Color");
      ds.field("value", &self.value());
      ds.field("fill", &self.fill());
      ds.finish()
  }
}
pub enum CircleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Circle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Circle<'a> {
  type Inner = Circle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Circle<'a> {
  pub const VT_COLOR: flatbuffers::VOffsetT = 4;
  pub const VT_CENTER: flatbuffers::VOffsetT = 6;
  pub const VT_RADIUS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Circle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CircleArgs<'args>
  ) -> flatbuffers::WIPOffset<Circle<'bldr>> {
    let mut builder = CircleBuilder::new(_fbb);
    builder.add_radius(args.radius);
    if let Some(x) = args.center { builder.add_center(x); }
    if let Some(x) = args.color { builder.add_color(x); }
    builder.finish()
  }


  #[inline]
  pub fn color(&self) -> Option<Color<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Color>>(Circle::VT_COLOR, None)}
  }
  #[inline]
  pub fn center(&self) -> &'a Vector2f {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector2f>(Circle::VT_CENTER, None).unwrap()}
  }
  #[inline]
  pub fn radius(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Circle::VT_RADIUS, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Circle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Color>>("color", Self::VT_COLOR, false)?
     .visit_field::<Vector2f>("center", Self::VT_CENTER, true)?
     .visit_field::<f32>("radius", Self::VT_RADIUS, false)?
     .finish();
    Ok(())
  }
}
pub struct CircleArgs<'a> {
    pub color: Option<flatbuffers::WIPOffset<Color<'a>>>,
    pub center: Option<&'a Vector2f>,
    pub radius: f32,
}
impl<'a> Default for CircleArgs<'a> {
  #[inline]
  fn default() -> Self {
    CircleArgs {
      color: None,
      center: None, // required field
      radius: 0.0,
    }
  }
}

pub struct CircleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CircleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_color(&mut self, color: flatbuffers::WIPOffset<Color<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Color>>(Circle::VT_COLOR, color);
  }
  #[inline]
  pub fn add_center(&mut self, center: &Vector2f) {
    self.fbb_.push_slot_always::<&Vector2f>(Circle::VT_CENTER, center);
  }
  #[inline]
  pub fn add_radius(&mut self, radius: f32) {
    self.fbb_.push_slot::<f32>(Circle::VT_RADIUS, radius, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CircleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CircleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Circle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Circle::VT_CENTER,"center");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Circle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Circle");
      ds.field("color", &self.color());
      ds.field("center", &self.center());
      ds.field("radius", &self.radius());
      ds.finish()
  }
}
pub enum ArcOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Arc<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Arc<'a> {
  type Inner = Arc<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Arc<'a> {
  pub const VT_COLOR: flatbuffers::VOffsetT = 4;
  pub const VT_CENTER: flatbuffers::VOffsetT = 6;
  pub const VT_RADIUS: flatbuffers::VOffsetT = 8;
  pub const VT_START_ANGLE: flatbuffers::VOffsetT = 10;
  pub const VT_END_ANGLE: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Arc { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ArcArgs<'args>
  ) -> flatbuffers::WIPOffset<Arc<'bldr>> {
    let mut builder = ArcBuilder::new(_fbb);
    builder.add_end_angle(args.end_angle);
    builder.add_start_angle(args.start_angle);
    builder.add_radius(args.radius);
    if let Some(x) = args.center { builder.add_center(x); }
    if let Some(x) = args.color { builder.add_color(x); }
    builder.finish()
  }


  #[inline]
  pub fn color(&self) -> Option<Color<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Color>>(Arc::VT_COLOR, None)}
  }
  #[inline]
  pub fn center(&self) -> &'a Vector2f {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector2f>(Arc::VT_CENTER, None).unwrap()}
  }
  #[inline]
  pub fn radius(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Arc::VT_RADIUS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn start_angle(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Arc::VT_START_ANGLE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn end_angle(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Arc::VT_END_ANGLE, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Arc<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Color>>("color", Self::VT_COLOR, false)?
     .visit_field::<Vector2f>("center", Self::VT_CENTER, true)?
     .visit_field::<f32>("radius", Self::VT_RADIUS, false)?
     .visit_field::<f32>("start_angle", Self::VT_START_ANGLE, false)?
     .visit_field::<f32>("end_angle", Self::VT_END_ANGLE, false)?
     .finish();
    Ok(())
  }
}
pub struct ArcArgs<'a> {
    pub color: Option<flatbuffers::WIPOffset<Color<'a>>>,
    pub center: Option<&'a Vector2f>,
    pub radius: f32,
    pub start_angle: f32,
    pub end_angle: f32,
}
impl<'a> Default for ArcArgs<'a> {
  #[inline]
  fn default() -> Self {
    ArcArgs {
      color: None,
      center: None, // required field
      radius: 0.0,
      start_angle: 0.0,
      end_angle: 0.0,
    }
  }
}

pub struct ArcBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ArcBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_color(&mut self, color: flatbuffers::WIPOffset<Color<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Color>>(Arc::VT_COLOR, color);
  }
  #[inline]
  pub fn add_center(&mut self, center: &Vector2f) {
    self.fbb_.push_slot_always::<&Vector2f>(Arc::VT_CENTER, center);
  }
  #[inline]
  pub fn add_radius(&mut self, radius: f32) {
    self.fbb_.push_slot::<f32>(Arc::VT_RADIUS, radius, 0.0);
  }
  #[inline]
  pub fn add_start_angle(&mut self, start_angle: f32) {
    self.fbb_.push_slot::<f32>(Arc::VT_START_ANGLE, start_angle, 0.0);
  }
  #[inline]
  pub fn add_end_angle(&mut self, end_angle: f32) {
    self.fbb_.push_slot::<f32>(Arc::VT_END_ANGLE, end_angle, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ArcBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ArcBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Arc<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Arc::VT_CENTER,"center");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Arc<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Arc");
      ds.field("color", &self.color());
      ds.field("center", &self.center());
      ds.field("radius", &self.radius());
      ds.field("start_angle", &self.start_angle());
      ds.field("end_angle", &self.end_angle());
      ds.finish()
  }
}
pub enum CircleSegmentOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CircleSegment<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CircleSegment<'a> {
  type Inner = CircleSegment<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CircleSegment<'a> {
  pub const VT_COLOR: flatbuffers::VOffsetT = 4;
  pub const VT_CENTER: flatbuffers::VOffsetT = 6;
  pub const VT_RADIUS: flatbuffers::VOffsetT = 8;
  pub const VT_START_ANGLE: flatbuffers::VOffsetT = 10;
  pub const VT_END_ANGLE: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CircleSegment { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CircleSegmentArgs<'args>
  ) -> flatbuffers::WIPOffset<CircleSegment<'bldr>> {
    let mut builder = CircleSegmentBuilder::new(_fbb);
    builder.add_end_angle(args.end_angle);
    builder.add_start_angle(args.start_angle);
    builder.add_radius(args.radius);
    if let Some(x) = args.center { builder.add_center(x); }
    if let Some(x) = args.color { builder.add_color(x); }
    builder.finish()
  }


  #[inline]
  pub fn color(&self) -> Option<Color<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Color>>(CircleSegment::VT_COLOR, None)}
  }
  #[inline]
  pub fn center(&self) -> &'a Vector2f {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector2f>(CircleSegment::VT_CENTER, None).unwrap()}
  }
  #[inline]
  pub fn radius(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(CircleSegment::VT_RADIUS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn start_angle(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(CircleSegment::VT_START_ANGLE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn end_angle(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(CircleSegment::VT_END_ANGLE, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for CircleSegment<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Color>>("color", Self::VT_COLOR, false)?
     .visit_field::<Vector2f>("center", Self::VT_CENTER, true)?
     .visit_field::<f32>("radius", Self::VT_RADIUS, false)?
     .visit_field::<f32>("start_angle", Self::VT_START_ANGLE, false)?
     .visit_field::<f32>("end_angle", Self::VT_END_ANGLE, false)?
     .finish();
    Ok(())
  }
}
pub struct CircleSegmentArgs<'a> {
    pub color: Option<flatbuffers::WIPOffset<Color<'a>>>,
    pub center: Option<&'a Vector2f>,
    pub radius: f32,
    pub start_angle: f32,
    pub end_angle: f32,
}
impl<'a> Default for CircleSegmentArgs<'a> {
  #[inline]
  fn default() -> Self {
    CircleSegmentArgs {
      color: None,
      center: None, // required field
      radius: 0.0,
      start_angle: 0.0,
      end_angle: 0.0,
    }
  }
}

pub struct CircleSegmentBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CircleSegmentBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_color(&mut self, color: flatbuffers::WIPOffset<Color<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Color>>(CircleSegment::VT_COLOR, color);
  }
  #[inline]
  pub fn add_center(&mut self, center: &Vector2f) {
    self.fbb_.push_slot_always::<&Vector2f>(CircleSegment::VT_CENTER, center);
  }
  #[inline]
  pub fn add_radius(&mut self, radius: f32) {
    self.fbb_.push_slot::<f32>(CircleSegment::VT_RADIUS, radius, 0.0);
  }
  #[inline]
  pub fn add_start_angle(&mut self, start_angle: f32) {
    self.fbb_.push_slot::<f32>(CircleSegment::VT_START_ANGLE, start_angle, 0.0);
  }
  #[inline]
  pub fn add_end_angle(&mut self, end_angle: f32) {
    self.fbb_.push_slot::<f32>(CircleSegment::VT_END_ANGLE, end_angle, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CircleSegmentBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CircleSegmentBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CircleSegment<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, CircleSegment::VT_CENTER,"center");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CircleSegment<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CircleSegment");
      ds.field("color", &self.color());
      ds.field("center", &self.center());
      ds.field("radius", &self.radius());
      ds.field("start_angle", &self.start_angle());
      ds.field("end_angle", &self.end_angle());
      ds.finish()
  }
}
pub enum TilesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Tiles<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Tiles<'a> {
  type Inner = Tiles<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Tiles<'a> {
  pub const VT_POSITION: flatbuffers::VOffsetT = 4;
  pub const VT_CELL_SIZE: flatbuffers::VOffsetT = 6;
  pub const VT_ROW_SIZE: flatbuffers::VOffsetT = 8;
  pub const VT_COLORS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Tiles { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TilesArgs<'args>
  ) -> flatbuffers::WIPOffset<Tiles<'bldr>> {
    let mut builder = TilesBuilder::new(_fbb);
    if let Some(x) = args.colors { builder.add_colors(x); }
    if let Some(x) = args.cell_size { builder.add_cell_size(x); }
    if let Some(x) = args.position { builder.add_position(x); }
    builder.add_row_size(args.row_size);
    builder.finish()
  }


  #[inline]
  pub fn position(&self) -> &'a Vector2f {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector2f>(Tiles::VT_POSITION, None).unwrap()}
  }
  #[inline]
  pub fn cell_size(&self) -> &'a Vector2f {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector2f>(Tiles::VT_CELL_SIZE, None).unwrap()}
  }
  #[inline]
  pub fn row_size(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(Tiles::VT_ROW_SIZE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn colors(&self) -> flatbuffers::Vector<'a, u32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(Tiles::VT_COLORS, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Tiles<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Vector2f>("position", Self::VT_POSITION, true)?
     .visit_field::<Vector2f>("cell_size", Self::VT_CELL_SIZE, true)?
     .visit_field::<u16>("row_size", Self::VT_ROW_SIZE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("colors", Self::VT_COLORS, true)?
     .finish();
    Ok(())
  }
}
pub struct TilesArgs<'a> {
    pub position: Option<&'a Vector2f>,
    pub cell_size: Option<&'a Vector2f>,
    pub row_size: u16,
    pub colors: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
}
impl<'a> Default for TilesArgs<'a> {
  #[inline]
  fn default() -> Self {
    TilesArgs {
      position: None, // required field
      cell_size: None, // required field
      row_size: 0,
      colors: None, // required field
    }
  }
}

pub struct TilesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TilesBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_position(&mut self, position: &Vector2f) {
    self.fbb_.push_slot_always::<&Vector2f>(Tiles::VT_POSITION, position);
  }
  #[inline]
  pub fn add_cell_size(&mut self, cell_size: &Vector2f) {
    self.fbb_.push_slot_always::<&Vector2f>(Tiles::VT_CELL_SIZE, cell_size);
  }
  #[inline]
  pub fn add_row_size(&mut self, row_size: u16) {
    self.fbb_.push_slot::<u16>(Tiles::VT_ROW_SIZE, row_size, 0);
  }
  #[inline]
  pub fn add_colors(&mut self, colors: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Tiles::VT_COLORS, colors);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TilesBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TilesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Tiles<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Tiles::VT_POSITION,"position");
    self.fbb_.required(o, Tiles::VT_CELL_SIZE,"cell_size");
    self.fbb_.required(o, Tiles::VT_COLORS,"colors");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Tiles<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Tiles");
      ds.field("position", &self.position());
      ds.field("cell_size", &self.cell_size());
      ds.field("row_size", &self.row_size());
      ds.field("colors", &self.colors());
      ds.finish()
  }
}
pub enum RectangleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Rectangle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Rectangle<'a> {
  type Inner = Rectangle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Rectangle<'a> {
  pub const VT_COLOR: flatbuffers::VOffsetT = 4;
  pub const VT_POSITION: flatbuffers::VOffsetT = 6;
  pub const VT_SIZE_: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Rectangle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RectangleArgs<'args>
  ) -> flatbuffers::WIPOffset<Rectangle<'bldr>> {
    let mut builder = RectangleBuilder::new(_fbb);
    if let Some(x) = args.size_ { builder.add_size_(x); }
    if let Some(x) = args.position { builder.add_position(x); }
    if let Some(x) = args.color { builder.add_color(x); }
    builder.finish()
  }


  #[inline]
  pub fn color(&self) -> Option<Color<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Color>>(Rectangle::VT_COLOR, None)}
  }
  #[inline]
  pub fn position(&self) -> &'a Vector2f {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector2f>(Rectangle::VT_POSITION, None).unwrap()}
  }
  #[inline]
  pub fn size_(&self) -> &'a Vector2f {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector2f>(Rectangle::VT_SIZE_, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Rectangle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Color>>("color", Self::VT_COLOR, false)?
     .visit_field::<Vector2f>("position", Self::VT_POSITION, true)?
     .visit_field::<Vector2f>("size_", Self::VT_SIZE_, true)?
     .finish();
    Ok(())
  }
}
pub struct RectangleArgs<'a> {
    pub color: Option<flatbuffers::WIPOffset<Color<'a>>>,
    pub position: Option<&'a Vector2f>,
    pub size_: Option<&'a Vector2f>,
}
impl<'a> Default for RectangleArgs<'a> {
  #[inline]
  fn default() -> Self {
    RectangleArgs {
      color: None,
      position: None, // required field
      size_: None, // required field
    }
  }
}

pub struct RectangleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RectangleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_color(&mut self, color: flatbuffers::WIPOffset<Color<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Color>>(Rectangle::VT_COLOR, color);
  }
  #[inline]
  pub fn add_position(&mut self, position: &Vector2f) {
    self.fbb_.push_slot_always::<&Vector2f>(Rectangle::VT_POSITION, position);
  }
  #[inline]
  pub fn add_size_(&mut self, size_: &Vector2f) {
    self.fbb_.push_slot_always::<&Vector2f>(Rectangle::VT_SIZE_, size_);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RectangleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RectangleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Rectangle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Rectangle::VT_POSITION,"position");
    self.fbb_.required(o, Rectangle::VT_SIZE_,"size_");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Rectangle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Rectangle");
      ds.field("color", &self.color());
      ds.field("position", &self.position());
      ds.field("size_", &self.size_());
      ds.finish()
  }
}
pub enum TriangleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Triangle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Triangle<'a> {
  type Inner = Triangle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Triangle<'a> {
  pub const VT_COLOR: flatbuffers::VOffsetT = 4;
  pub const VT_POINTS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Triangle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TriangleArgs<'args>
  ) -> flatbuffers::WIPOffset<Triangle<'bldr>> {
    let mut builder = TriangleBuilder::new(_fbb);
    if let Some(x) = args.points { builder.add_points(x); }
    if let Some(x) = args.color { builder.add_color(x); }
    builder.finish()
  }


  #[inline]
  pub fn color(&self) -> Option<Color<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Color>>(Triangle::VT_COLOR, None)}
  }
  #[inline]
  pub fn points(&self) -> flatbuffers::Vector<'a, Vector2f> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Vector2f>>>(Triangle::VT_POINTS, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Triangle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Color>>("color", Self::VT_COLOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Vector2f>>>("points", Self::VT_POINTS, true)?
     .finish();
    Ok(())
  }
}
pub struct TriangleArgs<'a> {
    pub color: Option<flatbuffers::WIPOffset<Color<'a>>>,
    pub points: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Vector2f>>>,
}
impl<'a> Default for TriangleArgs<'a> {
  #[inline]
  fn default() -> Self {
    TriangleArgs {
      color: None,
      points: None, // required field
    }
  }
}

pub struct TriangleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TriangleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_color(&mut self, color: flatbuffers::WIPOffset<Color<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Color>>(Triangle::VT_COLOR, color);
  }
  #[inline]
  pub fn add_points(&mut self, points: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Vector2f>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Triangle::VT_POINTS, points);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TriangleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TriangleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Triangle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Triangle::VT_POINTS,"points");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Triangle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Triangle");
      ds.field("color", &self.color());
      ds.field("points", &self.points());
      ds.finish()
  }
}
pub enum PolylineOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Polyline<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Polyline<'a> {
  type Inner = Polyline<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Polyline<'a> {
  pub const VT_COLOR: flatbuffers::VOffsetT = 4;
  pub const VT_POINTS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Polyline { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PolylineArgs<'args>
  ) -> flatbuffers::WIPOffset<Polyline<'bldr>> {
    let mut builder = PolylineBuilder::new(_fbb);
    if let Some(x) = args.points { builder.add_points(x); }
    if let Some(x) = args.color { builder.add_color(x); }
    builder.finish()
  }


  #[inline]
  pub fn color(&self) -> Option<Color<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Color>>(Polyline::VT_COLOR, None)}
  }
  #[inline]
  pub fn points(&self) -> flatbuffers::Vector<'a, Vector2f> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Vector2f>>>(Polyline::VT_POINTS, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Polyline<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Color>>("color", Self::VT_COLOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Vector2f>>>("points", Self::VT_POINTS, true)?
     .finish();
    Ok(())
  }
}
pub struct PolylineArgs<'a> {
    pub color: Option<flatbuffers::WIPOffset<Color<'a>>>,
    pub points: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Vector2f>>>,
}
impl<'a> Default for PolylineArgs<'a> {
  #[inline]
  fn default() -> Self {
    PolylineArgs {
      color: None,
      points: None, // required field
    }
  }
}

pub struct PolylineBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PolylineBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_color(&mut self, color: flatbuffers::WIPOffset<Color<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Color>>(Polyline::VT_COLOR, color);
  }
  #[inline]
  pub fn add_points(&mut self, points: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Vector2f>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Polyline::VT_POINTS, points);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PolylineBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PolylineBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Polyline<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Polyline::VT_POINTS,"points");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Polyline<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Polyline");
      ds.field("color", &self.color());
      ds.field("points", &self.points());
      ds.finish()
  }
}
pub enum StartProtoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct StartProto<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StartProto<'a> {
  type Inner = StartProto<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> StartProto<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    StartProto { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    _args: &'args StartProtoArgs
  ) -> flatbuffers::WIPOffset<StartProto<'bldr>> {
    let mut builder = StartProtoBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for StartProto<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct StartProtoArgs {
}
impl<'a> Default for StartProtoArgs {
  #[inline]
  fn default() -> Self {
    StartProtoArgs {
    }
  }
}

pub struct StartProtoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StartProtoBuilder<'a, 'b, A> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> StartProtoBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    StartProtoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StartProto<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for StartProto<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("StartProto");
      ds.finish()
  }
}
pub enum EndProtoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct EndProto<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EndProto<'a> {
  type Inner = EndProto<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> EndProto<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EndProto { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    _args: &'args EndProtoArgs
  ) -> flatbuffers::WIPOffset<EndProto<'bldr>> {
    let mut builder = EndProtoBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for EndProto<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct EndProtoArgs {
}
impl<'a> Default for EndProtoArgs {
  #[inline]
  fn default() -> Self {
    EndProtoArgs {
    }
  }
}

pub struct EndProtoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EndProtoBuilder<'a, 'b, A> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> EndProtoBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    EndProtoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EndProto<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EndProto<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EndProto");
      ds.finish()
  }
}
pub enum DrawProtoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DrawProto<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DrawProto<'a> {
  type Inner = DrawProto<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DrawProto<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_POSITION: flatbuffers::VOffsetT = 6;
  pub const VT_ANGLE: flatbuffers::VOffsetT = 8;
  pub const VT_COLOR: flatbuffers::VOffsetT = 10;
  pub const VT_SCALE: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DrawProto { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DrawProtoArgs<'args>
  ) -> flatbuffers::WIPOffset<DrawProto<'bldr>> {
    let mut builder = DrawProtoBuilder::new(_fbb);
    builder.add_id(args.id);
    builder.add_scale(args.scale);
    builder.add_color(args.color);
    builder.add_angle(args.angle);
    if let Some(x) = args.position { builder.add_position(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(DrawProto::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn position(&self) -> &'a Vector2f {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector2f>(DrawProto::VT_POSITION, None).unwrap()}
  }
  #[inline]
  pub fn angle(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DrawProto::VT_ANGLE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn color(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(DrawProto::VT_COLOR, Some(0)).unwrap()}
  }
  #[inline]
  pub fn scale(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DrawProto::VT_SCALE, Some(1.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DrawProto<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("id", Self::VT_ID, false)?
     .visit_field::<Vector2f>("position", Self::VT_POSITION, true)?
     .visit_field::<f32>("angle", Self::VT_ANGLE, false)?
     .visit_field::<u32>("color", Self::VT_COLOR, false)?
     .visit_field::<f32>("scale", Self::VT_SCALE, false)?
     .finish();
    Ok(())
  }
}
pub struct DrawProtoArgs<'a> {
    pub id: u64,
    pub position: Option<&'a Vector2f>,
    pub angle: f32,
    pub color: u32,
    pub scale: f32,
}
impl<'a> Default for DrawProtoArgs<'a> {
  #[inline]
  fn default() -> Self {
    DrawProtoArgs {
      id: 0,
      position: None, // required field
      angle: 0.0,
      color: 0,
      scale: 1.0,
    }
  }
}

pub struct DrawProtoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DrawProtoBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: u64) {
    self.fbb_.push_slot::<u64>(DrawProto::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_position(&mut self, position: &Vector2f) {
    self.fbb_.push_slot_always::<&Vector2f>(DrawProto::VT_POSITION, position);
  }
  #[inline]
  pub fn add_angle(&mut self, angle: f32) {
    self.fbb_.push_slot::<f32>(DrawProto::VT_ANGLE, angle, 0.0);
  }
  #[inline]
  pub fn add_color(&mut self, color: u32) {
    self.fbb_.push_slot::<u32>(DrawProto::VT_COLOR, color, 0);
  }
  #[inline]
  pub fn add_scale(&mut self, scale: f32) {
    self.fbb_.push_slot::<f32>(DrawProto::VT_SCALE, scale, 1.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DrawProtoBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DrawProtoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DrawProto<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, DrawProto::VT_POSITION,"position");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DrawProto<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DrawProto");
      ds.field("id", &self.id());
      ds.field("position", &self.position());
      ds.field("angle", &self.angle());
      ds.field("color", &self.color());
      ds.field("scale", &self.scale());
      ds.finish()
  }
}
}  // pub mod fbs
}  // pub mod rewind_viewer

