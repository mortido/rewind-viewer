// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod rewind_viewer {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod fbs {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ACTION_INPUT: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ACTION_INPUT: u8 = 6;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ACTION_INPUT: [ActionInput; 7] = [
  ActionInput::NONE,
  ActionInput::BoolInput,
  ActionInput::ButtonInput,
  ActionInput::FloatInput,
  ActionInput::IntInput,
  ActionInput::SelectInput,
  ActionInput::StringInput,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ActionInput(pub u8);
#[allow(non_upper_case_globals)]
impl ActionInput {
  pub const NONE: Self = Self(0);
  pub const BoolInput: Self = Self(1);
  pub const ButtonInput: Self = Self(2);
  pub const FloatInput: Self = Self(3);
  pub const IntInput: Self = Self(4);
  pub const SelectInput: Self = Self(5);
  pub const StringInput: Self = Self(6);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 6;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::BoolInput,
    Self::ButtonInput,
    Self::FloatInput,
    Self::IntInput,
    Self::SelectInput,
    Self::StringInput,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::BoolInput => Some("BoolInput"),
      Self::ButtonInput => Some("ButtonInput"),
      Self::FloatInput => Some("FloatInput"),
      Self::IntInput => Some("IntInput"),
      Self::SelectInput => Some("SelectInput"),
      Self::StringInput => Some("StringInput"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ActionInput {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ActionInput {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ActionInput {
    type Output = ActionInput;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ActionInput {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ActionInput {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ActionInput {}
pub struct ActionInputUnionTableOffset {}

pub enum SubscribeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Subscribe<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Subscribe<'a> {
  type Inner = Subscribe<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Subscribe<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_CONTINUOUS: flatbuffers::VOffsetT = 8;
  pub const VT_CAPTURE_MOUSE: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Subscribe { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SubscribeArgs<'args>
  ) -> flatbuffers::WIPOffset<Subscribe<'bldr>> {
    let mut builder = SubscribeBuilder::new(_fbb);
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_capture_mouse(args.capture_mouse);
    builder.add_continuous(args.continuous);
    builder.add_key(args.key);
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(Subscribe::VT_KEY, Some(0)).unwrap()}
  }
  #[inline]
  pub fn name(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Subscribe::VT_NAME, None).unwrap()}
  }
  #[inline]
  pub fn continuous(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Subscribe::VT_CONTINUOUS, Some(false)).unwrap()}
  }
  #[inline]
  pub fn capture_mouse(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Subscribe::VT_CAPTURE_MOUSE, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Subscribe<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i8>("key", Self::VT_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, true)?
     .visit_field::<bool>("continuous", Self::VT_CONTINUOUS, false)?
     .visit_field::<bool>("capture_mouse", Self::VT_CAPTURE_MOUSE, false)?
     .finish();
    Ok(())
  }
}
pub struct SubscribeArgs<'a> {
    pub key: i8,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub continuous: bool,
    pub capture_mouse: bool,
}
impl<'a> Default for SubscribeArgs<'a> {
  #[inline]
  fn default() -> Self {
    SubscribeArgs {
      key: 0,
      name: None, // required field
      continuous: false,
      capture_mouse: false,
    }
  }
}

pub struct SubscribeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SubscribeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: i8) {
    self.fbb_.push_slot::<i8>(Subscribe::VT_KEY, key, 0);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Subscribe::VT_NAME, name);
  }
  #[inline]
  pub fn add_continuous(&mut self, continuous: bool) {
    self.fbb_.push_slot::<bool>(Subscribe::VT_CONTINUOUS, continuous, false);
  }
  #[inline]
  pub fn add_capture_mouse(&mut self, capture_mouse: bool) {
    self.fbb_.push_slot::<bool>(Subscribe::VT_CAPTURE_MOUSE, capture_mouse, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SubscribeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SubscribeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Subscribe<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Subscribe::VT_NAME,"name");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Subscribe<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Subscribe");
      ds.field("key", &self.key());
      ds.field("name", &self.name());
      ds.field("continuous", &self.continuous());
      ds.field("capture_mouse", &self.capture_mouse());
      ds.finish()
  }
}
pub enum UnsubscribeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Unsubscribe<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Unsubscribe<'a> {
  type Inner = Unsubscribe<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Unsubscribe<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Unsubscribe { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args UnsubscribeArgs
  ) -> flatbuffers::WIPOffset<Unsubscribe<'bldr>> {
    let mut builder = UnsubscribeBuilder::new(_fbb);
    builder.add_key(args.key);
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(Unsubscribe::VT_KEY, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Unsubscribe<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i8>("key", Self::VT_KEY, false)?
     .finish();
    Ok(())
  }
}
pub struct UnsubscribeArgs {
    pub key: i8,
}
impl<'a> Default for UnsubscribeArgs {
  #[inline]
  fn default() -> Self {
    UnsubscribeArgs {
      key: 0,
    }
  }
}

pub struct UnsubscribeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> UnsubscribeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: i8) {
    self.fbb_.push_slot::<i8>(Unsubscribe::VT_KEY, key, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> UnsubscribeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    UnsubscribeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Unsubscribe<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Unsubscribe<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Unsubscribe");
      ds.field("key", &self.key());
      ds.finish()
  }
}
pub enum IntInputOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct IntInput<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IntInput<'a> {
  type Inner = IntInput<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> IntInput<'a> {
  pub const VT_DEFAULT_VALUE: flatbuffers::VOffsetT = 4;
  pub const VT_MIN_VALUE: flatbuffers::VOffsetT = 6;
  pub const VT_MAX_VALUE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    IntInput { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args IntInputArgs
  ) -> flatbuffers::WIPOffset<IntInput<'bldr>> {
    let mut builder = IntInputBuilder::new(_fbb);
    builder.add_max_value(args.max_value);
    builder.add_min_value(args.min_value);
    builder.add_default_value(args.default_value);
    builder.finish()
  }


  #[inline]
  pub fn default_value(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(IntInput::VT_DEFAULT_VALUE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn min_value(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(IntInput::VT_MIN_VALUE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn max_value(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(IntInput::VT_MAX_VALUE, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for IntInput<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("default_value", Self::VT_DEFAULT_VALUE, false)?
     .visit_field::<i32>("min_value", Self::VT_MIN_VALUE, false)?
     .visit_field::<i32>("max_value", Self::VT_MAX_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct IntInputArgs {
    pub default_value: i32,
    pub min_value: i32,
    pub max_value: i32,
}
impl<'a> Default for IntInputArgs {
  #[inline]
  fn default() -> Self {
    IntInputArgs {
      default_value: 0,
      min_value: 0,
      max_value: 0,
    }
  }
}

pub struct IntInputBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> IntInputBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_default_value(&mut self, default_value: i32) {
    self.fbb_.push_slot::<i32>(IntInput::VT_DEFAULT_VALUE, default_value, 0);
  }
  #[inline]
  pub fn add_min_value(&mut self, min_value: i32) {
    self.fbb_.push_slot::<i32>(IntInput::VT_MIN_VALUE, min_value, 0);
  }
  #[inline]
  pub fn add_max_value(&mut self, max_value: i32) {
    self.fbb_.push_slot::<i32>(IntInput::VT_MAX_VALUE, max_value, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> IntInputBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    IntInputBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IntInput<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for IntInput<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("IntInput");
      ds.field("default_value", &self.default_value());
      ds.field("min_value", &self.min_value());
      ds.field("max_value", &self.max_value());
      ds.finish()
  }
}
pub enum FloatInputOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FloatInput<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FloatInput<'a> {
  type Inner = FloatInput<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> FloatInput<'a> {
  pub const VT_DEFAULT_VALUE: flatbuffers::VOffsetT = 4;
  pub const VT_MIN_VALUE: flatbuffers::VOffsetT = 6;
  pub const VT_MAX_VALUE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FloatInput { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args FloatInputArgs
  ) -> flatbuffers::WIPOffset<FloatInput<'bldr>> {
    let mut builder = FloatInputBuilder::new(_fbb);
    builder.add_max_value(args.max_value);
    builder.add_min_value(args.min_value);
    builder.add_default_value(args.default_value);
    builder.finish()
  }


  #[inline]
  pub fn default_value(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(FloatInput::VT_DEFAULT_VALUE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn min_value(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(FloatInput::VT_MIN_VALUE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn max_value(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(FloatInput::VT_MAX_VALUE, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for FloatInput<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>("default_value", Self::VT_DEFAULT_VALUE, false)?
     .visit_field::<f32>("min_value", Self::VT_MIN_VALUE, false)?
     .visit_field::<f32>("max_value", Self::VT_MAX_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct FloatInputArgs {
    pub default_value: f32,
    pub min_value: f32,
    pub max_value: f32,
}
impl<'a> Default for FloatInputArgs {
  #[inline]
  fn default() -> Self {
    FloatInputArgs {
      default_value: 0.0,
      min_value: 0.0,
      max_value: 0.0,
    }
  }
}

pub struct FloatInputBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FloatInputBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_default_value(&mut self, default_value: f32) {
    self.fbb_.push_slot::<f32>(FloatInput::VT_DEFAULT_VALUE, default_value, 0.0);
  }
  #[inline]
  pub fn add_min_value(&mut self, min_value: f32) {
    self.fbb_.push_slot::<f32>(FloatInput::VT_MIN_VALUE, min_value, 0.0);
  }
  #[inline]
  pub fn add_max_value(&mut self, max_value: f32) {
    self.fbb_.push_slot::<f32>(FloatInput::VT_MAX_VALUE, max_value, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> FloatInputBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    FloatInputBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FloatInput<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for FloatInput<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("FloatInput");
      ds.field("default_value", &self.default_value());
      ds.field("min_value", &self.min_value());
      ds.field("max_value", &self.max_value());
      ds.finish()
  }
}
pub enum SelectInputOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SelectInput<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SelectInput<'a> {
  type Inner = SelectInput<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SelectInput<'a> {
  pub const VT_OPTIONS: flatbuffers::VOffsetT = 4;
  pub const VT_SELECTED_OPTION: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SelectInput { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SelectInputArgs<'args>
  ) -> flatbuffers::WIPOffset<SelectInput<'bldr>> {
    let mut builder = SelectInputBuilder::new(_fbb);
    if let Some(x) = args.options { builder.add_options(x); }
    builder.add_selected_option(args.selected_option);
    builder.finish()
  }


  #[inline]
  pub fn options(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(SelectInput::VT_OPTIONS, None).unwrap()}
  }
  #[inline]
  pub fn selected_option(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(SelectInput::VT_SELECTED_OPTION, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for SelectInput<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("options", Self::VT_OPTIONS, true)?
     .visit_field::<u16>("selected_option", Self::VT_SELECTED_OPTION, false)?
     .finish();
    Ok(())
  }
}
pub struct SelectInputArgs<'a> {
    pub options: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub selected_option: u16,
}
impl<'a> Default for SelectInputArgs<'a> {
  #[inline]
  fn default() -> Self {
    SelectInputArgs {
      options: None, // required field
      selected_option: 0,
    }
  }
}

pub struct SelectInputBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SelectInputBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_options(&mut self, options: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SelectInput::VT_OPTIONS, options);
  }
  #[inline]
  pub fn add_selected_option(&mut self, selected_option: u16) {
    self.fbb_.push_slot::<u16>(SelectInput::VT_SELECTED_OPTION, selected_option, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SelectInputBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SelectInputBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SelectInput<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, SelectInput::VT_OPTIONS,"options");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SelectInput<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SelectInput");
      ds.field("options", &self.options());
      ds.field("selected_option", &self.selected_option());
      ds.finish()
  }
}
pub enum StringInputOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct StringInput<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StringInput<'a> {
  type Inner = StringInput<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> StringInput<'a> {
  pub const VT_DEFAULT_VALUE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    StringInput { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args StringInputArgs<'args>
  ) -> flatbuffers::WIPOffset<StringInput<'bldr>> {
    let mut builder = StringInputBuilder::new(_fbb);
    if let Some(x) = args.default_value { builder.add_default_value(x); }
    builder.finish()
  }


  #[inline]
  pub fn default_value(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StringInput::VT_DEFAULT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for StringInput<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("default_value", Self::VT_DEFAULT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct StringInputArgs<'a> {
    pub default_value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for StringInputArgs<'a> {
  #[inline]
  fn default() -> Self {
    StringInputArgs {
      default_value: None,
    }
  }
}

pub struct StringInputBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StringInputBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_default_value(&mut self, default_value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StringInput::VT_DEFAULT_VALUE, default_value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> StringInputBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    StringInputBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StringInput<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for StringInput<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("StringInput");
      ds.field("default_value", &self.default_value());
      ds.finish()
  }
}
pub enum BoolInputOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BoolInput<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BoolInput<'a> {
  type Inner = BoolInput<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BoolInput<'a> {
  pub const VT_DEFAULT_VALUE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BoolInput { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BoolInputArgs
  ) -> flatbuffers::WIPOffset<BoolInput<'bldr>> {
    let mut builder = BoolInputBuilder::new(_fbb);
    builder.add_default_value(args.default_value);
    builder.finish()
  }


  #[inline]
  pub fn default_value(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(BoolInput::VT_DEFAULT_VALUE, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for BoolInput<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("default_value", Self::VT_DEFAULT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct BoolInputArgs {
    pub default_value: bool,
}
impl<'a> Default for BoolInputArgs {
  #[inline]
  fn default() -> Self {
    BoolInputArgs {
      default_value: false,
    }
  }
}

pub struct BoolInputBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BoolInputBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_default_value(&mut self, default_value: bool) {
    self.fbb_.push_slot::<bool>(BoolInput::VT_DEFAULT_VALUE, default_value, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BoolInputBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BoolInputBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BoolInput<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BoolInput<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BoolInput");
      ds.field("default_value", &self.default_value());
      ds.finish()
  }
}
pub enum ButtonInputOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ButtonInput<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ButtonInput<'a> {
  type Inner = ButtonInput<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ButtonInput<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ButtonInput { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    _args: &'args ButtonInputArgs
  ) -> flatbuffers::WIPOffset<ButtonInput<'bldr>> {
    let mut builder = ButtonInputBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for ButtonInput<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct ButtonInputArgs {
}
impl<'a> Default for ButtonInputArgs {
  #[inline]
  fn default() -> Self {
    ButtonInputArgs {
    }
  }
}

pub struct ButtonInputBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ButtonInputBuilder<'a, 'b, A> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ButtonInputBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ButtonInputBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ButtonInput<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ButtonInput<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ButtonInput");
      ds.finish()
  }
}
pub enum CreateActionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CreateAction<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CreateAction<'a> {
  type Inner = CreateAction<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CreateAction<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_INPUT_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_INPUT: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CreateAction { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CreateActionArgs<'args>
  ) -> flatbuffers::WIPOffset<CreateAction<'bldr>> {
    let mut builder = CreateActionBuilder::new(_fbb);
    if let Some(x) = args.input { builder.add_input(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_input_type(args.input_type);
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CreateAction::VT_NAME, None).unwrap()}
  }
  #[inline]
  pub fn input_type(&self) -> ActionInput {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ActionInput>(CreateAction::VT_INPUT_TYPE, Some(ActionInput::NONE)).unwrap()}
  }
  #[inline]
  pub fn input(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(CreateAction::VT_INPUT, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn input_as_bool_input(&self) -> Option<BoolInput<'a>> {
    if self.input_type() == ActionInput::BoolInput {
      self.input().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { BoolInput::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn input_as_button_input(&self) -> Option<ButtonInput<'a>> {
    if self.input_type() == ActionInput::ButtonInput {
      self.input().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ButtonInput::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn input_as_float_input(&self) -> Option<FloatInput<'a>> {
    if self.input_type() == ActionInput::FloatInput {
      self.input().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { FloatInput::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn input_as_int_input(&self) -> Option<IntInput<'a>> {
    if self.input_type() == ActionInput::IntInput {
      self.input().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { IntInput::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn input_as_select_input(&self) -> Option<SelectInput<'a>> {
    if self.input_type() == ActionInput::SelectInput {
      self.input().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SelectInput::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn input_as_string_input(&self) -> Option<StringInput<'a>> {
    if self.input_type() == ActionInput::StringInput {
      self.input().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { StringInput::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for CreateAction<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, true)?
     .visit_union::<ActionInput, _>("input_type", Self::VT_INPUT_TYPE, "input", Self::VT_INPUT, false, |key, v, pos| {
        match key {
          ActionInput::BoolInput => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BoolInput>>("ActionInput::BoolInput", pos),
          ActionInput::ButtonInput => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ButtonInput>>("ActionInput::ButtonInput", pos),
          ActionInput::FloatInput => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloatInput>>("ActionInput::FloatInput", pos),
          ActionInput::IntInput => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IntInput>>("ActionInput::IntInput", pos),
          ActionInput::SelectInput => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SelectInput>>("ActionInput::SelectInput", pos),
          ActionInput::StringInput => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringInput>>("ActionInput::StringInput", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct CreateActionArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub input_type: ActionInput,
    pub input: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for CreateActionArgs<'a> {
  #[inline]
  fn default() -> Self {
    CreateActionArgs {
      name: None, // required field
      input_type: ActionInput::NONE,
      input: None,
    }
  }
}

pub struct CreateActionBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CreateActionBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CreateAction::VT_NAME, name);
  }
  #[inline]
  pub fn add_input_type(&mut self, input_type: ActionInput) {
    self.fbb_.push_slot::<ActionInput>(CreateAction::VT_INPUT_TYPE, input_type, ActionInput::NONE);
  }
  #[inline]
  pub fn add_input(&mut self, input: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CreateAction::VT_INPUT, input);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CreateActionBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CreateActionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CreateAction<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, CreateAction::VT_NAME,"name");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CreateAction<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CreateAction");
      ds.field("name", &self.name());
      ds.field("input_type", &self.input_type());
      match self.input_type() {
        ActionInput::BoolInput => {
          if let Some(x) = self.input_as_bool_input() {
            ds.field("input", &x)
          } else {
            ds.field("input", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ActionInput::ButtonInput => {
          if let Some(x) = self.input_as_button_input() {
            ds.field("input", &x)
          } else {
            ds.field("input", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ActionInput::FloatInput => {
          if let Some(x) = self.input_as_float_input() {
            ds.field("input", &x)
          } else {
            ds.field("input", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ActionInput::IntInput => {
          if let Some(x) = self.input_as_int_input() {
            ds.field("input", &x)
          } else {
            ds.field("input", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ActionInput::SelectInput => {
          if let Some(x) = self.input_as_select_input() {
            ds.field("input", &x)
          } else {
            ds.field("input", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ActionInput::StringInput => {
          if let Some(x) = self.input_as_string_input() {
            ds.field("input", &x)
          } else {
            ds.field("input", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("input", &x)
        },
      };
      ds.finish()
  }
}
pub enum RemoveActionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RemoveAction<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RemoveAction<'a> {
  type Inner = RemoveAction<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RemoveAction<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RemoveAction { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RemoveActionArgs<'args>
  ) -> flatbuffers::WIPOffset<RemoveAction<'bldr>> {
    let mut builder = RemoveActionBuilder::new(_fbb);
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RemoveAction::VT_NAME, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for RemoveAction<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, true)?
     .finish();
    Ok(())
  }
}
pub struct RemoveActionArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for RemoveActionArgs<'a> {
  #[inline]
  fn default() -> Self {
    RemoveActionArgs {
      name: None, // required field
    }
  }
}

pub struct RemoveActionBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RemoveActionBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RemoveAction::VT_NAME, name);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RemoveActionBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RemoveActionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RemoveAction<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, RemoveAction::VT_NAME,"name");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RemoveAction<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RemoveAction");
      ds.field("name", &self.name());
      ds.finish()
  }
}
pub enum ReadEventsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ReadEvents<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReadEvents<'a> {
  type Inner = ReadEvents<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ReadEvents<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ReadEvents { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    _args: &'args ReadEventsArgs
  ) -> flatbuffers::WIPOffset<ReadEvents<'bldr>> {
    let mut builder = ReadEventsBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for ReadEvents<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct ReadEventsArgs {
}
impl<'a> Default for ReadEventsArgs {
  #[inline]
  fn default() -> Self {
    ReadEventsArgs {
    }
  }
}

pub struct ReadEventsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ReadEventsBuilder<'a, 'b, A> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ReadEventsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ReadEventsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ReadEvents<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ReadEvents<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ReadEvents");
      ds.finish()
  }
}
}  // pub mod fbs
}  // pub mod rewind_viewer

