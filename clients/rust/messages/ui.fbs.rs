// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use crate::vector2f.fbs::*;
use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod rewind_viewer {

  use crate::vector2f.fbs::*;
  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod fbs {

  use crate::vector2f.fbs::*;
  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

pub enum LogTextOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LogText<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LogText<'a> {
  type Inner = LogText<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LogText<'a> {
  pub const VT_TEXT: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LogText { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LogTextArgs<'args>
  ) -> flatbuffers::WIPOffset<LogText<'bldr>> {
    let mut builder = LogTextBuilder::new(_fbb);
    if let Some(x) = args.text { builder.add_text(x); }
    builder.finish()
  }


  #[inline]
  pub fn text(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogText::VT_TEXT, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for LogText<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("text", Self::VT_TEXT, true)?
     .finish();
    Ok(())
  }
}
pub struct LogTextArgs<'a> {
    pub text: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for LogTextArgs<'a> {
  #[inline]
  fn default() -> Self {
    LogTextArgs {
      text: None, // required field
    }
  }
}

pub struct LogTextBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LogTextBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_text(&mut self, text: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogText::VT_TEXT, text);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LogTextBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LogTextBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LogText<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, LogText::VT_TEXT,"text");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LogText<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LogText");
      ds.field("text", &self.text());
      ds.finish()
  }
}
pub enum PopupOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Popup<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Popup<'a> {
  type Inner = Popup<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Popup<'a> {
  pub const VT_TEXT: flatbuffers::VOffsetT = 4;
  pub const VT_AREA_POSITION: flatbuffers::VOffsetT = 6;
  pub const VT_AREA_SIZE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Popup { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PopupArgs<'args>
  ) -> flatbuffers::WIPOffset<Popup<'bldr>> {
    let mut builder = PopupBuilder::new(_fbb);
    if let Some(x) = args.area_size { builder.add_area_size(x); }
    if let Some(x) = args.area_position { builder.add_area_position(x); }
    if let Some(x) = args.text { builder.add_text(x); }
    builder.finish()
  }


  #[inline]
  pub fn text(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Popup::VT_TEXT, None).unwrap()}
  }
  #[inline]
  pub fn area_position(&self) -> &'a Vector2f {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector2f>(Popup::VT_AREA_POSITION, None).unwrap()}
  }
  #[inline]
  pub fn area_size(&self) -> &'a Vector2f {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector2f>(Popup::VT_AREA_SIZE, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Popup<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("text", Self::VT_TEXT, true)?
     .visit_field::<Vector2f>("area_position", Self::VT_AREA_POSITION, true)?
     .visit_field::<Vector2f>("area_size", Self::VT_AREA_SIZE, true)?
     .finish();
    Ok(())
  }
}
pub struct PopupArgs<'a> {
    pub text: Option<flatbuffers::WIPOffset<&'a str>>,
    pub area_position: Option<&'a Vector2f>,
    pub area_size: Option<&'a Vector2f>,
}
impl<'a> Default for PopupArgs<'a> {
  #[inline]
  fn default() -> Self {
    PopupArgs {
      text: None, // required field
      area_position: None, // required field
      area_size: None, // required field
    }
  }
}

pub struct PopupBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PopupBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_text(&mut self, text: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Popup::VT_TEXT, text);
  }
  #[inline]
  pub fn add_area_position(&mut self, area_position: &Vector2f) {
    self.fbb_.push_slot_always::<&Vector2f>(Popup::VT_AREA_POSITION, area_position);
  }
  #[inline]
  pub fn add_area_size(&mut self, area_size: &Vector2f) {
    self.fbb_.push_slot_always::<&Vector2f>(Popup::VT_AREA_SIZE, area_size);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PopupBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PopupBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Popup<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Popup::VT_TEXT,"text");
    self.fbb_.required(o, Popup::VT_AREA_POSITION,"area_position");
    self.fbb_.required(o, Popup::VT_AREA_SIZE,"area_size");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Popup<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Popup");
      ds.field("text", &self.text());
      ds.field("area_position", &self.area_position());
      ds.field("area_size", &self.area_size());
      ds.finish()
  }
}
pub enum PopupRoundOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PopupRound<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PopupRound<'a> {
  type Inner = PopupRound<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PopupRound<'a> {
  pub const VT_TEXT: flatbuffers::VOffsetT = 4;
  pub const VT_AREA_CENTER: flatbuffers::VOffsetT = 6;
  pub const VT_AREA_RADIUS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PopupRound { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PopupRoundArgs<'args>
  ) -> flatbuffers::WIPOffset<PopupRound<'bldr>> {
    let mut builder = PopupRoundBuilder::new(_fbb);
    builder.add_area_radius(args.area_radius);
    if let Some(x) = args.area_center { builder.add_area_center(x); }
    if let Some(x) = args.text { builder.add_text(x); }
    builder.finish()
  }


  #[inline]
  pub fn text(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PopupRound::VT_TEXT, None).unwrap()}
  }
  #[inline]
  pub fn area_center(&self) -> &'a Vector2f {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector2f>(PopupRound::VT_AREA_CENTER, None).unwrap()}
  }
  #[inline]
  pub fn area_radius(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(PopupRound::VT_AREA_RADIUS, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for PopupRound<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("text", Self::VT_TEXT, true)?
     .visit_field::<Vector2f>("area_center", Self::VT_AREA_CENTER, true)?
     .visit_field::<f32>("area_radius", Self::VT_AREA_RADIUS, false)?
     .finish();
    Ok(())
  }
}
pub struct PopupRoundArgs<'a> {
    pub text: Option<flatbuffers::WIPOffset<&'a str>>,
    pub area_center: Option<&'a Vector2f>,
    pub area_radius: f32,
}
impl<'a> Default for PopupRoundArgs<'a> {
  #[inline]
  fn default() -> Self {
    PopupRoundArgs {
      text: None, // required field
      area_center: None, // required field
      area_radius: 0.0,
    }
  }
}

pub struct PopupRoundBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PopupRoundBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_text(&mut self, text: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PopupRound::VT_TEXT, text);
  }
  #[inline]
  pub fn add_area_center(&mut self, area_center: &Vector2f) {
    self.fbb_.push_slot_always::<&Vector2f>(PopupRound::VT_AREA_CENTER, area_center);
  }
  #[inline]
  pub fn add_area_radius(&mut self, area_radius: f32) {
    self.fbb_.push_slot::<f32>(PopupRound::VT_AREA_RADIUS, area_radius, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PopupRoundBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PopupRoundBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PopupRound<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, PopupRound::VT_TEXT,"text");
    self.fbb_.required(o, PopupRound::VT_AREA_CENTER,"area_center");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PopupRound<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PopupRound");
      ds.field("text", &self.text());
      ds.field("area_center", &self.area_center());
      ds.field("area_radius", &self.area_radius());
      ds.finish()
  }
}
pub enum CameraViewOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CameraView<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CameraView<'a> {
  type Inner = CameraView<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CameraView<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_POSITION: flatbuffers::VOffsetT = 6;
  pub const VT_VIEW_RADIUS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CameraView { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CameraViewArgs<'args>
  ) -> flatbuffers::WIPOffset<CameraView<'bldr>> {
    let mut builder = CameraViewBuilder::new(_fbb);
    builder.add_view_radius(args.view_radius);
    if let Some(x) = args.position { builder.add_position(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CameraView::VT_NAME, None).unwrap()}
  }
  #[inline]
  pub fn position(&self) -> &'a Vector2f {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector2f>(CameraView::VT_POSITION, None).unwrap()}
  }
  #[inline]
  pub fn view_radius(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(CameraView::VT_VIEW_RADIUS, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for CameraView<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, true)?
     .visit_field::<Vector2f>("position", Self::VT_POSITION, true)?
     .visit_field::<f32>("view_radius", Self::VT_VIEW_RADIUS, false)?
     .finish();
    Ok(())
  }
}
pub struct CameraViewArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub position: Option<&'a Vector2f>,
    pub view_radius: f32,
}
impl<'a> Default for CameraViewArgs<'a> {
  #[inline]
  fn default() -> Self {
    CameraViewArgs {
      name: None, // required field
      position: None, // required field
      view_radius: 0.0,
    }
  }
}

pub struct CameraViewBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CameraViewBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CameraView::VT_NAME, name);
  }
  #[inline]
  pub fn add_position(&mut self, position: &Vector2f) {
    self.fbb_.push_slot_always::<&Vector2f>(CameraView::VT_POSITION, position);
  }
  #[inline]
  pub fn add_view_radius(&mut self, view_radius: f32) {
    self.fbb_.push_slot::<f32>(CameraView::VT_VIEW_RADIUS, view_radius, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CameraViewBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CameraViewBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CameraView<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, CameraView::VT_NAME,"name");
    self.fbb_.required(o, CameraView::VT_POSITION,"position");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CameraView<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CameraView");
      ds.field("name", &self.name());
      ds.field("position", &self.position());
      ds.field("view_radius", &self.view_radius());
      ds.finish()
  }
}
pub enum TextOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Text<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Text<'a> {
  type Inner = Text<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Text<'a> {
  pub const VT_TEXT: flatbuffers::VOffsetT = 4;
  pub const VT_POSITION: flatbuffers::VOffsetT = 6;
  pub const VT_SIZE_: flatbuffers::VOffsetT = 8;
  pub const VT_COLOR: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Text { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TextArgs<'args>
  ) -> flatbuffers::WIPOffset<Text<'bldr>> {
    let mut builder = TextBuilder::new(_fbb);
    builder.add_color(args.color);
    builder.add_size_(args.size_);
    if let Some(x) = args.position { builder.add_position(x); }
    if let Some(x) = args.text { builder.add_text(x); }
    builder.finish()
  }


  #[inline]
  pub fn text(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Text::VT_TEXT, None).unwrap()}
  }
  #[inline]
  pub fn position(&self) -> &'a Vector2f {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector2f>(Text::VT_POSITION, None).unwrap()}
  }
  #[inline]
  pub fn size_(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Text::VT_SIZE_, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn color(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Text::VT_COLOR, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Text<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("text", Self::VT_TEXT, true)?
     .visit_field::<Vector2f>("position", Self::VT_POSITION, true)?
     .visit_field::<f32>("size_", Self::VT_SIZE_, false)?
     .visit_field::<u32>("color", Self::VT_COLOR, false)?
     .finish();
    Ok(())
  }
}
pub struct TextArgs<'a> {
    pub text: Option<flatbuffers::WIPOffset<&'a str>>,
    pub position: Option<&'a Vector2f>,
    pub size_: f32,
    pub color: u32,
}
impl<'a> Default for TextArgs<'a> {
  #[inline]
  fn default() -> Self {
    TextArgs {
      text: None, // required field
      position: None, // required field
      size_: 0.0,
      color: 0,
    }
  }
}

pub struct TextBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TextBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_text(&mut self, text: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Text::VT_TEXT, text);
  }
  #[inline]
  pub fn add_position(&mut self, position: &Vector2f) {
    self.fbb_.push_slot_always::<&Vector2f>(Text::VT_POSITION, position);
  }
  #[inline]
  pub fn add_size_(&mut self, size_: f32) {
    self.fbb_.push_slot::<f32>(Text::VT_SIZE_, size_, 0.0);
  }
  #[inline]
  pub fn add_color(&mut self, color: u32) {
    self.fbb_.push_slot::<u32>(Text::VT_COLOR, color, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TextBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TextBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Text<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Text::VT_TEXT,"text");
    self.fbb_.required(o, Text::VT_POSITION,"position");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Text<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Text");
      ds.field("text", &self.text());
      ds.field("position", &self.position());
      ds.field("size_", &self.size_());
      ds.field("color", &self.color());
      ds.finish()
  }
}
}  // pub mod fbs
}  // pub mod rewind_viewer

