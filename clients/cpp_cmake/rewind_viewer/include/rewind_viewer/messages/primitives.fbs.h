// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PRIMITIVES_REWIND_VIEWER_FBS_H_
#define FLATBUFFERS_GENERATED_PRIMITIVES_REWIND_VIEWER_FBS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

#include "vector2f.fbs.h"

namespace rewind_viewer {
namespace fbs {

struct Color;
struct ColorBuilder;

struct Circle;
struct CircleBuilder;

struct Arc;
struct ArcBuilder;

struct CircleSegment;
struct CircleSegmentBuilder;

struct Tiles;
struct TilesBuilder;

struct Rectangle;
struct RectangleBuilder;

struct Triangle;
struct TriangleBuilder;

struct Polyline;
struct PolylineBuilder;

struct StartProto;
struct StartProtoBuilder;

struct EndProto;
struct EndProtoBuilder;

struct DrawProto;
struct DrawProtoBuilder;

struct Color FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ColorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_FILL = 6
  };
  uint32_t value() const {
    return GetField<uint32_t>(VT_VALUE, 0);
  }
  bool fill() const {
    return GetField<uint8_t>(VT_FILL, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_VALUE, 4) &&
           VerifyField<uint8_t>(verifier, VT_FILL, 1) &&
           verifier.EndTable();
  }
};

struct ColorBuilder {
  typedef Color Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(uint32_t value) {
    fbb_.AddElement<uint32_t>(Color::VT_VALUE, value, 0);
  }
  void add_fill(bool fill) {
    fbb_.AddElement<uint8_t>(Color::VT_FILL, static_cast<uint8_t>(fill), 0);
  }
  explicit ColorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Color> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Color>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Color> CreateColor(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t value = 0,
    bool fill = false) {
  ColorBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_fill(fill);
  return builder_.Finish();
}

struct Circle FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CircleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLOR = 4,
    VT_CENTER = 6,
    VT_RADIUS = 8
  };
  const rewind_viewer::fbs::Color *color() const {
    return GetPointer<const rewind_viewer::fbs::Color *>(VT_COLOR);
  }
  const rewind_viewer::fbs::Vector2f *center() const {
    return GetStruct<const rewind_viewer::fbs::Vector2f *>(VT_CENTER);
  }
  float radius() const {
    return GetField<float>(VT_RADIUS, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COLOR) &&
           verifier.VerifyTable(color()) &&
           VerifyFieldRequired<rewind_viewer::fbs::Vector2f>(verifier, VT_CENTER, 4) &&
           VerifyField<float>(verifier, VT_RADIUS, 4) &&
           verifier.EndTable();
  }
};

struct CircleBuilder {
  typedef Circle Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_color(::flatbuffers::Offset<rewind_viewer::fbs::Color> color) {
    fbb_.AddOffset(Circle::VT_COLOR, color);
  }
  void add_center(const rewind_viewer::fbs::Vector2f *center) {
    fbb_.AddStruct(Circle::VT_CENTER, center);
  }
  void add_radius(float radius) {
    fbb_.AddElement<float>(Circle::VT_RADIUS, radius, 0.0f);
  }
  explicit CircleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Circle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Circle>(end);
    fbb_.Required(o, Circle::VT_CENTER);
    return o;
  }
};

inline ::flatbuffers::Offset<Circle> CreateCircle(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<rewind_viewer::fbs::Color> color = 0,
    const rewind_viewer::fbs::Vector2f *center = nullptr,
    float radius = 0.0f) {
  CircleBuilder builder_(_fbb);
  builder_.add_radius(radius);
  builder_.add_center(center);
  builder_.add_color(color);
  return builder_.Finish();
}

struct Arc FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ArcBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLOR = 4,
    VT_CENTER = 6,
    VT_RADIUS = 8,
    VT_START_ANGLE = 10,
    VT_END_ANGLE = 12
  };
  const rewind_viewer::fbs::Color *color() const {
    return GetPointer<const rewind_viewer::fbs::Color *>(VT_COLOR);
  }
  const rewind_viewer::fbs::Vector2f *center() const {
    return GetStruct<const rewind_viewer::fbs::Vector2f *>(VT_CENTER);
  }
  float radius() const {
    return GetField<float>(VT_RADIUS, 0.0f);
  }
  float start_angle() const {
    return GetField<float>(VT_START_ANGLE, 0.0f);
  }
  float end_angle() const {
    return GetField<float>(VT_END_ANGLE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COLOR) &&
           verifier.VerifyTable(color()) &&
           VerifyFieldRequired<rewind_viewer::fbs::Vector2f>(verifier, VT_CENTER, 4) &&
           VerifyField<float>(verifier, VT_RADIUS, 4) &&
           VerifyField<float>(verifier, VT_START_ANGLE, 4) &&
           VerifyField<float>(verifier, VT_END_ANGLE, 4) &&
           verifier.EndTable();
  }
};

struct ArcBuilder {
  typedef Arc Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_color(::flatbuffers::Offset<rewind_viewer::fbs::Color> color) {
    fbb_.AddOffset(Arc::VT_COLOR, color);
  }
  void add_center(const rewind_viewer::fbs::Vector2f *center) {
    fbb_.AddStruct(Arc::VT_CENTER, center);
  }
  void add_radius(float radius) {
    fbb_.AddElement<float>(Arc::VT_RADIUS, radius, 0.0f);
  }
  void add_start_angle(float start_angle) {
    fbb_.AddElement<float>(Arc::VT_START_ANGLE, start_angle, 0.0f);
  }
  void add_end_angle(float end_angle) {
    fbb_.AddElement<float>(Arc::VT_END_ANGLE, end_angle, 0.0f);
  }
  explicit ArcBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Arc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Arc>(end);
    fbb_.Required(o, Arc::VT_CENTER);
    return o;
  }
};

inline ::flatbuffers::Offset<Arc> CreateArc(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<rewind_viewer::fbs::Color> color = 0,
    const rewind_viewer::fbs::Vector2f *center = nullptr,
    float radius = 0.0f,
    float start_angle = 0.0f,
    float end_angle = 0.0f) {
  ArcBuilder builder_(_fbb);
  builder_.add_end_angle(end_angle);
  builder_.add_start_angle(start_angle);
  builder_.add_radius(radius);
  builder_.add_center(center);
  builder_.add_color(color);
  return builder_.Finish();
}

struct CircleSegment FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CircleSegmentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLOR = 4,
    VT_CENTER = 6,
    VT_RADIUS = 8,
    VT_START_ANGLE = 10,
    VT_END_ANGLE = 12
  };
  const rewind_viewer::fbs::Color *color() const {
    return GetPointer<const rewind_viewer::fbs::Color *>(VT_COLOR);
  }
  const rewind_viewer::fbs::Vector2f *center() const {
    return GetStruct<const rewind_viewer::fbs::Vector2f *>(VT_CENTER);
  }
  float radius() const {
    return GetField<float>(VT_RADIUS, 0.0f);
  }
  float start_angle() const {
    return GetField<float>(VT_START_ANGLE, 0.0f);
  }
  float end_angle() const {
    return GetField<float>(VT_END_ANGLE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COLOR) &&
           verifier.VerifyTable(color()) &&
           VerifyFieldRequired<rewind_viewer::fbs::Vector2f>(verifier, VT_CENTER, 4) &&
           VerifyField<float>(verifier, VT_RADIUS, 4) &&
           VerifyField<float>(verifier, VT_START_ANGLE, 4) &&
           VerifyField<float>(verifier, VT_END_ANGLE, 4) &&
           verifier.EndTable();
  }
};

struct CircleSegmentBuilder {
  typedef CircleSegment Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_color(::flatbuffers::Offset<rewind_viewer::fbs::Color> color) {
    fbb_.AddOffset(CircleSegment::VT_COLOR, color);
  }
  void add_center(const rewind_viewer::fbs::Vector2f *center) {
    fbb_.AddStruct(CircleSegment::VT_CENTER, center);
  }
  void add_radius(float radius) {
    fbb_.AddElement<float>(CircleSegment::VT_RADIUS, radius, 0.0f);
  }
  void add_start_angle(float start_angle) {
    fbb_.AddElement<float>(CircleSegment::VT_START_ANGLE, start_angle, 0.0f);
  }
  void add_end_angle(float end_angle) {
    fbb_.AddElement<float>(CircleSegment::VT_END_ANGLE, end_angle, 0.0f);
  }
  explicit CircleSegmentBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CircleSegment> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CircleSegment>(end);
    fbb_.Required(o, CircleSegment::VT_CENTER);
    return o;
  }
};

inline ::flatbuffers::Offset<CircleSegment> CreateCircleSegment(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<rewind_viewer::fbs::Color> color = 0,
    const rewind_viewer::fbs::Vector2f *center = nullptr,
    float radius = 0.0f,
    float start_angle = 0.0f,
    float end_angle = 0.0f) {
  CircleSegmentBuilder builder_(_fbb);
  builder_.add_end_angle(end_angle);
  builder_.add_start_angle(start_angle);
  builder_.add_radius(radius);
  builder_.add_center(center);
  builder_.add_color(color);
  return builder_.Finish();
}

struct Tiles FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TilesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POSITION = 4,
    VT_CELL_SIZE = 6,
    VT_ROW_SIZE = 8,
    VT_COLORS = 10
  };
  const rewind_viewer::fbs::Vector2f *position() const {
    return GetStruct<const rewind_viewer::fbs::Vector2f *>(VT_POSITION);
  }
  const rewind_viewer::fbs::Vector2f *cell_size() const {
    return GetStruct<const rewind_viewer::fbs::Vector2f *>(VT_CELL_SIZE);
  }
  uint16_t row_size() const {
    return GetField<uint16_t>(VT_ROW_SIZE, 0);
  }
  const ::flatbuffers::Vector<uint32_t> *colors() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_COLORS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<rewind_viewer::fbs::Vector2f>(verifier, VT_POSITION, 4) &&
           VerifyFieldRequired<rewind_viewer::fbs::Vector2f>(verifier, VT_CELL_SIZE, 4) &&
           VerifyField<uint16_t>(verifier, VT_ROW_SIZE, 2) &&
           VerifyOffsetRequired(verifier, VT_COLORS) &&
           verifier.VerifyVector(colors()) &&
           verifier.EndTable();
  }
};

struct TilesBuilder {
  typedef Tiles Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_position(const rewind_viewer::fbs::Vector2f *position) {
    fbb_.AddStruct(Tiles::VT_POSITION, position);
  }
  void add_cell_size(const rewind_viewer::fbs::Vector2f *cell_size) {
    fbb_.AddStruct(Tiles::VT_CELL_SIZE, cell_size);
  }
  void add_row_size(uint16_t row_size) {
    fbb_.AddElement<uint16_t>(Tiles::VT_ROW_SIZE, row_size, 0);
  }
  void add_colors(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> colors) {
    fbb_.AddOffset(Tiles::VT_COLORS, colors);
  }
  explicit TilesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Tiles> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Tiles>(end);
    fbb_.Required(o, Tiles::VT_POSITION);
    fbb_.Required(o, Tiles::VT_CELL_SIZE);
    fbb_.Required(o, Tiles::VT_COLORS);
    return o;
  }
};

inline ::flatbuffers::Offset<Tiles> CreateTiles(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const rewind_viewer::fbs::Vector2f *position = nullptr,
    const rewind_viewer::fbs::Vector2f *cell_size = nullptr,
    uint16_t row_size = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> colors = 0) {
  TilesBuilder builder_(_fbb);
  builder_.add_colors(colors);
  builder_.add_cell_size(cell_size);
  builder_.add_position(position);
  builder_.add_row_size(row_size);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Tiles> CreateTilesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const rewind_viewer::fbs::Vector2f *position = nullptr,
    const rewind_viewer::fbs::Vector2f *cell_size = nullptr,
    uint16_t row_size = 0,
    const std::vector<uint32_t> *colors = nullptr) {
  auto colors__ = colors ? _fbb.CreateVector<uint32_t>(*colors) : 0;
  return rewind_viewer::fbs::CreateTiles(
      _fbb,
      position,
      cell_size,
      row_size,
      colors__);
}

struct Rectangle FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RectangleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLOR = 4,
    VT_POSITION = 6,
    VT_SIZE = 8
  };
  const rewind_viewer::fbs::Color *color() const {
    return GetPointer<const rewind_viewer::fbs::Color *>(VT_COLOR);
  }
  const rewind_viewer::fbs::Vector2f *position() const {
    return GetStruct<const rewind_viewer::fbs::Vector2f *>(VT_POSITION);
  }
  const rewind_viewer::fbs::Vector2f *size() const {
    return GetStruct<const rewind_viewer::fbs::Vector2f *>(VT_SIZE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COLOR) &&
           verifier.VerifyTable(color()) &&
           VerifyFieldRequired<rewind_viewer::fbs::Vector2f>(verifier, VT_POSITION, 4) &&
           VerifyFieldRequired<rewind_viewer::fbs::Vector2f>(verifier, VT_SIZE, 4) &&
           verifier.EndTable();
  }
};

struct RectangleBuilder {
  typedef Rectangle Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_color(::flatbuffers::Offset<rewind_viewer::fbs::Color> color) {
    fbb_.AddOffset(Rectangle::VT_COLOR, color);
  }
  void add_position(const rewind_viewer::fbs::Vector2f *position) {
    fbb_.AddStruct(Rectangle::VT_POSITION, position);
  }
  void add_size(const rewind_viewer::fbs::Vector2f *size) {
    fbb_.AddStruct(Rectangle::VT_SIZE, size);
  }
  explicit RectangleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Rectangle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Rectangle>(end);
    fbb_.Required(o, Rectangle::VT_POSITION);
    fbb_.Required(o, Rectangle::VT_SIZE);
    return o;
  }
};

inline ::flatbuffers::Offset<Rectangle> CreateRectangle(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<rewind_viewer::fbs::Color> color = 0,
    const rewind_viewer::fbs::Vector2f *position = nullptr,
    const rewind_viewer::fbs::Vector2f *size = nullptr) {
  RectangleBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_position(position);
  builder_.add_color(color);
  return builder_.Finish();
}

struct Triangle FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TriangleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLOR = 4,
    VT_POINTS = 6
  };
  const rewind_viewer::fbs::Color *color() const {
    return GetPointer<const rewind_viewer::fbs::Color *>(VT_COLOR);
  }
  const ::flatbuffers::Vector<const rewind_viewer::fbs::Vector2f *> *points() const {
    return GetPointer<const ::flatbuffers::Vector<const rewind_viewer::fbs::Vector2f *> *>(VT_POINTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COLOR) &&
           verifier.VerifyTable(color()) &&
           VerifyOffsetRequired(verifier, VT_POINTS) &&
           verifier.VerifyVector(points()) &&
           verifier.EndTable();
  }
};

struct TriangleBuilder {
  typedef Triangle Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_color(::flatbuffers::Offset<rewind_viewer::fbs::Color> color) {
    fbb_.AddOffset(Triangle::VT_COLOR, color);
  }
  void add_points(::flatbuffers::Offset<::flatbuffers::Vector<const rewind_viewer::fbs::Vector2f *>> points) {
    fbb_.AddOffset(Triangle::VT_POINTS, points);
  }
  explicit TriangleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Triangle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Triangle>(end);
    fbb_.Required(o, Triangle::VT_POINTS);
    return o;
  }
};

inline ::flatbuffers::Offset<Triangle> CreateTriangle(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<rewind_viewer::fbs::Color> color = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const rewind_viewer::fbs::Vector2f *>> points = 0) {
  TriangleBuilder builder_(_fbb);
  builder_.add_points(points);
  builder_.add_color(color);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Triangle> CreateTriangleDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<rewind_viewer::fbs::Color> color = 0,
    const std::vector<rewind_viewer::fbs::Vector2f> *points = nullptr) {
  auto points__ = points ? _fbb.CreateVectorOfStructs<rewind_viewer::fbs::Vector2f>(*points) : 0;
  return rewind_viewer::fbs::CreateTriangle(
      _fbb,
      color,
      points__);
}

struct Polyline FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PolylineBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLOR = 4,
    VT_POINTS = 6
  };
  const rewind_viewer::fbs::Color *color() const {
    return GetPointer<const rewind_viewer::fbs::Color *>(VT_COLOR);
  }
  const ::flatbuffers::Vector<const rewind_viewer::fbs::Vector2f *> *points() const {
    return GetPointer<const ::flatbuffers::Vector<const rewind_viewer::fbs::Vector2f *> *>(VT_POINTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COLOR) &&
           verifier.VerifyTable(color()) &&
           VerifyOffsetRequired(verifier, VT_POINTS) &&
           verifier.VerifyVector(points()) &&
           verifier.EndTable();
  }
};

struct PolylineBuilder {
  typedef Polyline Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_color(::flatbuffers::Offset<rewind_viewer::fbs::Color> color) {
    fbb_.AddOffset(Polyline::VT_COLOR, color);
  }
  void add_points(::flatbuffers::Offset<::flatbuffers::Vector<const rewind_viewer::fbs::Vector2f *>> points) {
    fbb_.AddOffset(Polyline::VT_POINTS, points);
  }
  explicit PolylineBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Polyline> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Polyline>(end);
    fbb_.Required(o, Polyline::VT_POINTS);
    return o;
  }
};

inline ::flatbuffers::Offset<Polyline> CreatePolyline(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<rewind_viewer::fbs::Color> color = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const rewind_viewer::fbs::Vector2f *>> points = 0) {
  PolylineBuilder builder_(_fbb);
  builder_.add_points(points);
  builder_.add_color(color);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Polyline> CreatePolylineDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<rewind_viewer::fbs::Color> color = 0,
    const std::vector<rewind_viewer::fbs::Vector2f> *points = nullptr) {
  auto points__ = points ? _fbb.CreateVectorOfStructs<rewind_viewer::fbs::Vector2f>(*points) : 0;
  return rewind_viewer::fbs::CreatePolyline(
      _fbb,
      color,
      points__);
}

struct StartProto FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StartProtoBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct StartProtoBuilder {
  typedef StartProto Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit StartProtoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StartProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StartProto>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StartProto> CreateStartProto(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  StartProtoBuilder builder_(_fbb);
  return builder_.Finish();
}

struct EndProto FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EndProtoBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct EndProtoBuilder {
  typedef EndProto Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit EndProtoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EndProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EndProto>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EndProto> CreateEndProto(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  EndProtoBuilder builder_(_fbb);
  return builder_.Finish();
}

struct DrawProto FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DrawProtoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_POSITION = 6,
    VT_ANGLE = 8,
    VT_COLOR = 10,
    VT_SCALE = 12
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  const rewind_viewer::fbs::Vector2f *position() const {
    return GetStruct<const rewind_viewer::fbs::Vector2f *>(VT_POSITION);
  }
  float angle() const {
    return GetField<float>(VT_ANGLE, 0.0f);
  }
  uint32_t color() const {
    return GetField<uint32_t>(VT_COLOR, 0);
  }
  float scale() const {
    return GetField<float>(VT_SCALE, 1.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID, 8) &&
           VerifyFieldRequired<rewind_viewer::fbs::Vector2f>(verifier, VT_POSITION, 4) &&
           VerifyField<float>(verifier, VT_ANGLE, 4) &&
           VerifyField<uint32_t>(verifier, VT_COLOR, 4) &&
           VerifyField<float>(verifier, VT_SCALE, 4) &&
           verifier.EndTable();
  }
};

struct DrawProtoBuilder {
  typedef DrawProto Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(DrawProto::VT_ID, id, 0);
  }
  void add_position(const rewind_viewer::fbs::Vector2f *position) {
    fbb_.AddStruct(DrawProto::VT_POSITION, position);
  }
  void add_angle(float angle) {
    fbb_.AddElement<float>(DrawProto::VT_ANGLE, angle, 0.0f);
  }
  void add_color(uint32_t color) {
    fbb_.AddElement<uint32_t>(DrawProto::VT_COLOR, color, 0);
  }
  void add_scale(float scale) {
    fbb_.AddElement<float>(DrawProto::VT_SCALE, scale, 1.0f);
  }
  explicit DrawProtoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DrawProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DrawProto>(end);
    fbb_.Required(o, DrawProto::VT_POSITION);
    return o;
  }
};

inline ::flatbuffers::Offset<DrawProto> CreateDrawProto(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    const rewind_viewer::fbs::Vector2f *position = nullptr,
    float angle = 0.0f,
    uint32_t color = 0,
    float scale = 1.0f) {
  DrawProtoBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_scale(scale);
  builder_.add_color(color);
  builder_.add_angle(angle);
  builder_.add_position(position);
  return builder_.Finish();
}

}  // namespace fbs
}  // namespace rewind_viewer

#endif  // FLATBUFFERS_GENERATED_PRIMITIVES_REWIND_VIEWER_FBS_H_
