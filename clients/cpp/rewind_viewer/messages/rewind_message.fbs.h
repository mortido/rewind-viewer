// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_REWINDMESSAGE_REWIND_VIEWER_FBS_H_
#define FLATBUFFERS_GENERATED_REWINDMESSAGE_REWIND_VIEWER_FBS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace rewind_viewer {
namespace fbs {

struct Vector2f;

struct Color;
struct ColorBuilder;
struct ColorT;

struct Circle;
struct CircleBuilder;
struct CircleT;

struct Rectangle;
struct RectangleBuilder;
struct RectangleT;

struct Triangle;
struct TriangleBuilder;
struct TriangleT;

struct Polyline;
struct PolylineBuilder;
struct PolylineT;

struct LogText;
struct LogTextBuilder;
struct LogTextT;

struct Popup;
struct PopupBuilder;
struct PopupT;

struct PopupRound;
struct PopupRoundBuilder;
struct PopupRoundT;

struct CameraView;
struct CameraViewBuilder;
struct CameraViewT;

struct Layer;
struct LayerBuilder;
struct LayerT;

struct Map;
struct MapBuilder;
struct MapT;

struct Options;
struct OptionsBuilder;
struct OptionsT;

struct EndFrame;
struct EndFrameBuilder;
struct EndFrameT;

struct RewindMessage;
struct RewindMessageBuilder;
struct RewindMessageT;

enum Command : uint8_t {
  Command_NONE = 0,
  Command_Circle = 1,
  Command_Rectangle = 2,
  Command_Triangle = 3,
  Command_Polyline = 4,
  Command_LogText = 5,
  Command_Popup = 6,
  Command_PopupRound = 7,
  Command_Options = 8,
  Command_CameraView = 9,
  Command_EndFrame = 10,
  Command_MIN = Command_NONE,
  Command_MAX = Command_EndFrame
};

inline const Command (&EnumValuesCommand())[11] {
  static const Command values[] = {
    Command_NONE,
    Command_Circle,
    Command_Rectangle,
    Command_Triangle,
    Command_Polyline,
    Command_LogText,
    Command_Popup,
    Command_PopupRound,
    Command_Options,
    Command_CameraView,
    Command_EndFrame
  };
  return values;
}

inline const char * const *EnumNamesCommand() {
  static const char * const names[12] = {
    "NONE",
    "Circle",
    "Rectangle",
    "Triangle",
    "Polyline",
    "LogText",
    "Popup",
    "PopupRound",
    "Options",
    "CameraView",
    "EndFrame",
    nullptr
  };
  return names;
}

inline const char *EnumNameCommand(Command e) {
  if (::flatbuffers::IsOutRange(e, Command_NONE, Command_EndFrame)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCommand()[index];
}

template<typename T> struct CommandTraits {
  static const Command enum_value = Command_NONE;
};

template<> struct CommandTraits<rewind_viewer::fbs::Circle> {
  static const Command enum_value = Command_Circle;
};

template<> struct CommandTraits<rewind_viewer::fbs::Rectangle> {
  static const Command enum_value = Command_Rectangle;
};

template<> struct CommandTraits<rewind_viewer::fbs::Triangle> {
  static const Command enum_value = Command_Triangle;
};

template<> struct CommandTraits<rewind_viewer::fbs::Polyline> {
  static const Command enum_value = Command_Polyline;
};

template<> struct CommandTraits<rewind_viewer::fbs::LogText> {
  static const Command enum_value = Command_LogText;
};

template<> struct CommandTraits<rewind_viewer::fbs::Popup> {
  static const Command enum_value = Command_Popup;
};

template<> struct CommandTraits<rewind_viewer::fbs::PopupRound> {
  static const Command enum_value = Command_PopupRound;
};

template<> struct CommandTraits<rewind_viewer::fbs::Options> {
  static const Command enum_value = Command_Options;
};

template<> struct CommandTraits<rewind_viewer::fbs::CameraView> {
  static const Command enum_value = Command_CameraView;
};

template<> struct CommandTraits<rewind_viewer::fbs::EndFrame> {
  static const Command enum_value = Command_EndFrame;
};

template<typename T> struct CommandUnionTraits {
  static const Command enum_value = Command_NONE;
};

template<> struct CommandUnionTraits<rewind_viewer::fbs::CircleT> {
  static const Command enum_value = Command_Circle;
};

template<> struct CommandUnionTraits<rewind_viewer::fbs::RectangleT> {
  static const Command enum_value = Command_Rectangle;
};

template<> struct CommandUnionTraits<rewind_viewer::fbs::TriangleT> {
  static const Command enum_value = Command_Triangle;
};

template<> struct CommandUnionTraits<rewind_viewer::fbs::PolylineT> {
  static const Command enum_value = Command_Polyline;
};

template<> struct CommandUnionTraits<rewind_viewer::fbs::LogTextT> {
  static const Command enum_value = Command_LogText;
};

template<> struct CommandUnionTraits<rewind_viewer::fbs::PopupT> {
  static const Command enum_value = Command_Popup;
};

template<> struct CommandUnionTraits<rewind_viewer::fbs::PopupRoundT> {
  static const Command enum_value = Command_PopupRound;
};

template<> struct CommandUnionTraits<rewind_viewer::fbs::OptionsT> {
  static const Command enum_value = Command_Options;
};

template<> struct CommandUnionTraits<rewind_viewer::fbs::CameraViewT> {
  static const Command enum_value = Command_CameraView;
};

template<> struct CommandUnionTraits<rewind_viewer::fbs::EndFrameT> {
  static const Command enum_value = Command_EndFrame;
};

struct CommandUnion {
  Command type;
  void *value;

  CommandUnion() : type(Command_NONE), value(nullptr) {}
  CommandUnion(CommandUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(Command_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  CommandUnion(const CommandUnion &);
  CommandUnion &operator=(const CommandUnion &u)
    { CommandUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  CommandUnion &operator=(CommandUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~CommandUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = CommandUnionTraits<RT>::enum_value;
    if (type != Command_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, Command type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  rewind_viewer::fbs::CircleT *AsCircle() {
    return type == Command_Circle ?
      reinterpret_cast<rewind_viewer::fbs::CircleT *>(value) : nullptr;
  }
  const rewind_viewer::fbs::CircleT *AsCircle() const {
    return type == Command_Circle ?
      reinterpret_cast<const rewind_viewer::fbs::CircleT *>(value) : nullptr;
  }
  rewind_viewer::fbs::RectangleT *AsRectangle() {
    return type == Command_Rectangle ?
      reinterpret_cast<rewind_viewer::fbs::RectangleT *>(value) : nullptr;
  }
  const rewind_viewer::fbs::RectangleT *AsRectangle() const {
    return type == Command_Rectangle ?
      reinterpret_cast<const rewind_viewer::fbs::RectangleT *>(value) : nullptr;
  }
  rewind_viewer::fbs::TriangleT *AsTriangle() {
    return type == Command_Triangle ?
      reinterpret_cast<rewind_viewer::fbs::TriangleT *>(value) : nullptr;
  }
  const rewind_viewer::fbs::TriangleT *AsTriangle() const {
    return type == Command_Triangle ?
      reinterpret_cast<const rewind_viewer::fbs::TriangleT *>(value) : nullptr;
  }
  rewind_viewer::fbs::PolylineT *AsPolyline() {
    return type == Command_Polyline ?
      reinterpret_cast<rewind_viewer::fbs::PolylineT *>(value) : nullptr;
  }
  const rewind_viewer::fbs::PolylineT *AsPolyline() const {
    return type == Command_Polyline ?
      reinterpret_cast<const rewind_viewer::fbs::PolylineT *>(value) : nullptr;
  }
  rewind_viewer::fbs::LogTextT *AsLogText() {
    return type == Command_LogText ?
      reinterpret_cast<rewind_viewer::fbs::LogTextT *>(value) : nullptr;
  }
  const rewind_viewer::fbs::LogTextT *AsLogText() const {
    return type == Command_LogText ?
      reinterpret_cast<const rewind_viewer::fbs::LogTextT *>(value) : nullptr;
  }
  rewind_viewer::fbs::PopupT *AsPopup() {
    return type == Command_Popup ?
      reinterpret_cast<rewind_viewer::fbs::PopupT *>(value) : nullptr;
  }
  const rewind_viewer::fbs::PopupT *AsPopup() const {
    return type == Command_Popup ?
      reinterpret_cast<const rewind_viewer::fbs::PopupT *>(value) : nullptr;
  }
  rewind_viewer::fbs::PopupRoundT *AsPopupRound() {
    return type == Command_PopupRound ?
      reinterpret_cast<rewind_viewer::fbs::PopupRoundT *>(value) : nullptr;
  }
  const rewind_viewer::fbs::PopupRoundT *AsPopupRound() const {
    return type == Command_PopupRound ?
      reinterpret_cast<const rewind_viewer::fbs::PopupRoundT *>(value) : nullptr;
  }
  rewind_viewer::fbs::OptionsT *AsOptions() {
    return type == Command_Options ?
      reinterpret_cast<rewind_viewer::fbs::OptionsT *>(value) : nullptr;
  }
  const rewind_viewer::fbs::OptionsT *AsOptions() const {
    return type == Command_Options ?
      reinterpret_cast<const rewind_viewer::fbs::OptionsT *>(value) : nullptr;
  }
  rewind_viewer::fbs::CameraViewT *AsCameraView() {
    return type == Command_CameraView ?
      reinterpret_cast<rewind_viewer::fbs::CameraViewT *>(value) : nullptr;
  }
  const rewind_viewer::fbs::CameraViewT *AsCameraView() const {
    return type == Command_CameraView ?
      reinterpret_cast<const rewind_viewer::fbs::CameraViewT *>(value) : nullptr;
  }
  rewind_viewer::fbs::EndFrameT *AsEndFrame() {
    return type == Command_EndFrame ?
      reinterpret_cast<rewind_viewer::fbs::EndFrameT *>(value) : nullptr;
  }
  const rewind_viewer::fbs::EndFrameT *AsEndFrame() const {
    return type == Command_EndFrame ?
      reinterpret_cast<const rewind_viewer::fbs::EndFrameT *>(value) : nullptr;
  }
};

bool VerifyCommand(::flatbuffers::Verifier &verifier, const void *obj, Command type);
bool VerifyCommandVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vector2f FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Vector2f()
      : x_(0),
        y_(0) {
  }
  Vector2f(float _x, float _y)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Vector2f, 8);

struct ColorT : public ::flatbuffers::NativeTable {
  typedef Color TableType;
  uint32_t value = 0;
  bool fill = false;
};

struct Color FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ColorT NativeTableType;
  typedef ColorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_FILL = 6
  };
  uint32_t value() const {
    return GetField<uint32_t>(VT_VALUE, 0);
  }
  bool fill() const {
    return GetField<uint8_t>(VT_FILL, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_VALUE, 4) &&
           VerifyField<uint8_t>(verifier, VT_FILL, 1) &&
           verifier.EndTable();
  }
  ColorT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ColorT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Color> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ColorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ColorBuilder {
  typedef Color Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(uint32_t value) {
    fbb_.AddElement<uint32_t>(Color::VT_VALUE, value, 0);
  }
  void add_fill(bool fill) {
    fbb_.AddElement<uint8_t>(Color::VT_FILL, static_cast<uint8_t>(fill), 0);
  }
  explicit ColorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Color> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Color>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Color> CreateColor(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t value = 0,
    bool fill = false) {
  ColorBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_fill(fill);
  return builder_.Finish();
}

::flatbuffers::Offset<Color> CreateColor(::flatbuffers::FlatBufferBuilder &_fbb, const ColorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CircleT : public ::flatbuffers::NativeTable {
  typedef Circle TableType;
  std::unique_ptr<rewind_viewer::fbs::ColorT> color{};
  std::unique_ptr<rewind_viewer::fbs::Vector2f> center{};
  float radius = 0.0f;
  CircleT() = default;
  CircleT(const CircleT &o);
  CircleT(CircleT&&) FLATBUFFERS_NOEXCEPT = default;
  CircleT &operator=(CircleT o) FLATBUFFERS_NOEXCEPT;
};

struct Circle FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CircleT NativeTableType;
  typedef CircleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLOR = 4,
    VT_CENTER = 6,
    VT_RADIUS = 8
  };
  const rewind_viewer::fbs::Color *color() const {
    return GetPointer<const rewind_viewer::fbs::Color *>(VT_COLOR);
  }
  const rewind_viewer::fbs::Vector2f *center() const {
    return GetStruct<const rewind_viewer::fbs::Vector2f *>(VT_CENTER);
  }
  float radius() const {
    return GetField<float>(VT_RADIUS, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_COLOR) &&
           verifier.VerifyTable(color()) &&
           VerifyFieldRequired<rewind_viewer::fbs::Vector2f>(verifier, VT_CENTER, 4) &&
           VerifyField<float>(verifier, VT_RADIUS, 4) &&
           verifier.EndTable();
  }
  CircleT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CircleT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Circle> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CircleT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CircleBuilder {
  typedef Circle Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_color(::flatbuffers::Offset<rewind_viewer::fbs::Color> color) {
    fbb_.AddOffset(Circle::VT_COLOR, color);
  }
  void add_center(const rewind_viewer::fbs::Vector2f *center) {
    fbb_.AddStruct(Circle::VT_CENTER, center);
  }
  void add_radius(float radius) {
    fbb_.AddElement<float>(Circle::VT_RADIUS, radius, 0.0f);
  }
  explicit CircleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Circle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Circle>(end);
    fbb_.Required(o, Circle::VT_COLOR);
    fbb_.Required(o, Circle::VT_CENTER);
    return o;
  }
};

inline ::flatbuffers::Offset<Circle> CreateCircle(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<rewind_viewer::fbs::Color> color = 0,
    const rewind_viewer::fbs::Vector2f *center = nullptr,
    float radius = 0.0f) {
  CircleBuilder builder_(_fbb);
  builder_.add_radius(radius);
  builder_.add_center(center);
  builder_.add_color(color);
  return builder_.Finish();
}

::flatbuffers::Offset<Circle> CreateCircle(::flatbuffers::FlatBufferBuilder &_fbb, const CircleT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RectangleT : public ::flatbuffers::NativeTable {
  typedef Rectangle TableType;
  std::unique_ptr<rewind_viewer::fbs::ColorT> color{};
  std::unique_ptr<rewind_viewer::fbs::Vector2f> position{};
  std::unique_ptr<rewind_viewer::fbs::Vector2f> size{};
  RectangleT() = default;
  RectangleT(const RectangleT &o);
  RectangleT(RectangleT&&) FLATBUFFERS_NOEXCEPT = default;
  RectangleT &operator=(RectangleT o) FLATBUFFERS_NOEXCEPT;
};

struct Rectangle FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RectangleT NativeTableType;
  typedef RectangleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLOR = 4,
    VT_POSITION = 6,
    VT_SIZE = 8
  };
  const rewind_viewer::fbs::Color *color() const {
    return GetPointer<const rewind_viewer::fbs::Color *>(VT_COLOR);
  }
  const rewind_viewer::fbs::Vector2f *position() const {
    return GetStruct<const rewind_viewer::fbs::Vector2f *>(VT_POSITION);
  }
  const rewind_viewer::fbs::Vector2f *size() const {
    return GetStruct<const rewind_viewer::fbs::Vector2f *>(VT_SIZE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_COLOR) &&
           verifier.VerifyTable(color()) &&
           VerifyFieldRequired<rewind_viewer::fbs::Vector2f>(verifier, VT_POSITION, 4) &&
           VerifyFieldRequired<rewind_viewer::fbs::Vector2f>(verifier, VT_SIZE, 4) &&
           verifier.EndTable();
  }
  RectangleT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RectangleT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Rectangle> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RectangleT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RectangleBuilder {
  typedef Rectangle Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_color(::flatbuffers::Offset<rewind_viewer::fbs::Color> color) {
    fbb_.AddOffset(Rectangle::VT_COLOR, color);
  }
  void add_position(const rewind_viewer::fbs::Vector2f *position) {
    fbb_.AddStruct(Rectangle::VT_POSITION, position);
  }
  void add_size(const rewind_viewer::fbs::Vector2f *size) {
    fbb_.AddStruct(Rectangle::VT_SIZE, size);
  }
  explicit RectangleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Rectangle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Rectangle>(end);
    fbb_.Required(o, Rectangle::VT_COLOR);
    fbb_.Required(o, Rectangle::VT_POSITION);
    fbb_.Required(o, Rectangle::VT_SIZE);
    return o;
  }
};

inline ::flatbuffers::Offset<Rectangle> CreateRectangle(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<rewind_viewer::fbs::Color> color = 0,
    const rewind_viewer::fbs::Vector2f *position = nullptr,
    const rewind_viewer::fbs::Vector2f *size = nullptr) {
  RectangleBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_position(position);
  builder_.add_color(color);
  return builder_.Finish();
}

::flatbuffers::Offset<Rectangle> CreateRectangle(::flatbuffers::FlatBufferBuilder &_fbb, const RectangleT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TriangleT : public ::flatbuffers::NativeTable {
  typedef Triangle TableType;
  std::unique_ptr<rewind_viewer::fbs::ColorT> color{};
  std::vector<rewind_viewer::fbs::Vector2f> points{};
  TriangleT() = default;
  TriangleT(const TriangleT &o);
  TriangleT(TriangleT&&) FLATBUFFERS_NOEXCEPT = default;
  TriangleT &operator=(TriangleT o) FLATBUFFERS_NOEXCEPT;
};

struct Triangle FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TriangleT NativeTableType;
  typedef TriangleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLOR = 4,
    VT_POINTS = 6
  };
  const rewind_viewer::fbs::Color *color() const {
    return GetPointer<const rewind_viewer::fbs::Color *>(VT_COLOR);
  }
  const ::flatbuffers::Vector<const rewind_viewer::fbs::Vector2f *> *points() const {
    return GetPointer<const ::flatbuffers::Vector<const rewind_viewer::fbs::Vector2f *> *>(VT_POINTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_COLOR) &&
           verifier.VerifyTable(color()) &&
           VerifyOffsetRequired(verifier, VT_POINTS) &&
           verifier.VerifyVector(points()) &&
           verifier.EndTable();
  }
  TriangleT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TriangleT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Triangle> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TriangleT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TriangleBuilder {
  typedef Triangle Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_color(::flatbuffers::Offset<rewind_viewer::fbs::Color> color) {
    fbb_.AddOffset(Triangle::VT_COLOR, color);
  }
  void add_points(::flatbuffers::Offset<::flatbuffers::Vector<const rewind_viewer::fbs::Vector2f *>> points) {
    fbb_.AddOffset(Triangle::VT_POINTS, points);
  }
  explicit TriangleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Triangle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Triangle>(end);
    fbb_.Required(o, Triangle::VT_COLOR);
    fbb_.Required(o, Triangle::VT_POINTS);
    return o;
  }
};

inline ::flatbuffers::Offset<Triangle> CreateTriangle(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<rewind_viewer::fbs::Color> color = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const rewind_viewer::fbs::Vector2f *>> points = 0) {
  TriangleBuilder builder_(_fbb);
  builder_.add_points(points);
  builder_.add_color(color);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Triangle> CreateTriangleDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<rewind_viewer::fbs::Color> color = 0,
    const std::vector<rewind_viewer::fbs::Vector2f> *points = nullptr) {
  auto points__ = points ? _fbb.CreateVectorOfStructs<rewind_viewer::fbs::Vector2f>(*points) : 0;
  return rewind_viewer::fbs::CreateTriangle(
      _fbb,
      color,
      points__);
}

::flatbuffers::Offset<Triangle> CreateTriangle(::flatbuffers::FlatBufferBuilder &_fbb, const TriangleT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PolylineT : public ::flatbuffers::NativeTable {
  typedef Polyline TableType;
  std::unique_ptr<rewind_viewer::fbs::ColorT> color{};
  std::vector<rewind_viewer::fbs::Vector2f> points{};
  PolylineT() = default;
  PolylineT(const PolylineT &o);
  PolylineT(PolylineT&&) FLATBUFFERS_NOEXCEPT = default;
  PolylineT &operator=(PolylineT o) FLATBUFFERS_NOEXCEPT;
};

struct Polyline FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PolylineT NativeTableType;
  typedef PolylineBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLOR = 4,
    VT_POINTS = 6
  };
  const rewind_viewer::fbs::Color *color() const {
    return GetPointer<const rewind_viewer::fbs::Color *>(VT_COLOR);
  }
  const ::flatbuffers::Vector<const rewind_viewer::fbs::Vector2f *> *points() const {
    return GetPointer<const ::flatbuffers::Vector<const rewind_viewer::fbs::Vector2f *> *>(VT_POINTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_COLOR) &&
           verifier.VerifyTable(color()) &&
           VerifyOffsetRequired(verifier, VT_POINTS) &&
           verifier.VerifyVector(points()) &&
           verifier.EndTable();
  }
  PolylineT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PolylineT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Polyline> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PolylineT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PolylineBuilder {
  typedef Polyline Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_color(::flatbuffers::Offset<rewind_viewer::fbs::Color> color) {
    fbb_.AddOffset(Polyline::VT_COLOR, color);
  }
  void add_points(::flatbuffers::Offset<::flatbuffers::Vector<const rewind_viewer::fbs::Vector2f *>> points) {
    fbb_.AddOffset(Polyline::VT_POINTS, points);
  }
  explicit PolylineBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Polyline> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Polyline>(end);
    fbb_.Required(o, Polyline::VT_COLOR);
    fbb_.Required(o, Polyline::VT_POINTS);
    return o;
  }
};

inline ::flatbuffers::Offset<Polyline> CreatePolyline(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<rewind_viewer::fbs::Color> color = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const rewind_viewer::fbs::Vector2f *>> points = 0) {
  PolylineBuilder builder_(_fbb);
  builder_.add_points(points);
  builder_.add_color(color);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Polyline> CreatePolylineDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<rewind_viewer::fbs::Color> color = 0,
    const std::vector<rewind_viewer::fbs::Vector2f> *points = nullptr) {
  auto points__ = points ? _fbb.CreateVectorOfStructs<rewind_viewer::fbs::Vector2f>(*points) : 0;
  return rewind_viewer::fbs::CreatePolyline(
      _fbb,
      color,
      points__);
}

::flatbuffers::Offset<Polyline> CreatePolyline(::flatbuffers::FlatBufferBuilder &_fbb, const PolylineT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogTextT : public ::flatbuffers::NativeTable {
  typedef LogText TableType;
  std::string text{};
};

struct LogText FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LogTextT NativeTableType;
  typedef LogTextBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEXT = 4
  };
  const ::flatbuffers::String *text() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           verifier.EndTable();
  }
  LogTextT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LogTextT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<LogText> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LogTextT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogTextBuilder {
  typedef LogText Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_text(::flatbuffers::Offset<::flatbuffers::String> text) {
    fbb_.AddOffset(LogText::VT_TEXT, text);
  }
  explicit LogTextBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LogText> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LogText>(end);
    fbb_.Required(o, LogText::VT_TEXT);
    return o;
  }
};

inline ::flatbuffers::Offset<LogText> CreateLogText(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> text = 0) {
  LogTextBuilder builder_(_fbb);
  builder_.add_text(text);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<LogText> CreateLogTextDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *text = nullptr) {
  auto text__ = text ? _fbb.CreateString(text) : 0;
  return rewind_viewer::fbs::CreateLogText(
      _fbb,
      text__);
}

::flatbuffers::Offset<LogText> CreateLogText(::flatbuffers::FlatBufferBuilder &_fbb, const LogTextT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PopupT : public ::flatbuffers::NativeTable {
  typedef Popup TableType;
  std::string text{};
  std::unique_ptr<rewind_viewer::fbs::Vector2f> area_position{};
  std::unique_ptr<rewind_viewer::fbs::Vector2f> area_size{};
  PopupT() = default;
  PopupT(const PopupT &o);
  PopupT(PopupT&&) FLATBUFFERS_NOEXCEPT = default;
  PopupT &operator=(PopupT o) FLATBUFFERS_NOEXCEPT;
};

struct Popup FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PopupT NativeTableType;
  typedef PopupBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEXT = 4,
    VT_AREA_POSITION = 6,
    VT_AREA_SIZE = 8
  };
  const ::flatbuffers::String *text() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXT);
  }
  const rewind_viewer::fbs::Vector2f *area_position() const {
    return GetStruct<const rewind_viewer::fbs::Vector2f *>(VT_AREA_POSITION);
  }
  const rewind_viewer::fbs::Vector2f *area_size() const {
    return GetStruct<const rewind_viewer::fbs::Vector2f *>(VT_AREA_SIZE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           VerifyFieldRequired<rewind_viewer::fbs::Vector2f>(verifier, VT_AREA_POSITION, 4) &&
           VerifyFieldRequired<rewind_viewer::fbs::Vector2f>(verifier, VT_AREA_SIZE, 4) &&
           verifier.EndTable();
  }
  PopupT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PopupT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Popup> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PopupT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PopupBuilder {
  typedef Popup Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_text(::flatbuffers::Offset<::flatbuffers::String> text) {
    fbb_.AddOffset(Popup::VT_TEXT, text);
  }
  void add_area_position(const rewind_viewer::fbs::Vector2f *area_position) {
    fbb_.AddStruct(Popup::VT_AREA_POSITION, area_position);
  }
  void add_area_size(const rewind_viewer::fbs::Vector2f *area_size) {
    fbb_.AddStruct(Popup::VT_AREA_SIZE, area_size);
  }
  explicit PopupBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Popup> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Popup>(end);
    fbb_.Required(o, Popup::VT_TEXT);
    fbb_.Required(o, Popup::VT_AREA_POSITION);
    fbb_.Required(o, Popup::VT_AREA_SIZE);
    return o;
  }
};

inline ::flatbuffers::Offset<Popup> CreatePopup(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> text = 0,
    const rewind_viewer::fbs::Vector2f *area_position = nullptr,
    const rewind_viewer::fbs::Vector2f *area_size = nullptr) {
  PopupBuilder builder_(_fbb);
  builder_.add_area_size(area_size);
  builder_.add_area_position(area_position);
  builder_.add_text(text);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Popup> CreatePopupDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *text = nullptr,
    const rewind_viewer::fbs::Vector2f *area_position = nullptr,
    const rewind_viewer::fbs::Vector2f *area_size = nullptr) {
  auto text__ = text ? _fbb.CreateString(text) : 0;
  return rewind_viewer::fbs::CreatePopup(
      _fbb,
      text__,
      area_position,
      area_size);
}

::flatbuffers::Offset<Popup> CreatePopup(::flatbuffers::FlatBufferBuilder &_fbb, const PopupT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PopupRoundT : public ::flatbuffers::NativeTable {
  typedef PopupRound TableType;
  std::string text{};
  std::unique_ptr<rewind_viewer::fbs::Vector2f> area_center{};
  float area_radius = 0.0f;
  PopupRoundT() = default;
  PopupRoundT(const PopupRoundT &o);
  PopupRoundT(PopupRoundT&&) FLATBUFFERS_NOEXCEPT = default;
  PopupRoundT &operator=(PopupRoundT o) FLATBUFFERS_NOEXCEPT;
};

struct PopupRound FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PopupRoundT NativeTableType;
  typedef PopupRoundBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEXT = 4,
    VT_AREA_CENTER = 6,
    VT_AREA_RADIUS = 8
  };
  const ::flatbuffers::String *text() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXT);
  }
  const rewind_viewer::fbs::Vector2f *area_center() const {
    return GetStruct<const rewind_viewer::fbs::Vector2f *>(VT_AREA_CENTER);
  }
  float area_radius() const {
    return GetField<float>(VT_AREA_RADIUS, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           VerifyFieldRequired<rewind_viewer::fbs::Vector2f>(verifier, VT_AREA_CENTER, 4) &&
           VerifyField<float>(verifier, VT_AREA_RADIUS, 4) &&
           verifier.EndTable();
  }
  PopupRoundT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PopupRoundT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<PopupRound> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PopupRoundT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PopupRoundBuilder {
  typedef PopupRound Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_text(::flatbuffers::Offset<::flatbuffers::String> text) {
    fbb_.AddOffset(PopupRound::VT_TEXT, text);
  }
  void add_area_center(const rewind_viewer::fbs::Vector2f *area_center) {
    fbb_.AddStruct(PopupRound::VT_AREA_CENTER, area_center);
  }
  void add_area_radius(float area_radius) {
    fbb_.AddElement<float>(PopupRound::VT_AREA_RADIUS, area_radius, 0.0f);
  }
  explicit PopupRoundBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PopupRound> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PopupRound>(end);
    fbb_.Required(o, PopupRound::VT_TEXT);
    fbb_.Required(o, PopupRound::VT_AREA_CENTER);
    return o;
  }
};

inline ::flatbuffers::Offset<PopupRound> CreatePopupRound(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> text = 0,
    const rewind_viewer::fbs::Vector2f *area_center = nullptr,
    float area_radius = 0.0f) {
  PopupRoundBuilder builder_(_fbb);
  builder_.add_area_radius(area_radius);
  builder_.add_area_center(area_center);
  builder_.add_text(text);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PopupRound> CreatePopupRoundDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *text = nullptr,
    const rewind_viewer::fbs::Vector2f *area_center = nullptr,
    float area_radius = 0.0f) {
  auto text__ = text ? _fbb.CreateString(text) : 0;
  return rewind_viewer::fbs::CreatePopupRound(
      _fbb,
      text__,
      area_center,
      area_radius);
}

::flatbuffers::Offset<PopupRound> CreatePopupRound(::flatbuffers::FlatBufferBuilder &_fbb, const PopupRoundT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CameraViewT : public ::flatbuffers::NativeTable {
  typedef CameraView TableType;
  std::string name{};
  std::unique_ptr<rewind_viewer::fbs::Vector2f> position{};
  float view_radius = 0.0f;
  CameraViewT() = default;
  CameraViewT(const CameraViewT &o);
  CameraViewT(CameraViewT&&) FLATBUFFERS_NOEXCEPT = default;
  CameraViewT &operator=(CameraViewT o) FLATBUFFERS_NOEXCEPT;
};

struct CameraView FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CameraViewT NativeTableType;
  typedef CameraViewBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_POSITION = 6,
    VT_VIEW_RADIUS = 8
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const rewind_viewer::fbs::Vector2f *position() const {
    return GetStruct<const rewind_viewer::fbs::Vector2f *>(VT_POSITION);
  }
  float view_radius() const {
    return GetField<float>(VT_VIEW_RADIUS, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyFieldRequired<rewind_viewer::fbs::Vector2f>(verifier, VT_POSITION, 4) &&
           VerifyField<float>(verifier, VT_VIEW_RADIUS, 4) &&
           verifier.EndTable();
  }
  CameraViewT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CameraViewT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CameraView> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CameraViewT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CameraViewBuilder {
  typedef CameraView Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(CameraView::VT_NAME, name);
  }
  void add_position(const rewind_viewer::fbs::Vector2f *position) {
    fbb_.AddStruct(CameraView::VT_POSITION, position);
  }
  void add_view_radius(float view_radius) {
    fbb_.AddElement<float>(CameraView::VT_VIEW_RADIUS, view_radius, 0.0f);
  }
  explicit CameraViewBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CameraView> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CameraView>(end);
    fbb_.Required(o, CameraView::VT_NAME);
    fbb_.Required(o, CameraView::VT_POSITION);
    return o;
  }
};

inline ::flatbuffers::Offset<CameraView> CreateCameraView(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    const rewind_viewer::fbs::Vector2f *position = nullptr,
    float view_radius = 0.0f) {
  CameraViewBuilder builder_(_fbb);
  builder_.add_view_radius(view_radius);
  builder_.add_position(position);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CameraView> CreateCameraViewDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const rewind_viewer::fbs::Vector2f *position = nullptr,
    float view_radius = 0.0f) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return rewind_viewer::fbs::CreateCameraView(
      _fbb,
      name__,
      position,
      view_radius);
}

::flatbuffers::Offset<CameraView> CreateCameraView(::flatbuffers::FlatBufferBuilder &_fbb, const CameraViewT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LayerT : public ::flatbuffers::NativeTable {
  typedef Layer TableType;
  uint32_t id = 0;
  bool use_permanent_frame = false;
};

struct Layer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LayerT NativeTableType;
  typedef LayerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_USE_PERMANENT_FRAME = 6
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  bool use_permanent_frame() const {
    return GetField<uint8_t>(VT_USE_PERMANENT_FRAME, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID, 4) &&
           VerifyField<uint8_t>(verifier, VT_USE_PERMANENT_FRAME, 1) &&
           verifier.EndTable();
  }
  LayerT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LayerT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Layer> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LayerT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LayerBuilder {
  typedef Layer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(Layer::VT_ID, id, 0);
  }
  void add_use_permanent_frame(bool use_permanent_frame) {
    fbb_.AddElement<uint8_t>(Layer::VT_USE_PERMANENT_FRAME, static_cast<uint8_t>(use_permanent_frame), 0);
  }
  explicit LayerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Layer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Layer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Layer> CreateLayer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    bool use_permanent_frame = false) {
  LayerBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_use_permanent_frame(use_permanent_frame);
  return builder_.Finish();
}

::flatbuffers::Offset<Layer> CreateLayer(::flatbuffers::FlatBufferBuilder &_fbb, const LayerT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MapT : public ::flatbuffers::NativeTable {
  typedef Map TableType;
  float width = 0.0f;
  float height = 0.0f;
  uint32_t x_grid = 0;
  uint32_t y_grid = 0;
};

struct Map FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MapT NativeTableType;
  typedef MapBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WIDTH = 4,
    VT_HEIGHT = 6,
    VT_X_GRID = 8,
    VT_Y_GRID = 10
  };
  float width() const {
    return GetField<float>(VT_WIDTH, 0.0f);
  }
  float height() const {
    return GetField<float>(VT_HEIGHT, 0.0f);
  }
  uint32_t x_grid() const {
    return GetField<uint32_t>(VT_X_GRID, 0);
  }
  uint32_t y_grid() const {
    return GetField<uint32_t>(VT_Y_GRID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_WIDTH, 4) &&
           VerifyField<float>(verifier, VT_HEIGHT, 4) &&
           VerifyField<uint32_t>(verifier, VT_X_GRID, 4) &&
           VerifyField<uint32_t>(verifier, VT_Y_GRID, 4) &&
           verifier.EndTable();
  }
  MapT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MapT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Map> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MapT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MapBuilder {
  typedef Map Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_width(float width) {
    fbb_.AddElement<float>(Map::VT_WIDTH, width, 0.0f);
  }
  void add_height(float height) {
    fbb_.AddElement<float>(Map::VT_HEIGHT, height, 0.0f);
  }
  void add_x_grid(uint32_t x_grid) {
    fbb_.AddElement<uint32_t>(Map::VT_X_GRID, x_grid, 0);
  }
  void add_y_grid(uint32_t y_grid) {
    fbb_.AddElement<uint32_t>(Map::VT_Y_GRID, y_grid, 0);
  }
  explicit MapBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Map> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Map>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Map> CreateMap(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float width = 0.0f,
    float height = 0.0f,
    uint32_t x_grid = 0,
    uint32_t y_grid = 0) {
  MapBuilder builder_(_fbb);
  builder_.add_y_grid(y_grid);
  builder_.add_x_grid(x_grid);
  builder_.add_height(height);
  builder_.add_width(width);
  return builder_.Finish();
}

::flatbuffers::Offset<Map> CreateMap(::flatbuffers::FlatBufferBuilder &_fbb, const MapT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OptionsT : public ::flatbuffers::NativeTable {
  typedef Options TableType;
  std::unique_ptr<rewind_viewer::fbs::MapT> map{};
  std::unique_ptr<rewind_viewer::fbs::LayerT> layer{};
  OptionsT() = default;
  OptionsT(const OptionsT &o);
  OptionsT(OptionsT&&) FLATBUFFERS_NOEXCEPT = default;
  OptionsT &operator=(OptionsT o) FLATBUFFERS_NOEXCEPT;
};

struct Options FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OptionsT NativeTableType;
  typedef OptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAP = 4,
    VT_LAYER = 6
  };
  const rewind_viewer::fbs::Map *map() const {
    return GetPointer<const rewind_viewer::fbs::Map *>(VT_MAP);
  }
  const rewind_viewer::fbs::Layer *layer() const {
    return GetPointer<const rewind_viewer::fbs::Layer *>(VT_LAYER);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MAP) &&
           verifier.VerifyTable(map()) &&
           VerifyOffset(verifier, VT_LAYER) &&
           verifier.VerifyTable(layer()) &&
           verifier.EndTable();
  }
  OptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Options> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const OptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OptionsBuilder {
  typedef Options Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_map(::flatbuffers::Offset<rewind_viewer::fbs::Map> map) {
    fbb_.AddOffset(Options::VT_MAP, map);
  }
  void add_layer(::flatbuffers::Offset<rewind_viewer::fbs::Layer> layer) {
    fbb_.AddOffset(Options::VT_LAYER, layer);
  }
  explicit OptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Options> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Options>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Options> CreateOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<rewind_viewer::fbs::Map> map = 0,
    ::flatbuffers::Offset<rewind_viewer::fbs::Layer> layer = 0) {
  OptionsBuilder builder_(_fbb);
  builder_.add_layer(layer);
  builder_.add_map(map);
  return builder_.Finish();
}

::flatbuffers::Offset<Options> CreateOptions(::flatbuffers::FlatBufferBuilder &_fbb, const OptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EndFrameT : public ::flatbuffers::NativeTable {
  typedef EndFrame TableType;
};

struct EndFrame FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EndFrameT NativeTableType;
  typedef EndFrameBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  EndFrameT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EndFrameT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<EndFrame> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EndFrameT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EndFrameBuilder {
  typedef EndFrame Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit EndFrameBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EndFrame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EndFrame>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EndFrame> CreateEndFrame(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  EndFrameBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<EndFrame> CreateEndFrame(::flatbuffers::FlatBufferBuilder &_fbb, const EndFrameT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RewindMessageT : public ::flatbuffers::NativeTable {
  typedef RewindMessage TableType;
  rewind_viewer::fbs::CommandUnion command{};
};

struct RewindMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RewindMessageT NativeTableType;
  typedef RewindMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMAND_TYPE = 4,
    VT_COMMAND = 6
  };
  rewind_viewer::fbs::Command command_type() const {
    return static_cast<rewind_viewer::fbs::Command>(GetField<uint8_t>(VT_COMMAND_TYPE, 0));
  }
  const void *command() const {
    return GetPointer<const void *>(VT_COMMAND);
  }
  template<typename T> const T *command_as() const;
  const rewind_viewer::fbs::Circle *command_as_Circle() const {
    return command_type() == rewind_viewer::fbs::Command_Circle ? static_cast<const rewind_viewer::fbs::Circle *>(command()) : nullptr;
  }
  const rewind_viewer::fbs::Rectangle *command_as_Rectangle() const {
    return command_type() == rewind_viewer::fbs::Command_Rectangle ? static_cast<const rewind_viewer::fbs::Rectangle *>(command()) : nullptr;
  }
  const rewind_viewer::fbs::Triangle *command_as_Triangle() const {
    return command_type() == rewind_viewer::fbs::Command_Triangle ? static_cast<const rewind_viewer::fbs::Triangle *>(command()) : nullptr;
  }
  const rewind_viewer::fbs::Polyline *command_as_Polyline() const {
    return command_type() == rewind_viewer::fbs::Command_Polyline ? static_cast<const rewind_viewer::fbs::Polyline *>(command()) : nullptr;
  }
  const rewind_viewer::fbs::LogText *command_as_LogText() const {
    return command_type() == rewind_viewer::fbs::Command_LogText ? static_cast<const rewind_viewer::fbs::LogText *>(command()) : nullptr;
  }
  const rewind_viewer::fbs::Popup *command_as_Popup() const {
    return command_type() == rewind_viewer::fbs::Command_Popup ? static_cast<const rewind_viewer::fbs::Popup *>(command()) : nullptr;
  }
  const rewind_viewer::fbs::PopupRound *command_as_PopupRound() const {
    return command_type() == rewind_viewer::fbs::Command_PopupRound ? static_cast<const rewind_viewer::fbs::PopupRound *>(command()) : nullptr;
  }
  const rewind_viewer::fbs::Options *command_as_Options() const {
    return command_type() == rewind_viewer::fbs::Command_Options ? static_cast<const rewind_viewer::fbs::Options *>(command()) : nullptr;
  }
  const rewind_viewer::fbs::CameraView *command_as_CameraView() const {
    return command_type() == rewind_viewer::fbs::Command_CameraView ? static_cast<const rewind_viewer::fbs::CameraView *>(command()) : nullptr;
  }
  const rewind_viewer::fbs::EndFrame *command_as_EndFrame() const {
    return command_type() == rewind_viewer::fbs::Command_EndFrame ? static_cast<const rewind_viewer::fbs::EndFrame *>(command()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_COMMAND_TYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_COMMAND) &&
           VerifyCommand(verifier, command(), command_type()) &&
           verifier.EndTable();
  }
  RewindMessageT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RewindMessageT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<RewindMessage> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RewindMessageT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const rewind_viewer::fbs::Circle *RewindMessage::command_as<rewind_viewer::fbs::Circle>() const {
  return command_as_Circle();
}

template<> inline const rewind_viewer::fbs::Rectangle *RewindMessage::command_as<rewind_viewer::fbs::Rectangle>() const {
  return command_as_Rectangle();
}

template<> inline const rewind_viewer::fbs::Triangle *RewindMessage::command_as<rewind_viewer::fbs::Triangle>() const {
  return command_as_Triangle();
}

template<> inline const rewind_viewer::fbs::Polyline *RewindMessage::command_as<rewind_viewer::fbs::Polyline>() const {
  return command_as_Polyline();
}

template<> inline const rewind_viewer::fbs::LogText *RewindMessage::command_as<rewind_viewer::fbs::LogText>() const {
  return command_as_LogText();
}

template<> inline const rewind_viewer::fbs::Popup *RewindMessage::command_as<rewind_viewer::fbs::Popup>() const {
  return command_as_Popup();
}

template<> inline const rewind_viewer::fbs::PopupRound *RewindMessage::command_as<rewind_viewer::fbs::PopupRound>() const {
  return command_as_PopupRound();
}

template<> inline const rewind_viewer::fbs::Options *RewindMessage::command_as<rewind_viewer::fbs::Options>() const {
  return command_as_Options();
}

template<> inline const rewind_viewer::fbs::CameraView *RewindMessage::command_as<rewind_viewer::fbs::CameraView>() const {
  return command_as_CameraView();
}

template<> inline const rewind_viewer::fbs::EndFrame *RewindMessage::command_as<rewind_viewer::fbs::EndFrame>() const {
  return command_as_EndFrame();
}

struct RewindMessageBuilder {
  typedef RewindMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_command_type(rewind_viewer::fbs::Command command_type) {
    fbb_.AddElement<uint8_t>(RewindMessage::VT_COMMAND_TYPE, static_cast<uint8_t>(command_type), 0);
  }
  void add_command(::flatbuffers::Offset<void> command) {
    fbb_.AddOffset(RewindMessage::VT_COMMAND, command);
  }
  explicit RewindMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RewindMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RewindMessage>(end);
    fbb_.Required(o, RewindMessage::VT_COMMAND);
    return o;
  }
};

inline ::flatbuffers::Offset<RewindMessage> CreateRewindMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    rewind_viewer::fbs::Command command_type = rewind_viewer::fbs::Command_NONE,
    ::flatbuffers::Offset<void> command = 0) {
  RewindMessageBuilder builder_(_fbb);
  builder_.add_command(command);
  builder_.add_command_type(command_type);
  return builder_.Finish();
}

::flatbuffers::Offset<RewindMessage> CreateRewindMessage(::flatbuffers::FlatBufferBuilder &_fbb, const RewindMessageT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline ColorT *Color::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ColorT>(new ColorT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Color::UnPackTo(ColorT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = value(); _o->value = _e; }
  { auto _e = fill(); _o->fill = _e; }
}

inline ::flatbuffers::Offset<Color> Color::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ColorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateColor(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Color> CreateColor(::flatbuffers::FlatBufferBuilder &_fbb, const ColorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ColorT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _value = _o->value;
  auto _fill = _o->fill;
  return rewind_viewer::fbs::CreateColor(
      _fbb,
      _value,
      _fill);
}

inline CircleT::CircleT(const CircleT &o)
      : color((o.color) ? new rewind_viewer::fbs::ColorT(*o.color) : nullptr),
        center((o.center) ? new rewind_viewer::fbs::Vector2f(*o.center) : nullptr),
        radius(o.radius) {
}

inline CircleT &CircleT::operator=(CircleT o) FLATBUFFERS_NOEXCEPT {
  std::swap(color, o.color);
  std::swap(center, o.center);
  std::swap(radius, o.radius);
  return *this;
}

inline CircleT *Circle::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CircleT>(new CircleT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Circle::UnPackTo(CircleT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = color(); if (_e) { if(_o->color) { _e->UnPackTo(_o->color.get(), _resolver); } else { _o->color = std::unique_ptr<rewind_viewer::fbs::ColorT>(_e->UnPack(_resolver)); } } else if (_o->color) { _o->color.reset(); } }
  { auto _e = center(); if (_e) _o->center = std::unique_ptr<rewind_viewer::fbs::Vector2f>(new rewind_viewer::fbs::Vector2f(*_e)); }
  { auto _e = radius(); _o->radius = _e; }
}

inline ::flatbuffers::Offset<Circle> Circle::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CircleT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCircle(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Circle> CreateCircle(::flatbuffers::FlatBufferBuilder &_fbb, const CircleT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CircleT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _color = _o->color ? CreateColor(_fbb, _o->color.get(), _rehasher) : 0;
  auto _center = _o->center ? _o->center.get() : nullptr;
  auto _radius = _o->radius;
  return rewind_viewer::fbs::CreateCircle(
      _fbb,
      _color,
      _center,
      _radius);
}

inline RectangleT::RectangleT(const RectangleT &o)
      : color((o.color) ? new rewind_viewer::fbs::ColorT(*o.color) : nullptr),
        position((o.position) ? new rewind_viewer::fbs::Vector2f(*o.position) : nullptr),
        size((o.size) ? new rewind_viewer::fbs::Vector2f(*o.size) : nullptr) {
}

inline RectangleT &RectangleT::operator=(RectangleT o) FLATBUFFERS_NOEXCEPT {
  std::swap(color, o.color);
  std::swap(position, o.position);
  std::swap(size, o.size);
  return *this;
}

inline RectangleT *Rectangle::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RectangleT>(new RectangleT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Rectangle::UnPackTo(RectangleT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = color(); if (_e) { if(_o->color) { _e->UnPackTo(_o->color.get(), _resolver); } else { _o->color = std::unique_ptr<rewind_viewer::fbs::ColorT>(_e->UnPack(_resolver)); } } else if (_o->color) { _o->color.reset(); } }
  { auto _e = position(); if (_e) _o->position = std::unique_ptr<rewind_viewer::fbs::Vector2f>(new rewind_viewer::fbs::Vector2f(*_e)); }
  { auto _e = size(); if (_e) _o->size = std::unique_ptr<rewind_viewer::fbs::Vector2f>(new rewind_viewer::fbs::Vector2f(*_e)); }
}

inline ::flatbuffers::Offset<Rectangle> Rectangle::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RectangleT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRectangle(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Rectangle> CreateRectangle(::flatbuffers::FlatBufferBuilder &_fbb, const RectangleT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const RectangleT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _color = _o->color ? CreateColor(_fbb, _o->color.get(), _rehasher) : 0;
  auto _position = _o->position ? _o->position.get() : nullptr;
  auto _size = _o->size ? _o->size.get() : nullptr;
  return rewind_viewer::fbs::CreateRectangle(
      _fbb,
      _color,
      _position,
      _size);
}

inline TriangleT::TriangleT(const TriangleT &o)
      : color((o.color) ? new rewind_viewer::fbs::ColorT(*o.color) : nullptr),
        points(o.points) {
}

inline TriangleT &TriangleT::operator=(TriangleT o) FLATBUFFERS_NOEXCEPT {
  std::swap(color, o.color);
  std::swap(points, o.points);
  return *this;
}

inline TriangleT *Triangle::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TriangleT>(new TriangleT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Triangle::UnPackTo(TriangleT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = color(); if (_e) { if(_o->color) { _e->UnPackTo(_o->color.get(), _resolver); } else { _o->color = std::unique_ptr<rewind_viewer::fbs::ColorT>(_e->UnPack(_resolver)); } } else if (_o->color) { _o->color.reset(); } }
  { auto _e = points(); if (_e) { _o->points.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->points[_i] = *_e->Get(_i); } } else { _o->points.resize(0); } }
}

inline ::flatbuffers::Offset<Triangle> Triangle::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TriangleT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTriangle(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Triangle> CreateTriangle(::flatbuffers::FlatBufferBuilder &_fbb, const TriangleT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TriangleT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _color = _o->color ? CreateColor(_fbb, _o->color.get(), _rehasher) : 0;
  auto _points = _fbb.CreateVectorOfStructs(_o->points);
  return rewind_viewer::fbs::CreateTriangle(
      _fbb,
      _color,
      _points);
}

inline PolylineT::PolylineT(const PolylineT &o)
      : color((o.color) ? new rewind_viewer::fbs::ColorT(*o.color) : nullptr),
        points(o.points) {
}

inline PolylineT &PolylineT::operator=(PolylineT o) FLATBUFFERS_NOEXCEPT {
  std::swap(color, o.color);
  std::swap(points, o.points);
  return *this;
}

inline PolylineT *Polyline::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PolylineT>(new PolylineT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Polyline::UnPackTo(PolylineT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = color(); if (_e) { if(_o->color) { _e->UnPackTo(_o->color.get(), _resolver); } else { _o->color = std::unique_ptr<rewind_viewer::fbs::ColorT>(_e->UnPack(_resolver)); } } else if (_o->color) { _o->color.reset(); } }
  { auto _e = points(); if (_e) { _o->points.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->points[_i] = *_e->Get(_i); } } else { _o->points.resize(0); } }
}

inline ::flatbuffers::Offset<Polyline> Polyline::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PolylineT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePolyline(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Polyline> CreatePolyline(::flatbuffers::FlatBufferBuilder &_fbb, const PolylineT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PolylineT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _color = _o->color ? CreateColor(_fbb, _o->color.get(), _rehasher) : 0;
  auto _points = _fbb.CreateVectorOfStructs(_o->points);
  return rewind_viewer::fbs::CreatePolyline(
      _fbb,
      _color,
      _points);
}

inline LogTextT *LogText::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LogTextT>(new LogTextT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LogText::UnPackTo(LogTextT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = text(); if (_e) _o->text = _e->str(); }
}

inline ::flatbuffers::Offset<LogText> LogText::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LogTextT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLogText(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<LogText> CreateLogText(::flatbuffers::FlatBufferBuilder &_fbb, const LogTextT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const LogTextT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _text = _fbb.CreateString(_o->text);
  return rewind_viewer::fbs::CreateLogText(
      _fbb,
      _text);
}

inline PopupT::PopupT(const PopupT &o)
      : text(o.text),
        area_position((o.area_position) ? new rewind_viewer::fbs::Vector2f(*o.area_position) : nullptr),
        area_size((o.area_size) ? new rewind_viewer::fbs::Vector2f(*o.area_size) : nullptr) {
}

inline PopupT &PopupT::operator=(PopupT o) FLATBUFFERS_NOEXCEPT {
  std::swap(text, o.text);
  std::swap(area_position, o.area_position);
  std::swap(area_size, o.area_size);
  return *this;
}

inline PopupT *Popup::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PopupT>(new PopupT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Popup::UnPackTo(PopupT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = text(); if (_e) _o->text = _e->str(); }
  { auto _e = area_position(); if (_e) _o->area_position = std::unique_ptr<rewind_viewer::fbs::Vector2f>(new rewind_viewer::fbs::Vector2f(*_e)); }
  { auto _e = area_size(); if (_e) _o->area_size = std::unique_ptr<rewind_viewer::fbs::Vector2f>(new rewind_viewer::fbs::Vector2f(*_e)); }
}

inline ::flatbuffers::Offset<Popup> Popup::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PopupT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePopup(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Popup> CreatePopup(::flatbuffers::FlatBufferBuilder &_fbb, const PopupT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PopupT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _text = _fbb.CreateString(_o->text);
  auto _area_position = _o->area_position ? _o->area_position.get() : nullptr;
  auto _area_size = _o->area_size ? _o->area_size.get() : nullptr;
  return rewind_viewer::fbs::CreatePopup(
      _fbb,
      _text,
      _area_position,
      _area_size);
}

inline PopupRoundT::PopupRoundT(const PopupRoundT &o)
      : text(o.text),
        area_center((o.area_center) ? new rewind_viewer::fbs::Vector2f(*o.area_center) : nullptr),
        area_radius(o.area_radius) {
}

inline PopupRoundT &PopupRoundT::operator=(PopupRoundT o) FLATBUFFERS_NOEXCEPT {
  std::swap(text, o.text);
  std::swap(area_center, o.area_center);
  std::swap(area_radius, o.area_radius);
  return *this;
}

inline PopupRoundT *PopupRound::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PopupRoundT>(new PopupRoundT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PopupRound::UnPackTo(PopupRoundT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = text(); if (_e) _o->text = _e->str(); }
  { auto _e = area_center(); if (_e) _o->area_center = std::unique_ptr<rewind_viewer::fbs::Vector2f>(new rewind_viewer::fbs::Vector2f(*_e)); }
  { auto _e = area_radius(); _o->area_radius = _e; }
}

inline ::flatbuffers::Offset<PopupRound> PopupRound::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PopupRoundT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePopupRound(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<PopupRound> CreatePopupRound(::flatbuffers::FlatBufferBuilder &_fbb, const PopupRoundT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PopupRoundT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _text = _fbb.CreateString(_o->text);
  auto _area_center = _o->area_center ? _o->area_center.get() : nullptr;
  auto _area_radius = _o->area_radius;
  return rewind_viewer::fbs::CreatePopupRound(
      _fbb,
      _text,
      _area_center,
      _area_radius);
}

inline CameraViewT::CameraViewT(const CameraViewT &o)
      : name(o.name),
        position((o.position) ? new rewind_viewer::fbs::Vector2f(*o.position) : nullptr),
        view_radius(o.view_radius) {
}

inline CameraViewT &CameraViewT::operator=(CameraViewT o) FLATBUFFERS_NOEXCEPT {
  std::swap(name, o.name);
  std::swap(position, o.position);
  std::swap(view_radius, o.view_radius);
  return *this;
}

inline CameraViewT *CameraView::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CameraViewT>(new CameraViewT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CameraView::UnPackTo(CameraViewT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = position(); if (_e) _o->position = std::unique_ptr<rewind_viewer::fbs::Vector2f>(new rewind_viewer::fbs::Vector2f(*_e)); }
  { auto _e = view_radius(); _o->view_radius = _e; }
}

inline ::flatbuffers::Offset<CameraView> CameraView::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CameraViewT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCameraView(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CameraView> CreateCameraView(::flatbuffers::FlatBufferBuilder &_fbb, const CameraViewT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CameraViewT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _fbb.CreateString(_o->name);
  auto _position = _o->position ? _o->position.get() : nullptr;
  auto _view_radius = _o->view_radius;
  return rewind_viewer::fbs::CreateCameraView(
      _fbb,
      _name,
      _position,
      _view_radius);
}

inline LayerT *Layer::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LayerT>(new LayerT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Layer::UnPackTo(LayerT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = use_permanent_frame(); _o->use_permanent_frame = _e; }
}

inline ::flatbuffers::Offset<Layer> Layer::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LayerT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLayer(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Layer> CreateLayer(::flatbuffers::FlatBufferBuilder &_fbb, const LayerT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const LayerT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _use_permanent_frame = _o->use_permanent_frame;
  return rewind_viewer::fbs::CreateLayer(
      _fbb,
      _id,
      _use_permanent_frame);
}

inline MapT *Map::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MapT>(new MapT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Map::UnPackTo(MapT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = width(); _o->width = _e; }
  { auto _e = height(); _o->height = _e; }
  { auto _e = x_grid(); _o->x_grid = _e; }
  { auto _e = y_grid(); _o->y_grid = _e; }
}

inline ::flatbuffers::Offset<Map> Map::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MapT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMap(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Map> CreateMap(::flatbuffers::FlatBufferBuilder &_fbb, const MapT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const MapT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _width = _o->width;
  auto _height = _o->height;
  auto _x_grid = _o->x_grid;
  auto _y_grid = _o->y_grid;
  return rewind_viewer::fbs::CreateMap(
      _fbb,
      _width,
      _height,
      _x_grid,
      _y_grid);
}

inline OptionsT::OptionsT(const OptionsT &o)
      : map((o.map) ? new rewind_viewer::fbs::MapT(*o.map) : nullptr),
        layer((o.layer) ? new rewind_viewer::fbs::LayerT(*o.layer) : nullptr) {
}

inline OptionsT &OptionsT::operator=(OptionsT o) FLATBUFFERS_NOEXCEPT {
  std::swap(map, o.map);
  std::swap(layer, o.layer);
  return *this;
}

inline OptionsT *Options::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<OptionsT>(new OptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Options::UnPackTo(OptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = map(); if (_e) { if(_o->map) { _e->UnPackTo(_o->map.get(), _resolver); } else { _o->map = std::unique_ptr<rewind_viewer::fbs::MapT>(_e->UnPack(_resolver)); } } else if (_o->map) { _o->map.reset(); } }
  { auto _e = layer(); if (_e) { if(_o->layer) { _e->UnPackTo(_o->layer.get(), _resolver); } else { _o->layer = std::unique_ptr<rewind_viewer::fbs::LayerT>(_e->UnPack(_resolver)); } } else if (_o->layer) { _o->layer.reset(); } }
}

inline ::flatbuffers::Offset<Options> Options::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const OptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Options> CreateOptions(::flatbuffers::FlatBufferBuilder &_fbb, const OptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const OptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _map = _o->map ? CreateMap(_fbb, _o->map.get(), _rehasher) : 0;
  auto _layer = _o->layer ? CreateLayer(_fbb, _o->layer.get(), _rehasher) : 0;
  return rewind_viewer::fbs::CreateOptions(
      _fbb,
      _map,
      _layer);
}

inline EndFrameT *EndFrame::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<EndFrameT>(new EndFrameT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void EndFrame::UnPackTo(EndFrameT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<EndFrame> EndFrame::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EndFrameT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEndFrame(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<EndFrame> CreateEndFrame(::flatbuffers::FlatBufferBuilder &_fbb, const EndFrameT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const EndFrameT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return rewind_viewer::fbs::CreateEndFrame(
      _fbb);
}

inline RewindMessageT *RewindMessage::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RewindMessageT>(new RewindMessageT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RewindMessage::UnPackTo(RewindMessageT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = command_type(); _o->command.type = _e; }
  { auto _e = command(); if (_e) _o->command.value = rewind_viewer::fbs::CommandUnion::UnPack(_e, command_type(), _resolver); }
}

inline ::flatbuffers::Offset<RewindMessage> RewindMessage::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RewindMessageT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRewindMessage(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<RewindMessage> CreateRewindMessage(::flatbuffers::FlatBufferBuilder &_fbb, const RewindMessageT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const RewindMessageT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _command_type = _o->command.type;
  auto _command = _o->command.Pack(_fbb);
  return rewind_viewer::fbs::CreateRewindMessage(
      _fbb,
      _command_type,
      _command);
}

inline bool VerifyCommand(::flatbuffers::Verifier &verifier, const void *obj, Command type) {
  switch (type) {
    case Command_NONE: {
      return true;
    }
    case Command_Circle: {
      auto ptr = reinterpret_cast<const rewind_viewer::fbs::Circle *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_Rectangle: {
      auto ptr = reinterpret_cast<const rewind_viewer::fbs::Rectangle *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_Triangle: {
      auto ptr = reinterpret_cast<const rewind_viewer::fbs::Triangle *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_Polyline: {
      auto ptr = reinterpret_cast<const rewind_viewer::fbs::Polyline *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_LogText: {
      auto ptr = reinterpret_cast<const rewind_viewer::fbs::LogText *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_Popup: {
      auto ptr = reinterpret_cast<const rewind_viewer::fbs::Popup *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_PopupRound: {
      auto ptr = reinterpret_cast<const rewind_viewer::fbs::PopupRound *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_Options: {
      auto ptr = reinterpret_cast<const rewind_viewer::fbs::Options *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_CameraView: {
      auto ptr = reinterpret_cast<const rewind_viewer::fbs::CameraView *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_EndFrame: {
      auto ptr = reinterpret_cast<const rewind_viewer::fbs::EndFrame *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyCommandVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyCommand(
        verifier,  values->Get(i), types->GetEnum<Command>(i))) {
      return false;
    }
  }
  return true;
}

inline void *CommandUnion::UnPack(const void *obj, Command type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case Command_Circle: {
      auto ptr = reinterpret_cast<const rewind_viewer::fbs::Circle *>(obj);
      return ptr->UnPack(resolver);
    }
    case Command_Rectangle: {
      auto ptr = reinterpret_cast<const rewind_viewer::fbs::Rectangle *>(obj);
      return ptr->UnPack(resolver);
    }
    case Command_Triangle: {
      auto ptr = reinterpret_cast<const rewind_viewer::fbs::Triangle *>(obj);
      return ptr->UnPack(resolver);
    }
    case Command_Polyline: {
      auto ptr = reinterpret_cast<const rewind_viewer::fbs::Polyline *>(obj);
      return ptr->UnPack(resolver);
    }
    case Command_LogText: {
      auto ptr = reinterpret_cast<const rewind_viewer::fbs::LogText *>(obj);
      return ptr->UnPack(resolver);
    }
    case Command_Popup: {
      auto ptr = reinterpret_cast<const rewind_viewer::fbs::Popup *>(obj);
      return ptr->UnPack(resolver);
    }
    case Command_PopupRound: {
      auto ptr = reinterpret_cast<const rewind_viewer::fbs::PopupRound *>(obj);
      return ptr->UnPack(resolver);
    }
    case Command_Options: {
      auto ptr = reinterpret_cast<const rewind_viewer::fbs::Options *>(obj);
      return ptr->UnPack(resolver);
    }
    case Command_CameraView: {
      auto ptr = reinterpret_cast<const rewind_viewer::fbs::CameraView *>(obj);
      return ptr->UnPack(resolver);
    }
    case Command_EndFrame: {
      auto ptr = reinterpret_cast<const rewind_viewer::fbs::EndFrame *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> CommandUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case Command_Circle: {
      auto ptr = reinterpret_cast<const rewind_viewer::fbs::CircleT *>(value);
      return CreateCircle(_fbb, ptr, _rehasher).Union();
    }
    case Command_Rectangle: {
      auto ptr = reinterpret_cast<const rewind_viewer::fbs::RectangleT *>(value);
      return CreateRectangle(_fbb, ptr, _rehasher).Union();
    }
    case Command_Triangle: {
      auto ptr = reinterpret_cast<const rewind_viewer::fbs::TriangleT *>(value);
      return CreateTriangle(_fbb, ptr, _rehasher).Union();
    }
    case Command_Polyline: {
      auto ptr = reinterpret_cast<const rewind_viewer::fbs::PolylineT *>(value);
      return CreatePolyline(_fbb, ptr, _rehasher).Union();
    }
    case Command_LogText: {
      auto ptr = reinterpret_cast<const rewind_viewer::fbs::LogTextT *>(value);
      return CreateLogText(_fbb, ptr, _rehasher).Union();
    }
    case Command_Popup: {
      auto ptr = reinterpret_cast<const rewind_viewer::fbs::PopupT *>(value);
      return CreatePopup(_fbb, ptr, _rehasher).Union();
    }
    case Command_PopupRound: {
      auto ptr = reinterpret_cast<const rewind_viewer::fbs::PopupRoundT *>(value);
      return CreatePopupRound(_fbb, ptr, _rehasher).Union();
    }
    case Command_Options: {
      auto ptr = reinterpret_cast<const rewind_viewer::fbs::OptionsT *>(value);
      return CreateOptions(_fbb, ptr, _rehasher).Union();
    }
    case Command_CameraView: {
      auto ptr = reinterpret_cast<const rewind_viewer::fbs::CameraViewT *>(value);
      return CreateCameraView(_fbb, ptr, _rehasher).Union();
    }
    case Command_EndFrame: {
      auto ptr = reinterpret_cast<const rewind_viewer::fbs::EndFrameT *>(value);
      return CreateEndFrame(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline CommandUnion::CommandUnion(const CommandUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case Command_Circle: {
      value = new rewind_viewer::fbs::CircleT(*reinterpret_cast<rewind_viewer::fbs::CircleT *>(u.value));
      break;
    }
    case Command_Rectangle: {
      value = new rewind_viewer::fbs::RectangleT(*reinterpret_cast<rewind_viewer::fbs::RectangleT *>(u.value));
      break;
    }
    case Command_Triangle: {
      value = new rewind_viewer::fbs::TriangleT(*reinterpret_cast<rewind_viewer::fbs::TriangleT *>(u.value));
      break;
    }
    case Command_Polyline: {
      value = new rewind_viewer::fbs::PolylineT(*reinterpret_cast<rewind_viewer::fbs::PolylineT *>(u.value));
      break;
    }
    case Command_LogText: {
      value = new rewind_viewer::fbs::LogTextT(*reinterpret_cast<rewind_viewer::fbs::LogTextT *>(u.value));
      break;
    }
    case Command_Popup: {
      value = new rewind_viewer::fbs::PopupT(*reinterpret_cast<rewind_viewer::fbs::PopupT *>(u.value));
      break;
    }
    case Command_PopupRound: {
      value = new rewind_viewer::fbs::PopupRoundT(*reinterpret_cast<rewind_viewer::fbs::PopupRoundT *>(u.value));
      break;
    }
    case Command_Options: {
      value = new rewind_viewer::fbs::OptionsT(*reinterpret_cast<rewind_viewer::fbs::OptionsT *>(u.value));
      break;
    }
    case Command_CameraView: {
      value = new rewind_viewer::fbs::CameraViewT(*reinterpret_cast<rewind_viewer::fbs::CameraViewT *>(u.value));
      break;
    }
    case Command_EndFrame: {
      value = new rewind_viewer::fbs::EndFrameT(*reinterpret_cast<rewind_viewer::fbs::EndFrameT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void CommandUnion::Reset() {
  switch (type) {
    case Command_Circle: {
      auto ptr = reinterpret_cast<rewind_viewer::fbs::CircleT *>(value);
      delete ptr;
      break;
    }
    case Command_Rectangle: {
      auto ptr = reinterpret_cast<rewind_viewer::fbs::RectangleT *>(value);
      delete ptr;
      break;
    }
    case Command_Triangle: {
      auto ptr = reinterpret_cast<rewind_viewer::fbs::TriangleT *>(value);
      delete ptr;
      break;
    }
    case Command_Polyline: {
      auto ptr = reinterpret_cast<rewind_viewer::fbs::PolylineT *>(value);
      delete ptr;
      break;
    }
    case Command_LogText: {
      auto ptr = reinterpret_cast<rewind_viewer::fbs::LogTextT *>(value);
      delete ptr;
      break;
    }
    case Command_Popup: {
      auto ptr = reinterpret_cast<rewind_viewer::fbs::PopupT *>(value);
      delete ptr;
      break;
    }
    case Command_PopupRound: {
      auto ptr = reinterpret_cast<rewind_viewer::fbs::PopupRoundT *>(value);
      delete ptr;
      break;
    }
    case Command_Options: {
      auto ptr = reinterpret_cast<rewind_viewer::fbs::OptionsT *>(value);
      delete ptr;
      break;
    }
    case Command_CameraView: {
      auto ptr = reinterpret_cast<rewind_viewer::fbs::CameraViewT *>(value);
      delete ptr;
      break;
    }
    case Command_EndFrame: {
      auto ptr = reinterpret_cast<rewind_viewer::fbs::EndFrameT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = Command_NONE;
}

inline const rewind_viewer::fbs::RewindMessage *GetRewindMessage(const void *buf) {
  return ::flatbuffers::GetRoot<rewind_viewer::fbs::RewindMessage>(buf);
}

inline const rewind_viewer::fbs::RewindMessage *GetSizePrefixedRewindMessage(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<rewind_viewer::fbs::RewindMessage>(buf);
}

inline bool VerifyRewindMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<rewind_viewer::fbs::RewindMessage>(nullptr);
}

inline bool VerifySizePrefixedRewindMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<rewind_viewer::fbs::RewindMessage>(nullptr);
}

inline void FinishRewindMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<rewind_viewer::fbs::RewindMessage> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedRewindMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<rewind_viewer::fbs::RewindMessage> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<rewind_viewer::fbs::RewindMessageT> UnPackRewindMessage(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<rewind_viewer::fbs::RewindMessageT>(GetRewindMessage(buf)->UnPack(res));
}

inline std::unique_ptr<rewind_viewer::fbs::RewindMessageT> UnPackSizePrefixedRewindMessage(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<rewind_viewer::fbs::RewindMessageT>(GetSizePrefixedRewindMessage(buf)->UnPack(res));
}

}  // namespace fbs
}  // namespace rewind_viewer

#endif  // FLATBUFFERS_GENERATED_REWINDMESSAGE_REWIND_VIEWER_FBS_H_
