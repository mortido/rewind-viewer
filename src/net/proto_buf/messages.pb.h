// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: net/proto_buf/messages.proto
// Protobuf C++ Version: 4.25.0

#ifndef GOOGLE_PROTOBUF_INCLUDED_net_2fproto_5fbuf_2fmessages_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_net_2fproto_5fbuf_2fmessages_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025000 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_net_2fproto_5fbuf_2fmessages_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_net_2fproto_5fbuf_2fmessages_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_net_2fproto_5fbuf_2fmessages_2eproto;
namespace net {
namespace messages {
class Circle;
struct CircleDefaultTypeInternal;
extern CircleDefaultTypeInternal _Circle_default_instance_;
class Color;
struct ColorDefaultTypeInternal;
extern ColorDefaultTypeInternal _Color_default_instance_;
class DrawMessage;
struct DrawMessageDefaultTypeInternal;
extern DrawMessageDefaultTypeInternal _DrawMessage_default_instance_;
class EndFrame;
struct EndFrameDefaultTypeInternal;
extern EndFrameDefaultTypeInternal _EndFrame_default_instance_;
class LogText;
struct LogTextDefaultTypeInternal;
extern LogTextDefaultTypeInternal _LogText_default_instance_;
class Map;
struct MapDefaultTypeInternal;
extern MapDefaultTypeInternal _Map_default_instance_;
class Options;
struct OptionsDefaultTypeInternal;
extern OptionsDefaultTypeInternal _Options_default_instance_;
class Polyline;
struct PolylineDefaultTypeInternal;
extern PolylineDefaultTypeInternal _Polyline_default_instance_;
class Popup;
struct PopupDefaultTypeInternal;
extern PopupDefaultTypeInternal _Popup_default_instance_;
class PopupRound;
struct PopupRoundDefaultTypeInternal;
extern PopupRoundDefaultTypeInternal _PopupRound_default_instance_;
class Rectangle;
struct RectangleDefaultTypeInternal;
extern RectangleDefaultTypeInternal _Rectangle_default_instance_;
class Triangle;
struct TriangleDefaultTypeInternal;
extern TriangleDefaultTypeInternal _Triangle_default_instance_;
class Vector2f;
struct Vector2fDefaultTypeInternal;
extern Vector2fDefaultTypeInternal _Vector2f_default_instance_;
}  // namespace messages
}  // namespace net
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace net {
namespace messages {

// ===================================================================


// -------------------------------------------------------------------

class Vector2f final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:net.messages.Vector2f) */ {
 public:
  inline Vector2f() : Vector2f(nullptr) {}
  ~Vector2f() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Vector2f(::google::protobuf::internal::ConstantInitialized);

  inline Vector2f(const Vector2f& from)
      : Vector2f(nullptr, from) {}
  Vector2f(Vector2f&& from) noexcept
    : Vector2f() {
    *this = ::std::move(from);
  }

  inline Vector2f& operator=(const Vector2f& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector2f& operator=(Vector2f&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vector2f& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vector2f* internal_default_instance() {
    return reinterpret_cast<const Vector2f*>(
               &_Vector2f_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Vector2f& a, Vector2f& b) {
    a.Swap(&b);
  }
  inline void Swap(Vector2f* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector2f* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vector2f* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vector2f>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Vector2f& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Vector2f& from) {
    Vector2f::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Vector2f* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "net.messages.Vector2f";
  }
  protected:
  explicit Vector2f(::google::protobuf::Arena* arena);
  Vector2f(::google::protobuf::Arena* arena, const Vector2f& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // float x = 1;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // float y = 2;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // @@protoc_insertion_point(class_scope:net.messages.Vector2f)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    float x_;
    float y_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_2fproto_5fbuf_2fmessages_2eproto;
};// -------------------------------------------------------------------

class Options final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:net.messages.Options) */ {
 public:
  inline Options() : Options(nullptr) {}
  ~Options() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Options(::google::protobuf::internal::ConstantInitialized);

  inline Options(const Options& from)
      : Options(nullptr, from) {}
  Options(Options&& from) noexcept
    : Options() {
    *this = ::std::move(from);
  }

  inline Options& operator=(const Options& from) {
    CopyFrom(from);
    return *this;
  }
  inline Options& operator=(Options&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Options& default_instance() {
    return *internal_default_instance();
  }
  static inline const Options* internal_default_instance() {
    return reinterpret_cast<const Options*>(
               &_Options_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Options& a, Options& b) {
    a.Swap(&b);
  }
  inline void Swap(Options* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Options* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Options* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Options>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Options& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Options& from) {
    Options::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Options* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "net.messages.Options";
  }
  protected:
  explicit Options(::google::protobuf::Arena* arena);
  Options(::google::protobuf::Arena* arena, const Options& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsePermanentFrameFieldNumber = 1,
    kLayerFieldNumber = 2,
  };
  // optional bool use_permanent_frame = 1;
  bool has_use_permanent_frame() const;
  void clear_use_permanent_frame() ;
  bool use_permanent_frame() const;
  void set_use_permanent_frame(bool value);

  private:
  bool _internal_use_permanent_frame() const;
  void _internal_set_use_permanent_frame(bool value);

  public:
  // optional uint32 layer = 2;
  bool has_layer() const;
  void clear_layer() ;
  ::uint32_t layer() const;
  void set_layer(::uint32_t value);

  private:
  ::uint32_t _internal_layer() const;
  void _internal_set_layer(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:net.messages.Options)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    bool use_permanent_frame_;
    ::uint32_t layer_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_2fproto_5fbuf_2fmessages_2eproto;
};// -------------------------------------------------------------------

class Map final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:net.messages.Map) */ {
 public:
  inline Map() : Map(nullptr) {}
  ~Map() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Map(::google::protobuf::internal::ConstantInitialized);

  inline Map(const Map& from)
      : Map(nullptr, from) {}
  Map(Map&& from) noexcept
    : Map() {
    *this = ::std::move(from);
  }

  inline Map& operator=(const Map& from) {
    CopyFrom(from);
    return *this;
  }
  inline Map& operator=(Map&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Map& default_instance() {
    return *internal_default_instance();
  }
  static inline const Map* internal_default_instance() {
    return reinterpret_cast<const Map*>(
               &_Map_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Map& a, Map& b) {
    a.Swap(&b);
  }
  inline void Swap(Map* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Map* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Map* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Map>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Map& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Map& from) {
    Map::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Map* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "net.messages.Map";
  }
  protected:
  explicit Map(::google::protobuf::Arena* arena);
  Map(::google::protobuf::Arena* arena, const Map& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
    kXGridFieldNumber = 3,
    kYGridFieldNumber = 4,
  };
  // float width = 1;
  void clear_width() ;
  float width() const;
  void set_width(float value);

  private:
  float _internal_width() const;
  void _internal_set_width(float value);

  public:
  // float height = 2;
  void clear_height() ;
  float height() const;
  void set_height(float value);

  private:
  float _internal_height() const;
  void _internal_set_height(float value);

  public:
  // uint32 x_grid = 3;
  void clear_x_grid() ;
  ::uint32_t x_grid() const;
  void set_x_grid(::uint32_t value);

  private:
  ::uint32_t _internal_x_grid() const;
  void _internal_set_x_grid(::uint32_t value);

  public:
  // uint32 y_grid = 4;
  void clear_y_grid() ;
  ::uint32_t y_grid() const;
  void set_y_grid(::uint32_t value);

  private:
  ::uint32_t _internal_y_grid() const;
  void _internal_set_y_grid(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:net.messages.Map)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    float width_;
    float height_;
    ::uint32_t x_grid_;
    ::uint32_t y_grid_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_2fproto_5fbuf_2fmessages_2eproto;
};// -------------------------------------------------------------------

class LogText final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:net.messages.LogText) */ {
 public:
  inline LogText() : LogText(nullptr) {}
  ~LogText() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LogText(::google::protobuf::internal::ConstantInitialized);

  inline LogText(const LogText& from)
      : LogText(nullptr, from) {}
  LogText(LogText&& from) noexcept
    : LogText() {
    *this = ::std::move(from);
  }

  inline LogText& operator=(const LogText& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogText& operator=(LogText&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogText& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogText* internal_default_instance() {
    return reinterpret_cast<const LogText*>(
               &_LogText_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(LogText& a, LogText& b) {
    a.Swap(&b);
  }
  inline void Swap(LogText* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogText* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogText* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogText>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LogText& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const LogText& from) {
    LogText::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LogText* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "net.messages.LogText";
  }
  protected:
  explicit LogText(::google::protobuf::Arena* arena);
  LogText(::google::protobuf::Arena* arena, const LogText& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
  };
  // string text = 1;
  void clear_text() ;
  const std::string& text() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_text(Arg_&& arg, Args_... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* value);

  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(
      const std::string& value);
  std::string* _internal_mutable_text();

  public:
  // @@protoc_insertion_point(class_scope:net.messages.LogText)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      33, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr text_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_2fproto_5fbuf_2fmessages_2eproto;
};// -------------------------------------------------------------------

class EndFrame final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:net.messages.EndFrame) */ {
 public:
  inline EndFrame() : EndFrame(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EndFrame(::google::protobuf::internal::ConstantInitialized);

  inline EndFrame(const EndFrame& from)
      : EndFrame(nullptr, from) {}
  EndFrame(EndFrame&& from) noexcept
    : EndFrame() {
    *this = ::std::move(from);
  }

  inline EndFrame& operator=(const EndFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline EndFrame& operator=(EndFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EndFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const EndFrame* internal_default_instance() {
    return reinterpret_cast<const EndFrame*>(
               &_EndFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(EndFrame& a, EndFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(EndFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EndFrame* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EndFrame* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EndFrame>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const EndFrame& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const EndFrame& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "net.messages.EndFrame";
  }
  protected:
  explicit EndFrame(::google::protobuf::Arena* arena);
  EndFrame(::google::protobuf::Arena* arena, const EndFrame& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:net.messages.EndFrame)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_net_2fproto_5fbuf_2fmessages_2eproto;
};// -------------------------------------------------------------------

class Color final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:net.messages.Color) */ {
 public:
  inline Color() : Color(nullptr) {}
  ~Color() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Color(::google::protobuf::internal::ConstantInitialized);

  inline Color(const Color& from)
      : Color(nullptr, from) {}
  Color(Color&& from) noexcept
    : Color() {
    *this = ::std::move(from);
  }

  inline Color& operator=(const Color& from) {
    CopyFrom(from);
    return *this;
  }
  inline Color& operator=(Color&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Color& default_instance() {
    return *internal_default_instance();
  }
  static inline const Color* internal_default_instance() {
    return reinterpret_cast<const Color*>(
               &_Color_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Color& a, Color& b) {
    a.Swap(&b);
  }
  inline void Swap(Color* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Color* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Color* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Color>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Color& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Color& from) {
    Color::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Color* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "net.messages.Color";
  }
  protected:
  explicit Color(::google::protobuf::Arena* arena);
  Color(::google::protobuf::Arena* arena, const Color& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
    kFillFieldNumber = 2,
  };
  // uint32 value = 1;
  void clear_value() ;
  ::uint32_t value() const;
  void set_value(::uint32_t value);

  private:
  ::uint32_t _internal_value() const;
  void _internal_set_value(::uint32_t value);

  public:
  // bool fill = 2;
  void clear_fill() ;
  bool fill() const;
  void set_fill(bool value);

  private:
  bool _internal_fill() const;
  void _internal_set_fill(bool value);

  public:
  // @@protoc_insertion_point(class_scope:net.messages.Color)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint32_t value_;
    bool fill_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_2fproto_5fbuf_2fmessages_2eproto;
};// -------------------------------------------------------------------

class Triangle final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:net.messages.Triangle) */ {
 public:
  inline Triangle() : Triangle(nullptr) {}
  ~Triangle() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Triangle(::google::protobuf::internal::ConstantInitialized);

  inline Triangle(const Triangle& from)
      : Triangle(nullptr, from) {}
  Triangle(Triangle&& from) noexcept
    : Triangle() {
    *this = ::std::move(from);
  }

  inline Triangle& operator=(const Triangle& from) {
    CopyFrom(from);
    return *this;
  }
  inline Triangle& operator=(Triangle&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Triangle& default_instance() {
    return *internal_default_instance();
  }
  static inline const Triangle* internal_default_instance() {
    return reinterpret_cast<const Triangle*>(
               &_Triangle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Triangle& a, Triangle& b) {
    a.Swap(&b);
  }
  inline void Swap(Triangle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Triangle* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Triangle* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Triangle>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Triangle& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Triangle& from) {
    Triangle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Triangle* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "net.messages.Triangle";
  }
  protected:
  explicit Triangle(::google::protobuf::Arena* arena);
  Triangle(::google::protobuf::Arena* arena, const Triangle& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointsFieldNumber = 2,
    kColorFieldNumber = 1,
  };
  // repeated .net.messages.Vector2f points = 2;
  int points_size() const;
  private:
  int _internal_points_size() const;

  public:
  void clear_points() ;
  ::net::messages::Vector2f* mutable_points(int index);
  ::google::protobuf::RepeatedPtrField< ::net::messages::Vector2f >*
      mutable_points();
  private:
  const ::google::protobuf::RepeatedPtrField<::net::messages::Vector2f>& _internal_points() const;
  ::google::protobuf::RepeatedPtrField<::net::messages::Vector2f>* _internal_mutable_points();
  public:
  const ::net::messages::Vector2f& points(int index) const;
  ::net::messages::Vector2f* add_points();
  const ::google::protobuf::RepeatedPtrField< ::net::messages::Vector2f >&
      points() const;
  // .net.messages.Color color = 1;
  bool has_color() const;
  void clear_color() ;
  const ::net::messages::Color& color() const;
  PROTOBUF_NODISCARD ::net::messages::Color* release_color();
  ::net::messages::Color* mutable_color();
  void set_allocated_color(::net::messages::Color* value);
  void unsafe_arena_set_allocated_color(::net::messages::Color* value);
  ::net::messages::Color* unsafe_arena_release_color();

  private:
  const ::net::messages::Color& _internal_color() const;
  ::net::messages::Color* _internal_mutable_color();

  public:
  // @@protoc_insertion_point(class_scope:net.messages.Triangle)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::net::messages::Vector2f > points_;
    ::net::messages::Color* color_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_2fproto_5fbuf_2fmessages_2eproto;
};// -------------------------------------------------------------------

class Rectangle final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:net.messages.Rectangle) */ {
 public:
  inline Rectangle() : Rectangle(nullptr) {}
  ~Rectangle() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Rectangle(::google::protobuf::internal::ConstantInitialized);

  inline Rectangle(const Rectangle& from)
      : Rectangle(nullptr, from) {}
  Rectangle(Rectangle&& from) noexcept
    : Rectangle() {
    *this = ::std::move(from);
  }

  inline Rectangle& operator=(const Rectangle& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rectangle& operator=(Rectangle&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rectangle& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rectangle* internal_default_instance() {
    return reinterpret_cast<const Rectangle*>(
               &_Rectangle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Rectangle& a, Rectangle& b) {
    a.Swap(&b);
  }
  inline void Swap(Rectangle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rectangle* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rectangle* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rectangle>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Rectangle& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Rectangle& from) {
    Rectangle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Rectangle* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "net.messages.Rectangle";
  }
  protected:
  explicit Rectangle(::google::protobuf::Arena* arena);
  Rectangle(::google::protobuf::Arena* arena, const Rectangle& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 1,
    kTopLeftFieldNumber = 2,
    kBottomRightFieldNumber = 3,
  };
  // .net.messages.Color color = 1;
  bool has_color() const;
  void clear_color() ;
  const ::net::messages::Color& color() const;
  PROTOBUF_NODISCARD ::net::messages::Color* release_color();
  ::net::messages::Color* mutable_color();
  void set_allocated_color(::net::messages::Color* value);
  void unsafe_arena_set_allocated_color(::net::messages::Color* value);
  ::net::messages::Color* unsafe_arena_release_color();

  private:
  const ::net::messages::Color& _internal_color() const;
  ::net::messages::Color* _internal_mutable_color();

  public:
  // .net.messages.Vector2f top_left = 2;
  bool has_top_left() const;
  void clear_top_left() ;
  const ::net::messages::Vector2f& top_left() const;
  PROTOBUF_NODISCARD ::net::messages::Vector2f* release_top_left();
  ::net::messages::Vector2f* mutable_top_left();
  void set_allocated_top_left(::net::messages::Vector2f* value);
  void unsafe_arena_set_allocated_top_left(::net::messages::Vector2f* value);
  ::net::messages::Vector2f* unsafe_arena_release_top_left();

  private:
  const ::net::messages::Vector2f& _internal_top_left() const;
  ::net::messages::Vector2f* _internal_mutable_top_left();

  public:
  // .net.messages.Vector2f bottom_right = 3;
  bool has_bottom_right() const;
  void clear_bottom_right() ;
  const ::net::messages::Vector2f& bottom_right() const;
  PROTOBUF_NODISCARD ::net::messages::Vector2f* release_bottom_right();
  ::net::messages::Vector2f* mutable_bottom_right();
  void set_allocated_bottom_right(::net::messages::Vector2f* value);
  void unsafe_arena_set_allocated_bottom_right(::net::messages::Vector2f* value);
  ::net::messages::Vector2f* unsafe_arena_release_bottom_right();

  private:
  const ::net::messages::Vector2f& _internal_bottom_right() const;
  ::net::messages::Vector2f* _internal_mutable_bottom_right();

  public:
  // @@protoc_insertion_point(class_scope:net.messages.Rectangle)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::net::messages::Color* color_;
    ::net::messages::Vector2f* top_left_;
    ::net::messages::Vector2f* bottom_right_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_2fproto_5fbuf_2fmessages_2eproto;
};// -------------------------------------------------------------------

class PopupRound final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:net.messages.PopupRound) */ {
 public:
  inline PopupRound() : PopupRound(nullptr) {}
  ~PopupRound() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PopupRound(::google::protobuf::internal::ConstantInitialized);

  inline PopupRound(const PopupRound& from)
      : PopupRound(nullptr, from) {}
  PopupRound(PopupRound&& from) noexcept
    : PopupRound() {
    *this = ::std::move(from);
  }

  inline PopupRound& operator=(const PopupRound& from) {
    CopyFrom(from);
    return *this;
  }
  inline PopupRound& operator=(PopupRound&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PopupRound& default_instance() {
    return *internal_default_instance();
  }
  static inline const PopupRound* internal_default_instance() {
    return reinterpret_cast<const PopupRound*>(
               &_PopupRound_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PopupRound& a, PopupRound& b) {
    a.Swap(&b);
  }
  inline void Swap(PopupRound* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PopupRound* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PopupRound* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PopupRound>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PopupRound& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PopupRound& from) {
    PopupRound::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PopupRound* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "net.messages.PopupRound";
  }
  protected:
  explicit PopupRound(::google::protobuf::Arena* arena);
  PopupRound(::google::protobuf::Arena* arena, const PopupRound& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
    kCenterFieldNumber = 2,
    kRadiusFieldNumber = 3,
  };
  // string text = 1;
  void clear_text() ;
  const std::string& text() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_text(Arg_&& arg, Args_... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* value);

  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(
      const std::string& value);
  std::string* _internal_mutable_text();

  public:
  // .net.messages.Vector2f center = 2;
  bool has_center() const;
  void clear_center() ;
  const ::net::messages::Vector2f& center() const;
  PROTOBUF_NODISCARD ::net::messages::Vector2f* release_center();
  ::net::messages::Vector2f* mutable_center();
  void set_allocated_center(::net::messages::Vector2f* value);
  void unsafe_arena_set_allocated_center(::net::messages::Vector2f* value);
  ::net::messages::Vector2f* unsafe_arena_release_center();

  private:
  const ::net::messages::Vector2f& _internal_center() const;
  ::net::messages::Vector2f* _internal_mutable_center();

  public:
  // float radius = 3;
  void clear_radius() ;
  float radius() const;
  void set_radius(float value);

  private:
  float _internal_radius() const;
  void _internal_set_radius(float value);

  public:
  // @@protoc_insertion_point(class_scope:net.messages.PopupRound)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      36, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr text_;
    ::net::messages::Vector2f* center_;
    float radius_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_2fproto_5fbuf_2fmessages_2eproto;
};// -------------------------------------------------------------------

class Popup final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:net.messages.Popup) */ {
 public:
  inline Popup() : Popup(nullptr) {}
  ~Popup() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Popup(::google::protobuf::internal::ConstantInitialized);

  inline Popup(const Popup& from)
      : Popup(nullptr, from) {}
  Popup(Popup&& from) noexcept
    : Popup() {
    *this = ::std::move(from);
  }

  inline Popup& operator=(const Popup& from) {
    CopyFrom(from);
    return *this;
  }
  inline Popup& operator=(Popup&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Popup& default_instance() {
    return *internal_default_instance();
  }
  static inline const Popup* internal_default_instance() {
    return reinterpret_cast<const Popup*>(
               &_Popup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Popup& a, Popup& b) {
    a.Swap(&b);
  }
  inline void Swap(Popup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Popup* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Popup* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Popup>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Popup& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Popup& from) {
    Popup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Popup* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "net.messages.Popup";
  }
  protected:
  explicit Popup(::google::protobuf::Arena* arena);
  Popup(::google::protobuf::Arena* arena, const Popup& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
    kPositionFieldNumber = 2,
    kWidthFieldNumber = 3,
    kHeightFieldNumber = 4,
  };
  // string text = 1;
  void clear_text() ;
  const std::string& text() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_text(Arg_&& arg, Args_... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* value);

  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(
      const std::string& value);
  std::string* _internal_mutable_text();

  public:
  // .net.messages.Vector2f position = 2;
  bool has_position() const;
  void clear_position() ;
  const ::net::messages::Vector2f& position() const;
  PROTOBUF_NODISCARD ::net::messages::Vector2f* release_position();
  ::net::messages::Vector2f* mutable_position();
  void set_allocated_position(::net::messages::Vector2f* value);
  void unsafe_arena_set_allocated_position(::net::messages::Vector2f* value);
  ::net::messages::Vector2f* unsafe_arena_release_position();

  private:
  const ::net::messages::Vector2f& _internal_position() const;
  ::net::messages::Vector2f* _internal_mutable_position();

  public:
  // float width = 3;
  void clear_width() ;
  float width() const;
  void set_width(float value);

  private:
  float _internal_width() const;
  void _internal_set_width(float value);

  public:
  // float height = 4;
  void clear_height() ;
  float height() const;
  void set_height(float value);

  private:
  float _internal_height() const;
  void _internal_set_height(float value);

  public:
  // @@protoc_insertion_point(class_scope:net.messages.Popup)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      31, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr text_;
    ::net::messages::Vector2f* position_;
    float width_;
    float height_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_2fproto_5fbuf_2fmessages_2eproto;
};// -------------------------------------------------------------------

class Polyline final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:net.messages.Polyline) */ {
 public:
  inline Polyline() : Polyline(nullptr) {}
  ~Polyline() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Polyline(::google::protobuf::internal::ConstantInitialized);

  inline Polyline(const Polyline& from)
      : Polyline(nullptr, from) {}
  Polyline(Polyline&& from) noexcept
    : Polyline() {
    *this = ::std::move(from);
  }

  inline Polyline& operator=(const Polyline& from) {
    CopyFrom(from);
    return *this;
  }
  inline Polyline& operator=(Polyline&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Polyline& default_instance() {
    return *internal_default_instance();
  }
  static inline const Polyline* internal_default_instance() {
    return reinterpret_cast<const Polyline*>(
               &_Polyline_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Polyline& a, Polyline& b) {
    a.Swap(&b);
  }
  inline void Swap(Polyline* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Polyline* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Polyline* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Polyline>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Polyline& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Polyline& from) {
    Polyline::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Polyline* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "net.messages.Polyline";
  }
  protected:
  explicit Polyline(::google::protobuf::Arena* arena);
  Polyline(::google::protobuf::Arena* arena, const Polyline& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointsFieldNumber = 2,
    kColorFieldNumber = 1,
  };
  // repeated .net.messages.Vector2f points = 2;
  int points_size() const;
  private:
  int _internal_points_size() const;

  public:
  void clear_points() ;
  ::net::messages::Vector2f* mutable_points(int index);
  ::google::protobuf::RepeatedPtrField< ::net::messages::Vector2f >*
      mutable_points();
  private:
  const ::google::protobuf::RepeatedPtrField<::net::messages::Vector2f>& _internal_points() const;
  ::google::protobuf::RepeatedPtrField<::net::messages::Vector2f>* _internal_mutable_points();
  public:
  const ::net::messages::Vector2f& points(int index) const;
  ::net::messages::Vector2f* add_points();
  const ::google::protobuf::RepeatedPtrField< ::net::messages::Vector2f >&
      points() const;
  // .net.messages.Color color = 1;
  bool has_color() const;
  void clear_color() ;
  const ::net::messages::Color& color() const;
  PROTOBUF_NODISCARD ::net::messages::Color* release_color();
  ::net::messages::Color* mutable_color();
  void set_allocated_color(::net::messages::Color* value);
  void unsafe_arena_set_allocated_color(::net::messages::Color* value);
  ::net::messages::Color* unsafe_arena_release_color();

  private:
  const ::net::messages::Color& _internal_color() const;
  ::net::messages::Color* _internal_mutable_color();

  public:
  // @@protoc_insertion_point(class_scope:net.messages.Polyline)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::net::messages::Vector2f > points_;
    ::net::messages::Color* color_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_2fproto_5fbuf_2fmessages_2eproto;
};// -------------------------------------------------------------------

class Circle final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:net.messages.Circle) */ {
 public:
  inline Circle() : Circle(nullptr) {}
  ~Circle() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Circle(::google::protobuf::internal::ConstantInitialized);

  inline Circle(const Circle& from)
      : Circle(nullptr, from) {}
  Circle(Circle&& from) noexcept
    : Circle() {
    *this = ::std::move(from);
  }

  inline Circle& operator=(const Circle& from) {
    CopyFrom(from);
    return *this;
  }
  inline Circle& operator=(Circle&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Circle& default_instance() {
    return *internal_default_instance();
  }
  static inline const Circle* internal_default_instance() {
    return reinterpret_cast<const Circle*>(
               &_Circle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Circle& a, Circle& b) {
    a.Swap(&b);
  }
  inline void Swap(Circle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Circle* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Circle* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Circle>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Circle& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Circle& from) {
    Circle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Circle* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "net.messages.Circle";
  }
  protected:
  explicit Circle(::google::protobuf::Arena* arena);
  Circle(::google::protobuf::Arena* arena, const Circle& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 1,
    kCenterFieldNumber = 2,
    kRadiusFieldNumber = 3,
  };
  // .net.messages.Color color = 1;
  bool has_color() const;
  void clear_color() ;
  const ::net::messages::Color& color() const;
  PROTOBUF_NODISCARD ::net::messages::Color* release_color();
  ::net::messages::Color* mutable_color();
  void set_allocated_color(::net::messages::Color* value);
  void unsafe_arena_set_allocated_color(::net::messages::Color* value);
  ::net::messages::Color* unsafe_arena_release_color();

  private:
  const ::net::messages::Color& _internal_color() const;
  ::net::messages::Color* _internal_mutable_color();

  public:
  // .net.messages.Vector2f center = 2;
  bool has_center() const;
  void clear_center() ;
  const ::net::messages::Vector2f& center() const;
  PROTOBUF_NODISCARD ::net::messages::Vector2f* release_center();
  ::net::messages::Vector2f* mutable_center();
  void set_allocated_center(::net::messages::Vector2f* value);
  void unsafe_arena_set_allocated_center(::net::messages::Vector2f* value);
  ::net::messages::Vector2f* unsafe_arena_release_center();

  private:
  const ::net::messages::Vector2f& _internal_center() const;
  ::net::messages::Vector2f* _internal_mutable_center();

  public:
  // float radius = 3;
  void clear_radius() ;
  float radius() const;
  void set_radius(float value);

  private:
  float _internal_radius() const;
  void _internal_set_radius(float value);

  public:
  // @@protoc_insertion_point(class_scope:net.messages.Circle)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::net::messages::Color* color_;
    ::net::messages::Vector2f* center_;
    float radius_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_2fproto_5fbuf_2fmessages_2eproto;
};// -------------------------------------------------------------------

class DrawMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:net.messages.DrawMessage) */ {
 public:
  inline DrawMessage() : DrawMessage(nullptr) {}
  ~DrawMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DrawMessage(::google::protobuf::internal::ConstantInitialized);

  inline DrawMessage(const DrawMessage& from)
      : DrawMessage(nullptr, from) {}
  DrawMessage(DrawMessage&& from) noexcept
    : DrawMessage() {
    *this = ::std::move(from);
  }

  inline DrawMessage& operator=(const DrawMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline DrawMessage& operator=(DrawMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DrawMessage& default_instance() {
    return *internal_default_instance();
  }
  enum CommandCase {
    kCircle = 1,
    kRectangle = 2,
    kTriangle = 3,
    kPolyline = 4,
    kLogText = 5,
    kPopup = 6,
    kPopupRound = 7,
    kOptions = 8,
    kMap = 9,
    kEndFrame = 10,
    COMMAND_NOT_SET = 0,
  };

  static inline const DrawMessage* internal_default_instance() {
    return reinterpret_cast<const DrawMessage*>(
               &_DrawMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DrawMessage& a, DrawMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(DrawMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DrawMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DrawMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DrawMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DrawMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DrawMessage& from) {
    DrawMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DrawMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "net.messages.DrawMessage";
  }
  protected:
  explicit DrawMessage(::google::protobuf::Arena* arena);
  DrawMessage(::google::protobuf::Arena* arena, const DrawMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCircleFieldNumber = 1,
    kRectangleFieldNumber = 2,
    kTriangleFieldNumber = 3,
    kPolylineFieldNumber = 4,
    kLogTextFieldNumber = 5,
    kPopupFieldNumber = 6,
    kPopupRoundFieldNumber = 7,
    kOptionsFieldNumber = 8,
    kMapFieldNumber = 9,
    kEndFrameFieldNumber = 10,
  };
  // .net.messages.Circle circle = 1;
  bool has_circle() const;
  private:
  bool _internal_has_circle() const;

  public:
  void clear_circle() ;
  const ::net::messages::Circle& circle() const;
  PROTOBUF_NODISCARD ::net::messages::Circle* release_circle();
  ::net::messages::Circle* mutable_circle();
  void set_allocated_circle(::net::messages::Circle* value);
  void unsafe_arena_set_allocated_circle(::net::messages::Circle* value);
  ::net::messages::Circle* unsafe_arena_release_circle();

  private:
  const ::net::messages::Circle& _internal_circle() const;
  ::net::messages::Circle* _internal_mutable_circle();

  public:
  // .net.messages.Rectangle rectangle = 2;
  bool has_rectangle() const;
  private:
  bool _internal_has_rectangle() const;

  public:
  void clear_rectangle() ;
  const ::net::messages::Rectangle& rectangle() const;
  PROTOBUF_NODISCARD ::net::messages::Rectangle* release_rectangle();
  ::net::messages::Rectangle* mutable_rectangle();
  void set_allocated_rectangle(::net::messages::Rectangle* value);
  void unsafe_arena_set_allocated_rectangle(::net::messages::Rectangle* value);
  ::net::messages::Rectangle* unsafe_arena_release_rectangle();

  private:
  const ::net::messages::Rectangle& _internal_rectangle() const;
  ::net::messages::Rectangle* _internal_mutable_rectangle();

  public:
  // .net.messages.Triangle triangle = 3;
  bool has_triangle() const;
  private:
  bool _internal_has_triangle() const;

  public:
  void clear_triangle() ;
  const ::net::messages::Triangle& triangle() const;
  PROTOBUF_NODISCARD ::net::messages::Triangle* release_triangle();
  ::net::messages::Triangle* mutable_triangle();
  void set_allocated_triangle(::net::messages::Triangle* value);
  void unsafe_arena_set_allocated_triangle(::net::messages::Triangle* value);
  ::net::messages::Triangle* unsafe_arena_release_triangle();

  private:
  const ::net::messages::Triangle& _internal_triangle() const;
  ::net::messages::Triangle* _internal_mutable_triangle();

  public:
  // .net.messages.Polyline polyline = 4;
  bool has_polyline() const;
  private:
  bool _internal_has_polyline() const;

  public:
  void clear_polyline() ;
  const ::net::messages::Polyline& polyline() const;
  PROTOBUF_NODISCARD ::net::messages::Polyline* release_polyline();
  ::net::messages::Polyline* mutable_polyline();
  void set_allocated_polyline(::net::messages::Polyline* value);
  void unsafe_arena_set_allocated_polyline(::net::messages::Polyline* value);
  ::net::messages::Polyline* unsafe_arena_release_polyline();

  private:
  const ::net::messages::Polyline& _internal_polyline() const;
  ::net::messages::Polyline* _internal_mutable_polyline();

  public:
  // .net.messages.LogText log_text = 5;
  bool has_log_text() const;
  private:
  bool _internal_has_log_text() const;

  public:
  void clear_log_text() ;
  const ::net::messages::LogText& log_text() const;
  PROTOBUF_NODISCARD ::net::messages::LogText* release_log_text();
  ::net::messages::LogText* mutable_log_text();
  void set_allocated_log_text(::net::messages::LogText* value);
  void unsafe_arena_set_allocated_log_text(::net::messages::LogText* value);
  ::net::messages::LogText* unsafe_arena_release_log_text();

  private:
  const ::net::messages::LogText& _internal_log_text() const;
  ::net::messages::LogText* _internal_mutable_log_text();

  public:
  // .net.messages.Popup popup = 6;
  bool has_popup() const;
  private:
  bool _internal_has_popup() const;

  public:
  void clear_popup() ;
  const ::net::messages::Popup& popup() const;
  PROTOBUF_NODISCARD ::net::messages::Popup* release_popup();
  ::net::messages::Popup* mutable_popup();
  void set_allocated_popup(::net::messages::Popup* value);
  void unsafe_arena_set_allocated_popup(::net::messages::Popup* value);
  ::net::messages::Popup* unsafe_arena_release_popup();

  private:
  const ::net::messages::Popup& _internal_popup() const;
  ::net::messages::Popup* _internal_mutable_popup();

  public:
  // .net.messages.PopupRound popup_round = 7;
  bool has_popup_round() const;
  private:
  bool _internal_has_popup_round() const;

  public:
  void clear_popup_round() ;
  const ::net::messages::PopupRound& popup_round() const;
  PROTOBUF_NODISCARD ::net::messages::PopupRound* release_popup_round();
  ::net::messages::PopupRound* mutable_popup_round();
  void set_allocated_popup_round(::net::messages::PopupRound* value);
  void unsafe_arena_set_allocated_popup_round(::net::messages::PopupRound* value);
  ::net::messages::PopupRound* unsafe_arena_release_popup_round();

  private:
  const ::net::messages::PopupRound& _internal_popup_round() const;
  ::net::messages::PopupRound* _internal_mutable_popup_round();

  public:
  // .net.messages.Options options = 8;
  bool has_options() const;
  private:
  bool _internal_has_options() const;

  public:
  void clear_options() ;
  const ::net::messages::Options& options() const;
  PROTOBUF_NODISCARD ::net::messages::Options* release_options();
  ::net::messages::Options* mutable_options();
  void set_allocated_options(::net::messages::Options* value);
  void unsafe_arena_set_allocated_options(::net::messages::Options* value);
  ::net::messages::Options* unsafe_arena_release_options();

  private:
  const ::net::messages::Options& _internal_options() const;
  ::net::messages::Options* _internal_mutable_options();

  public:
  // .net.messages.Map map = 9;
  bool has_map() const;
  private:
  bool _internal_has_map() const;

  public:
  void clear_map() ;
  const ::net::messages::Map& map() const;
  PROTOBUF_NODISCARD ::net::messages::Map* release_map();
  ::net::messages::Map* mutable_map();
  void set_allocated_map(::net::messages::Map* value);
  void unsafe_arena_set_allocated_map(::net::messages::Map* value);
  ::net::messages::Map* unsafe_arena_release_map();

  private:
  const ::net::messages::Map& _internal_map() const;
  ::net::messages::Map* _internal_mutable_map();

  public:
  // .net.messages.EndFrame end_frame = 10;
  bool has_end_frame() const;
  private:
  bool _internal_has_end_frame() const;

  public:
  void clear_end_frame() ;
  const ::net::messages::EndFrame& end_frame() const;
  PROTOBUF_NODISCARD ::net::messages::EndFrame* release_end_frame();
  ::net::messages::EndFrame* mutable_end_frame();
  void set_allocated_end_frame(::net::messages::EndFrame* value);
  void unsafe_arena_set_allocated_end_frame(::net::messages::EndFrame* value);
  ::net::messages::EndFrame* unsafe_arena_release_end_frame();

  private:
  const ::net::messages::EndFrame& _internal_end_frame() const;
  ::net::messages::EndFrame* _internal_mutable_end_frame();

  public:
  void clear_command();
  CommandCase command_case() const;
  // @@protoc_insertion_point(class_scope:net.messages.DrawMessage)
 private:
  class _Internal;
  void set_has_circle();
  void set_has_rectangle();
  void set_has_triangle();
  void set_has_polyline();
  void set_has_log_text();
  void set_has_popup();
  void set_has_popup_round();
  void set_has_options();
  void set_has_map();
  void set_has_end_frame();

  inline bool has_command() const;
  inline void clear_has_command();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 10, 10,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union CommandUnion {
      constexpr CommandUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::net::messages::Circle* circle_;
      ::net::messages::Rectangle* rectangle_;
      ::net::messages::Triangle* triangle_;
      ::net::messages::Polyline* polyline_;
      ::net::messages::LogText* log_text_;
      ::net::messages::Popup* popup_;
      ::net::messages::PopupRound* popup_round_;
      ::net::messages::Options* options_;
      ::net::messages::Map* map_;
      ::net::messages::EndFrame* end_frame_;
    } command_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_2fproto_5fbuf_2fmessages_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Vector2f

// float x = 1;
inline void Vector2f::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = 0;
}
inline float Vector2f::x() const {
  // @@protoc_insertion_point(field_get:net.messages.Vector2f.x)
  return _internal_x();
}
inline void Vector2f::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:net.messages.Vector2f.x)
}
inline float Vector2f::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void Vector2f::_internal_set_x(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x_ = value;
}

// float y = 2;
inline void Vector2f::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y_ = 0;
}
inline float Vector2f::y() const {
  // @@protoc_insertion_point(field_get:net.messages.Vector2f.y)
  return _internal_y();
}
inline void Vector2f::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:net.messages.Vector2f.y)
}
inline float Vector2f::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void Vector2f::_internal_set_y(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.y_ = value;
}

// -------------------------------------------------------------------

// Color

// uint32 value = 1;
inline void Color::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_ = 0u;
}
inline ::uint32_t Color::value() const {
  // @@protoc_insertion_point(field_get:net.messages.Color.value)
  return _internal_value();
}
inline void Color::set_value(::uint32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:net.messages.Color.value)
}
inline ::uint32_t Color::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void Color::_internal_set_value(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_ = value;
}

// bool fill = 2;
inline void Color::clear_fill() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fill_ = false;
}
inline bool Color::fill() const {
  // @@protoc_insertion_point(field_get:net.messages.Color.fill)
  return _internal_fill();
}
inline void Color::set_fill(bool value) {
  _internal_set_fill(value);
  // @@protoc_insertion_point(field_set:net.messages.Color.fill)
}
inline bool Color::_internal_fill() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fill_;
}
inline void Color::_internal_set_fill(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.fill_ = value;
}

// -------------------------------------------------------------------

// Circle

// .net.messages.Color color = 1;
inline bool Circle::has_color() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.color_ != nullptr);
  return value;
}
inline void Circle::clear_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.color_ != nullptr) _impl_.color_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::net::messages::Color& Circle::_internal_color() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::net::messages::Color* p = _impl_.color_;
  return p != nullptr ? *p : reinterpret_cast<const ::net::messages::Color&>(::net::messages::_Color_default_instance_);
}
inline const ::net::messages::Color& Circle::color() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:net.messages.Circle.color)
  return _internal_color();
}
inline void Circle::unsafe_arena_set_allocated_color(::net::messages::Color* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.color_);
  }
  _impl_.color_ = reinterpret_cast<::net::messages::Color*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:net.messages.Circle.color)
}
inline ::net::messages::Color* Circle::release_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::net::messages::Color* released = _impl_.color_;
  _impl_.color_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::net::messages::Color* Circle::unsafe_arena_release_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:net.messages.Circle.color)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::net::messages::Color* temp = _impl_.color_;
  _impl_.color_ = nullptr;
  return temp;
}
inline ::net::messages::Color* Circle::_internal_mutable_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.color_ == nullptr) {
    auto* p = CreateMaybeMessage<::net::messages::Color>(GetArena());
    _impl_.color_ = reinterpret_cast<::net::messages::Color*>(p);
  }
  return _impl_.color_;
}
inline ::net::messages::Color* Circle::mutable_color() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::net::messages::Color* _msg = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:net.messages.Circle.color)
  return _msg;
}
inline void Circle::set_allocated_color(::net::messages::Color* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::net::messages::Color*>(_impl_.color_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::net::messages::Color*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.color_ = reinterpret_cast<::net::messages::Color*>(value);
  // @@protoc_insertion_point(field_set_allocated:net.messages.Circle.color)
}

// .net.messages.Vector2f center = 2;
inline bool Circle::has_center() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.center_ != nullptr);
  return value;
}
inline void Circle::clear_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.center_ != nullptr) _impl_.center_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::net::messages::Vector2f& Circle::_internal_center() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::net::messages::Vector2f* p = _impl_.center_;
  return p != nullptr ? *p : reinterpret_cast<const ::net::messages::Vector2f&>(::net::messages::_Vector2f_default_instance_);
}
inline const ::net::messages::Vector2f& Circle::center() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:net.messages.Circle.center)
  return _internal_center();
}
inline void Circle::unsafe_arena_set_allocated_center(::net::messages::Vector2f* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.center_);
  }
  _impl_.center_ = reinterpret_cast<::net::messages::Vector2f*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:net.messages.Circle.center)
}
inline ::net::messages::Vector2f* Circle::release_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::net::messages::Vector2f* released = _impl_.center_;
  _impl_.center_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::net::messages::Vector2f* Circle::unsafe_arena_release_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:net.messages.Circle.center)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::net::messages::Vector2f* temp = _impl_.center_;
  _impl_.center_ = nullptr;
  return temp;
}
inline ::net::messages::Vector2f* Circle::_internal_mutable_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.center_ == nullptr) {
    auto* p = CreateMaybeMessage<::net::messages::Vector2f>(GetArena());
    _impl_.center_ = reinterpret_cast<::net::messages::Vector2f*>(p);
  }
  return _impl_.center_;
}
inline ::net::messages::Vector2f* Circle::mutable_center() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::net::messages::Vector2f* _msg = _internal_mutable_center();
  // @@protoc_insertion_point(field_mutable:net.messages.Circle.center)
  return _msg;
}
inline void Circle::set_allocated_center(::net::messages::Vector2f* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::net::messages::Vector2f*>(_impl_.center_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::net::messages::Vector2f*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.center_ = reinterpret_cast<::net::messages::Vector2f*>(value);
  // @@protoc_insertion_point(field_set_allocated:net.messages.Circle.center)
}

// float radius = 3;
inline void Circle::clear_radius() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.radius_ = 0;
}
inline float Circle::radius() const {
  // @@protoc_insertion_point(field_get:net.messages.Circle.radius)
  return _internal_radius();
}
inline void Circle::set_radius(float value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:net.messages.Circle.radius)
}
inline float Circle::_internal_radius() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.radius_;
}
inline void Circle::_internal_set_radius(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.radius_ = value;
}

// -------------------------------------------------------------------

// Rectangle

// .net.messages.Color color = 1;
inline bool Rectangle::has_color() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.color_ != nullptr);
  return value;
}
inline void Rectangle::clear_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.color_ != nullptr) _impl_.color_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::net::messages::Color& Rectangle::_internal_color() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::net::messages::Color* p = _impl_.color_;
  return p != nullptr ? *p : reinterpret_cast<const ::net::messages::Color&>(::net::messages::_Color_default_instance_);
}
inline const ::net::messages::Color& Rectangle::color() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:net.messages.Rectangle.color)
  return _internal_color();
}
inline void Rectangle::unsafe_arena_set_allocated_color(::net::messages::Color* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.color_);
  }
  _impl_.color_ = reinterpret_cast<::net::messages::Color*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:net.messages.Rectangle.color)
}
inline ::net::messages::Color* Rectangle::release_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::net::messages::Color* released = _impl_.color_;
  _impl_.color_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::net::messages::Color* Rectangle::unsafe_arena_release_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:net.messages.Rectangle.color)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::net::messages::Color* temp = _impl_.color_;
  _impl_.color_ = nullptr;
  return temp;
}
inline ::net::messages::Color* Rectangle::_internal_mutable_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.color_ == nullptr) {
    auto* p = CreateMaybeMessage<::net::messages::Color>(GetArena());
    _impl_.color_ = reinterpret_cast<::net::messages::Color*>(p);
  }
  return _impl_.color_;
}
inline ::net::messages::Color* Rectangle::mutable_color() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::net::messages::Color* _msg = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:net.messages.Rectangle.color)
  return _msg;
}
inline void Rectangle::set_allocated_color(::net::messages::Color* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::net::messages::Color*>(_impl_.color_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::net::messages::Color*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.color_ = reinterpret_cast<::net::messages::Color*>(value);
  // @@protoc_insertion_point(field_set_allocated:net.messages.Rectangle.color)
}

// .net.messages.Vector2f top_left = 2;
inline bool Rectangle::has_top_left() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.top_left_ != nullptr);
  return value;
}
inline void Rectangle::clear_top_left() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.top_left_ != nullptr) _impl_.top_left_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::net::messages::Vector2f& Rectangle::_internal_top_left() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::net::messages::Vector2f* p = _impl_.top_left_;
  return p != nullptr ? *p : reinterpret_cast<const ::net::messages::Vector2f&>(::net::messages::_Vector2f_default_instance_);
}
inline const ::net::messages::Vector2f& Rectangle::top_left() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:net.messages.Rectangle.top_left)
  return _internal_top_left();
}
inline void Rectangle::unsafe_arena_set_allocated_top_left(::net::messages::Vector2f* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.top_left_);
  }
  _impl_.top_left_ = reinterpret_cast<::net::messages::Vector2f*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:net.messages.Rectangle.top_left)
}
inline ::net::messages::Vector2f* Rectangle::release_top_left() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::net::messages::Vector2f* released = _impl_.top_left_;
  _impl_.top_left_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::net::messages::Vector2f* Rectangle::unsafe_arena_release_top_left() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:net.messages.Rectangle.top_left)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::net::messages::Vector2f* temp = _impl_.top_left_;
  _impl_.top_left_ = nullptr;
  return temp;
}
inline ::net::messages::Vector2f* Rectangle::_internal_mutable_top_left() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.top_left_ == nullptr) {
    auto* p = CreateMaybeMessage<::net::messages::Vector2f>(GetArena());
    _impl_.top_left_ = reinterpret_cast<::net::messages::Vector2f*>(p);
  }
  return _impl_.top_left_;
}
inline ::net::messages::Vector2f* Rectangle::mutable_top_left() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::net::messages::Vector2f* _msg = _internal_mutable_top_left();
  // @@protoc_insertion_point(field_mutable:net.messages.Rectangle.top_left)
  return _msg;
}
inline void Rectangle::set_allocated_top_left(::net::messages::Vector2f* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::net::messages::Vector2f*>(_impl_.top_left_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::net::messages::Vector2f*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.top_left_ = reinterpret_cast<::net::messages::Vector2f*>(value);
  // @@protoc_insertion_point(field_set_allocated:net.messages.Rectangle.top_left)
}

// .net.messages.Vector2f bottom_right = 3;
inline bool Rectangle::has_bottom_right() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.bottom_right_ != nullptr);
  return value;
}
inline void Rectangle::clear_bottom_right() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.bottom_right_ != nullptr) _impl_.bottom_right_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::net::messages::Vector2f& Rectangle::_internal_bottom_right() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::net::messages::Vector2f* p = _impl_.bottom_right_;
  return p != nullptr ? *p : reinterpret_cast<const ::net::messages::Vector2f&>(::net::messages::_Vector2f_default_instance_);
}
inline const ::net::messages::Vector2f& Rectangle::bottom_right() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:net.messages.Rectangle.bottom_right)
  return _internal_bottom_right();
}
inline void Rectangle::unsafe_arena_set_allocated_bottom_right(::net::messages::Vector2f* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.bottom_right_);
  }
  _impl_.bottom_right_ = reinterpret_cast<::net::messages::Vector2f*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:net.messages.Rectangle.bottom_right)
}
inline ::net::messages::Vector2f* Rectangle::release_bottom_right() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::net::messages::Vector2f* released = _impl_.bottom_right_;
  _impl_.bottom_right_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::net::messages::Vector2f* Rectangle::unsafe_arena_release_bottom_right() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:net.messages.Rectangle.bottom_right)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::net::messages::Vector2f* temp = _impl_.bottom_right_;
  _impl_.bottom_right_ = nullptr;
  return temp;
}
inline ::net::messages::Vector2f* Rectangle::_internal_mutable_bottom_right() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.bottom_right_ == nullptr) {
    auto* p = CreateMaybeMessage<::net::messages::Vector2f>(GetArena());
    _impl_.bottom_right_ = reinterpret_cast<::net::messages::Vector2f*>(p);
  }
  return _impl_.bottom_right_;
}
inline ::net::messages::Vector2f* Rectangle::mutable_bottom_right() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::net::messages::Vector2f* _msg = _internal_mutable_bottom_right();
  // @@protoc_insertion_point(field_mutable:net.messages.Rectangle.bottom_right)
  return _msg;
}
inline void Rectangle::set_allocated_bottom_right(::net::messages::Vector2f* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::net::messages::Vector2f*>(_impl_.bottom_right_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::net::messages::Vector2f*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.bottom_right_ = reinterpret_cast<::net::messages::Vector2f*>(value);
  // @@protoc_insertion_point(field_set_allocated:net.messages.Rectangle.bottom_right)
}

// -------------------------------------------------------------------

// Triangle

// .net.messages.Color color = 1;
inline bool Triangle::has_color() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.color_ != nullptr);
  return value;
}
inline void Triangle::clear_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.color_ != nullptr) _impl_.color_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::net::messages::Color& Triangle::_internal_color() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::net::messages::Color* p = _impl_.color_;
  return p != nullptr ? *p : reinterpret_cast<const ::net::messages::Color&>(::net::messages::_Color_default_instance_);
}
inline const ::net::messages::Color& Triangle::color() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:net.messages.Triangle.color)
  return _internal_color();
}
inline void Triangle::unsafe_arena_set_allocated_color(::net::messages::Color* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.color_);
  }
  _impl_.color_ = reinterpret_cast<::net::messages::Color*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:net.messages.Triangle.color)
}
inline ::net::messages::Color* Triangle::release_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::net::messages::Color* released = _impl_.color_;
  _impl_.color_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::net::messages::Color* Triangle::unsafe_arena_release_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:net.messages.Triangle.color)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::net::messages::Color* temp = _impl_.color_;
  _impl_.color_ = nullptr;
  return temp;
}
inline ::net::messages::Color* Triangle::_internal_mutable_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.color_ == nullptr) {
    auto* p = CreateMaybeMessage<::net::messages::Color>(GetArena());
    _impl_.color_ = reinterpret_cast<::net::messages::Color*>(p);
  }
  return _impl_.color_;
}
inline ::net::messages::Color* Triangle::mutable_color() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::net::messages::Color* _msg = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:net.messages.Triangle.color)
  return _msg;
}
inline void Triangle::set_allocated_color(::net::messages::Color* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::net::messages::Color*>(_impl_.color_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::net::messages::Color*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.color_ = reinterpret_cast<::net::messages::Color*>(value);
  // @@protoc_insertion_point(field_set_allocated:net.messages.Triangle.color)
}

// repeated .net.messages.Vector2f points = 2;
inline int Triangle::_internal_points_size() const {
  return _internal_points().size();
}
inline int Triangle::points_size() const {
  return _internal_points_size();
}
inline void Triangle::clear_points() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.points_.Clear();
}
inline ::net::messages::Vector2f* Triangle::mutable_points(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:net.messages.Triangle.points)
  return _internal_mutable_points()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::net::messages::Vector2f>* Triangle::mutable_points()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:net.messages.Triangle.points)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_points();
}
inline const ::net::messages::Vector2f& Triangle::points(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:net.messages.Triangle.points)
  return _internal_points().Get(index);
}
inline ::net::messages::Vector2f* Triangle::add_points() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::net::messages::Vector2f* _add = _internal_mutable_points()->Add();
  // @@protoc_insertion_point(field_add:net.messages.Triangle.points)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::net::messages::Vector2f>& Triangle::points() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:net.messages.Triangle.points)
  return _internal_points();
}
inline const ::google::protobuf::RepeatedPtrField<::net::messages::Vector2f>&
Triangle::_internal_points() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.points_;
}
inline ::google::protobuf::RepeatedPtrField<::net::messages::Vector2f>*
Triangle::_internal_mutable_points() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.points_;
}

// -------------------------------------------------------------------

// Polyline

// .net.messages.Color color = 1;
inline bool Polyline::has_color() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.color_ != nullptr);
  return value;
}
inline void Polyline::clear_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.color_ != nullptr) _impl_.color_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::net::messages::Color& Polyline::_internal_color() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::net::messages::Color* p = _impl_.color_;
  return p != nullptr ? *p : reinterpret_cast<const ::net::messages::Color&>(::net::messages::_Color_default_instance_);
}
inline const ::net::messages::Color& Polyline::color() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:net.messages.Polyline.color)
  return _internal_color();
}
inline void Polyline::unsafe_arena_set_allocated_color(::net::messages::Color* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.color_);
  }
  _impl_.color_ = reinterpret_cast<::net::messages::Color*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:net.messages.Polyline.color)
}
inline ::net::messages::Color* Polyline::release_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::net::messages::Color* released = _impl_.color_;
  _impl_.color_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::net::messages::Color* Polyline::unsafe_arena_release_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:net.messages.Polyline.color)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::net::messages::Color* temp = _impl_.color_;
  _impl_.color_ = nullptr;
  return temp;
}
inline ::net::messages::Color* Polyline::_internal_mutable_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.color_ == nullptr) {
    auto* p = CreateMaybeMessage<::net::messages::Color>(GetArena());
    _impl_.color_ = reinterpret_cast<::net::messages::Color*>(p);
  }
  return _impl_.color_;
}
inline ::net::messages::Color* Polyline::mutable_color() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::net::messages::Color* _msg = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:net.messages.Polyline.color)
  return _msg;
}
inline void Polyline::set_allocated_color(::net::messages::Color* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::net::messages::Color*>(_impl_.color_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::net::messages::Color*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.color_ = reinterpret_cast<::net::messages::Color*>(value);
  // @@protoc_insertion_point(field_set_allocated:net.messages.Polyline.color)
}

// repeated .net.messages.Vector2f points = 2;
inline int Polyline::_internal_points_size() const {
  return _internal_points().size();
}
inline int Polyline::points_size() const {
  return _internal_points_size();
}
inline void Polyline::clear_points() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.points_.Clear();
}
inline ::net::messages::Vector2f* Polyline::mutable_points(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:net.messages.Polyline.points)
  return _internal_mutable_points()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::net::messages::Vector2f>* Polyline::mutable_points()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:net.messages.Polyline.points)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_points();
}
inline const ::net::messages::Vector2f& Polyline::points(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:net.messages.Polyline.points)
  return _internal_points().Get(index);
}
inline ::net::messages::Vector2f* Polyline::add_points() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::net::messages::Vector2f* _add = _internal_mutable_points()->Add();
  // @@protoc_insertion_point(field_add:net.messages.Polyline.points)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::net::messages::Vector2f>& Polyline::points() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:net.messages.Polyline.points)
  return _internal_points();
}
inline const ::google::protobuf::RepeatedPtrField<::net::messages::Vector2f>&
Polyline::_internal_points() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.points_;
}
inline ::google::protobuf::RepeatedPtrField<::net::messages::Vector2f>*
Polyline::_internal_mutable_points() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.points_;
}

// -------------------------------------------------------------------

// LogText

// string text = 1;
inline void LogText::clear_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_.ClearToEmpty();
}
inline const std::string& LogText::text() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:net.messages.LogText.text)
  return _internal_text();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LogText::set_text(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.text_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:net.messages.LogText.text)
}
inline std::string* LogText::mutable_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:net.messages.LogText.text)
  return _s;
}
inline const std::string& LogText::_internal_text() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.text_.Get();
}
inline void LogText::_internal_set_text(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.text_.Set(value, GetArena());
}
inline std::string* LogText::_internal_mutable_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.text_.Mutable( GetArena());
}
inline std::string* LogText::release_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:net.messages.LogText.text)
  return _impl_.text_.Release();
}
inline void LogText::set_allocated_text(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.text_.IsDefault()) {
          _impl_.text_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:net.messages.LogText.text)
}

// -------------------------------------------------------------------

// Popup

// string text = 1;
inline void Popup::clear_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_.ClearToEmpty();
}
inline const std::string& Popup::text() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:net.messages.Popup.text)
  return _internal_text();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Popup::set_text(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.text_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:net.messages.Popup.text)
}
inline std::string* Popup::mutable_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:net.messages.Popup.text)
  return _s;
}
inline const std::string& Popup::_internal_text() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.text_.Get();
}
inline void Popup::_internal_set_text(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.text_.Set(value, GetArena());
}
inline std::string* Popup::_internal_mutable_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.text_.Mutable( GetArena());
}
inline std::string* Popup::release_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:net.messages.Popup.text)
  return _impl_.text_.Release();
}
inline void Popup::set_allocated_text(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.text_.IsDefault()) {
          _impl_.text_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:net.messages.Popup.text)
}

// .net.messages.Vector2f position = 2;
inline bool Popup::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void Popup::clear_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::net::messages::Vector2f& Popup::_internal_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::net::messages::Vector2f* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::net::messages::Vector2f&>(::net::messages::_Vector2f_default_instance_);
}
inline const ::net::messages::Vector2f& Popup::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:net.messages.Popup.position)
  return _internal_position();
}
inline void Popup::unsafe_arena_set_allocated_position(::net::messages::Vector2f* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::net::messages::Vector2f*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:net.messages.Popup.position)
}
inline ::net::messages::Vector2f* Popup::release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::net::messages::Vector2f* released = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::net::messages::Vector2f* Popup::unsafe_arena_release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:net.messages.Popup.position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::net::messages::Vector2f* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::net::messages::Vector2f* Popup::_internal_mutable_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::net::messages::Vector2f>(GetArena());
    _impl_.position_ = reinterpret_cast<::net::messages::Vector2f*>(p);
  }
  return _impl_.position_;
}
inline ::net::messages::Vector2f* Popup::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::net::messages::Vector2f* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:net.messages.Popup.position)
  return _msg;
}
inline void Popup::set_allocated_position(::net::messages::Vector2f* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::net::messages::Vector2f*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::net::messages::Vector2f*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_ = reinterpret_cast<::net::messages::Vector2f*>(value);
  // @@protoc_insertion_point(field_set_allocated:net.messages.Popup.position)
}

// float width = 3;
inline void Popup::clear_width() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.width_ = 0;
}
inline float Popup::width() const {
  // @@protoc_insertion_point(field_get:net.messages.Popup.width)
  return _internal_width();
}
inline void Popup::set_width(float value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:net.messages.Popup.width)
}
inline float Popup::_internal_width() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.width_;
}
inline void Popup::_internal_set_width(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.width_ = value;
}

// float height = 4;
inline void Popup::clear_height() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.height_ = 0;
}
inline float Popup::height() const {
  // @@protoc_insertion_point(field_get:net.messages.Popup.height)
  return _internal_height();
}
inline void Popup::set_height(float value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:net.messages.Popup.height)
}
inline float Popup::_internal_height() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.height_;
}
inline void Popup::_internal_set_height(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.height_ = value;
}

// -------------------------------------------------------------------

// PopupRound

// string text = 1;
inline void PopupRound::clear_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_.ClearToEmpty();
}
inline const std::string& PopupRound::text() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:net.messages.PopupRound.text)
  return _internal_text();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PopupRound::set_text(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.text_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:net.messages.PopupRound.text)
}
inline std::string* PopupRound::mutable_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:net.messages.PopupRound.text)
  return _s;
}
inline const std::string& PopupRound::_internal_text() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.text_.Get();
}
inline void PopupRound::_internal_set_text(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.text_.Set(value, GetArena());
}
inline std::string* PopupRound::_internal_mutable_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.text_.Mutable( GetArena());
}
inline std::string* PopupRound::release_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:net.messages.PopupRound.text)
  return _impl_.text_.Release();
}
inline void PopupRound::set_allocated_text(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.text_.IsDefault()) {
          _impl_.text_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:net.messages.PopupRound.text)
}

// .net.messages.Vector2f center = 2;
inline bool PopupRound::has_center() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.center_ != nullptr);
  return value;
}
inline void PopupRound::clear_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.center_ != nullptr) _impl_.center_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::net::messages::Vector2f& PopupRound::_internal_center() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::net::messages::Vector2f* p = _impl_.center_;
  return p != nullptr ? *p : reinterpret_cast<const ::net::messages::Vector2f&>(::net::messages::_Vector2f_default_instance_);
}
inline const ::net::messages::Vector2f& PopupRound::center() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:net.messages.PopupRound.center)
  return _internal_center();
}
inline void PopupRound::unsafe_arena_set_allocated_center(::net::messages::Vector2f* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.center_);
  }
  _impl_.center_ = reinterpret_cast<::net::messages::Vector2f*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:net.messages.PopupRound.center)
}
inline ::net::messages::Vector2f* PopupRound::release_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::net::messages::Vector2f* released = _impl_.center_;
  _impl_.center_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::net::messages::Vector2f* PopupRound::unsafe_arena_release_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:net.messages.PopupRound.center)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::net::messages::Vector2f* temp = _impl_.center_;
  _impl_.center_ = nullptr;
  return temp;
}
inline ::net::messages::Vector2f* PopupRound::_internal_mutable_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.center_ == nullptr) {
    auto* p = CreateMaybeMessage<::net::messages::Vector2f>(GetArena());
    _impl_.center_ = reinterpret_cast<::net::messages::Vector2f*>(p);
  }
  return _impl_.center_;
}
inline ::net::messages::Vector2f* PopupRound::mutable_center() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::net::messages::Vector2f* _msg = _internal_mutable_center();
  // @@protoc_insertion_point(field_mutable:net.messages.PopupRound.center)
  return _msg;
}
inline void PopupRound::set_allocated_center(::net::messages::Vector2f* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::net::messages::Vector2f*>(_impl_.center_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::net::messages::Vector2f*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.center_ = reinterpret_cast<::net::messages::Vector2f*>(value);
  // @@protoc_insertion_point(field_set_allocated:net.messages.PopupRound.center)
}

// float radius = 3;
inline void PopupRound::clear_radius() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.radius_ = 0;
}
inline float PopupRound::radius() const {
  // @@protoc_insertion_point(field_get:net.messages.PopupRound.radius)
  return _internal_radius();
}
inline void PopupRound::set_radius(float value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:net.messages.PopupRound.radius)
}
inline float PopupRound::_internal_radius() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.radius_;
}
inline void PopupRound::_internal_set_radius(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.radius_ = value;
}

// -------------------------------------------------------------------

// Options

// optional bool use_permanent_frame = 1;
inline bool Options::has_use_permanent_frame() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Options::clear_use_permanent_frame() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_permanent_frame_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool Options::use_permanent_frame() const {
  // @@protoc_insertion_point(field_get:net.messages.Options.use_permanent_frame)
  return _internal_use_permanent_frame();
}
inline void Options::set_use_permanent_frame(bool value) {
  _internal_set_use_permanent_frame(value);
  // @@protoc_insertion_point(field_set:net.messages.Options.use_permanent_frame)
}
inline bool Options::_internal_use_permanent_frame() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_permanent_frame_;
}
inline void Options::_internal_set_use_permanent_frame(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.use_permanent_frame_ = value;
}

// optional uint32 layer = 2;
inline bool Options::has_layer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Options::clear_layer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.layer_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t Options::layer() const {
  // @@protoc_insertion_point(field_get:net.messages.Options.layer)
  return _internal_layer();
}
inline void Options::set_layer(::uint32_t value) {
  _internal_set_layer(value);
  // @@protoc_insertion_point(field_set:net.messages.Options.layer)
}
inline ::uint32_t Options::_internal_layer() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.layer_;
}
inline void Options::_internal_set_layer(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.layer_ = value;
}

// -------------------------------------------------------------------

// Map

// float width = 1;
inline void Map::clear_width() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.width_ = 0;
}
inline float Map::width() const {
  // @@protoc_insertion_point(field_get:net.messages.Map.width)
  return _internal_width();
}
inline void Map::set_width(float value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:net.messages.Map.width)
}
inline float Map::_internal_width() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.width_;
}
inline void Map::_internal_set_width(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.width_ = value;
}

// float height = 2;
inline void Map::clear_height() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.height_ = 0;
}
inline float Map::height() const {
  // @@protoc_insertion_point(field_get:net.messages.Map.height)
  return _internal_height();
}
inline void Map::set_height(float value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:net.messages.Map.height)
}
inline float Map::_internal_height() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.height_;
}
inline void Map::_internal_set_height(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.height_ = value;
}

// uint32 x_grid = 3;
inline void Map::clear_x_grid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_grid_ = 0u;
}
inline ::uint32_t Map::x_grid() const {
  // @@protoc_insertion_point(field_get:net.messages.Map.x_grid)
  return _internal_x_grid();
}
inline void Map::set_x_grid(::uint32_t value) {
  _internal_set_x_grid(value);
  // @@protoc_insertion_point(field_set:net.messages.Map.x_grid)
}
inline ::uint32_t Map::_internal_x_grid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_grid_;
}
inline void Map::_internal_set_x_grid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x_grid_ = value;
}

// uint32 y_grid = 4;
inline void Map::clear_y_grid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y_grid_ = 0u;
}
inline ::uint32_t Map::y_grid() const {
  // @@protoc_insertion_point(field_get:net.messages.Map.y_grid)
  return _internal_y_grid();
}
inline void Map::set_y_grid(::uint32_t value) {
  _internal_set_y_grid(value);
  // @@protoc_insertion_point(field_set:net.messages.Map.y_grid)
}
inline ::uint32_t Map::_internal_y_grid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_grid_;
}
inline void Map::_internal_set_y_grid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.y_grid_ = value;
}

// -------------------------------------------------------------------

// EndFrame

// -------------------------------------------------------------------

// DrawMessage

// .net.messages.Circle circle = 1;
inline bool DrawMessage::has_circle() const {
  return command_case() == kCircle;
}
inline bool DrawMessage::_internal_has_circle() const {
  return command_case() == kCircle;
}
inline void DrawMessage::set_has_circle() {
  _impl_._oneof_case_[0] = kCircle;
}
inline void DrawMessage::clear_circle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (command_case() == kCircle) {
    if (GetArena() == nullptr) {
      delete _impl_.command_.circle_;
    }
    clear_has_command();
  }
}
inline ::net::messages::Circle* DrawMessage::release_circle() {
  // @@protoc_insertion_point(field_release:net.messages.DrawMessage.circle)
  if (command_case() == kCircle) {
    clear_has_command();
    auto* temp = _impl_.command_.circle_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.circle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::net::messages::Circle& DrawMessage::_internal_circle() const {
  return command_case() == kCircle ? *_impl_.command_.circle_ : reinterpret_cast<::net::messages::Circle&>(::net::messages::_Circle_default_instance_);
}
inline const ::net::messages::Circle& DrawMessage::circle() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:net.messages.DrawMessage.circle)
  return _internal_circle();
}
inline ::net::messages::Circle* DrawMessage::unsafe_arena_release_circle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:net.messages.DrawMessage.circle)
  if (command_case() == kCircle) {
    clear_has_command();
    auto* temp = _impl_.command_.circle_;
    _impl_.command_.circle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DrawMessage::unsafe_arena_set_allocated_circle(::net::messages::Circle* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_command();
  if (value) {
    set_has_circle();
    _impl_.command_.circle_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:net.messages.DrawMessage.circle)
}
inline ::net::messages::Circle* DrawMessage::_internal_mutable_circle() {
  if (command_case() != kCircle) {
    clear_command();
    set_has_circle();
    _impl_.command_.circle_ = CreateMaybeMessage<::net::messages::Circle>(GetArena());
  }
  return _impl_.command_.circle_;
}
inline ::net::messages::Circle* DrawMessage::mutable_circle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::net::messages::Circle* _msg = _internal_mutable_circle();
  // @@protoc_insertion_point(field_mutable:net.messages.DrawMessage.circle)
  return _msg;
}

// .net.messages.Rectangle rectangle = 2;
inline bool DrawMessage::has_rectangle() const {
  return command_case() == kRectangle;
}
inline bool DrawMessage::_internal_has_rectangle() const {
  return command_case() == kRectangle;
}
inline void DrawMessage::set_has_rectangle() {
  _impl_._oneof_case_[0] = kRectangle;
}
inline void DrawMessage::clear_rectangle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (command_case() == kRectangle) {
    if (GetArena() == nullptr) {
      delete _impl_.command_.rectangle_;
    }
    clear_has_command();
  }
}
inline ::net::messages::Rectangle* DrawMessage::release_rectangle() {
  // @@protoc_insertion_point(field_release:net.messages.DrawMessage.rectangle)
  if (command_case() == kRectangle) {
    clear_has_command();
    auto* temp = _impl_.command_.rectangle_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.rectangle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::net::messages::Rectangle& DrawMessage::_internal_rectangle() const {
  return command_case() == kRectangle ? *_impl_.command_.rectangle_ : reinterpret_cast<::net::messages::Rectangle&>(::net::messages::_Rectangle_default_instance_);
}
inline const ::net::messages::Rectangle& DrawMessage::rectangle() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:net.messages.DrawMessage.rectangle)
  return _internal_rectangle();
}
inline ::net::messages::Rectangle* DrawMessage::unsafe_arena_release_rectangle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:net.messages.DrawMessage.rectangle)
  if (command_case() == kRectangle) {
    clear_has_command();
    auto* temp = _impl_.command_.rectangle_;
    _impl_.command_.rectangle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DrawMessage::unsafe_arena_set_allocated_rectangle(::net::messages::Rectangle* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_command();
  if (value) {
    set_has_rectangle();
    _impl_.command_.rectangle_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:net.messages.DrawMessage.rectangle)
}
inline ::net::messages::Rectangle* DrawMessage::_internal_mutable_rectangle() {
  if (command_case() != kRectangle) {
    clear_command();
    set_has_rectangle();
    _impl_.command_.rectangle_ = CreateMaybeMessage<::net::messages::Rectangle>(GetArena());
  }
  return _impl_.command_.rectangle_;
}
inline ::net::messages::Rectangle* DrawMessage::mutable_rectangle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::net::messages::Rectangle* _msg = _internal_mutable_rectangle();
  // @@protoc_insertion_point(field_mutable:net.messages.DrawMessage.rectangle)
  return _msg;
}

// .net.messages.Triangle triangle = 3;
inline bool DrawMessage::has_triangle() const {
  return command_case() == kTriangle;
}
inline bool DrawMessage::_internal_has_triangle() const {
  return command_case() == kTriangle;
}
inline void DrawMessage::set_has_triangle() {
  _impl_._oneof_case_[0] = kTriangle;
}
inline void DrawMessage::clear_triangle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (command_case() == kTriangle) {
    if (GetArena() == nullptr) {
      delete _impl_.command_.triangle_;
    }
    clear_has_command();
  }
}
inline ::net::messages::Triangle* DrawMessage::release_triangle() {
  // @@protoc_insertion_point(field_release:net.messages.DrawMessage.triangle)
  if (command_case() == kTriangle) {
    clear_has_command();
    auto* temp = _impl_.command_.triangle_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.triangle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::net::messages::Triangle& DrawMessage::_internal_triangle() const {
  return command_case() == kTriangle ? *_impl_.command_.triangle_ : reinterpret_cast<::net::messages::Triangle&>(::net::messages::_Triangle_default_instance_);
}
inline const ::net::messages::Triangle& DrawMessage::triangle() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:net.messages.DrawMessage.triangle)
  return _internal_triangle();
}
inline ::net::messages::Triangle* DrawMessage::unsafe_arena_release_triangle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:net.messages.DrawMessage.triangle)
  if (command_case() == kTriangle) {
    clear_has_command();
    auto* temp = _impl_.command_.triangle_;
    _impl_.command_.triangle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DrawMessage::unsafe_arena_set_allocated_triangle(::net::messages::Triangle* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_command();
  if (value) {
    set_has_triangle();
    _impl_.command_.triangle_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:net.messages.DrawMessage.triangle)
}
inline ::net::messages::Triangle* DrawMessage::_internal_mutable_triangle() {
  if (command_case() != kTriangle) {
    clear_command();
    set_has_triangle();
    _impl_.command_.triangle_ = CreateMaybeMessage<::net::messages::Triangle>(GetArena());
  }
  return _impl_.command_.triangle_;
}
inline ::net::messages::Triangle* DrawMessage::mutable_triangle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::net::messages::Triangle* _msg = _internal_mutable_triangle();
  // @@protoc_insertion_point(field_mutable:net.messages.DrawMessage.triangle)
  return _msg;
}

// .net.messages.Polyline polyline = 4;
inline bool DrawMessage::has_polyline() const {
  return command_case() == kPolyline;
}
inline bool DrawMessage::_internal_has_polyline() const {
  return command_case() == kPolyline;
}
inline void DrawMessage::set_has_polyline() {
  _impl_._oneof_case_[0] = kPolyline;
}
inline void DrawMessage::clear_polyline() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (command_case() == kPolyline) {
    if (GetArena() == nullptr) {
      delete _impl_.command_.polyline_;
    }
    clear_has_command();
  }
}
inline ::net::messages::Polyline* DrawMessage::release_polyline() {
  // @@protoc_insertion_point(field_release:net.messages.DrawMessage.polyline)
  if (command_case() == kPolyline) {
    clear_has_command();
    auto* temp = _impl_.command_.polyline_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.polyline_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::net::messages::Polyline& DrawMessage::_internal_polyline() const {
  return command_case() == kPolyline ? *_impl_.command_.polyline_ : reinterpret_cast<::net::messages::Polyline&>(::net::messages::_Polyline_default_instance_);
}
inline const ::net::messages::Polyline& DrawMessage::polyline() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:net.messages.DrawMessage.polyline)
  return _internal_polyline();
}
inline ::net::messages::Polyline* DrawMessage::unsafe_arena_release_polyline() {
  // @@protoc_insertion_point(field_unsafe_arena_release:net.messages.DrawMessage.polyline)
  if (command_case() == kPolyline) {
    clear_has_command();
    auto* temp = _impl_.command_.polyline_;
    _impl_.command_.polyline_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DrawMessage::unsafe_arena_set_allocated_polyline(::net::messages::Polyline* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_command();
  if (value) {
    set_has_polyline();
    _impl_.command_.polyline_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:net.messages.DrawMessage.polyline)
}
inline ::net::messages::Polyline* DrawMessage::_internal_mutable_polyline() {
  if (command_case() != kPolyline) {
    clear_command();
    set_has_polyline();
    _impl_.command_.polyline_ = CreateMaybeMessage<::net::messages::Polyline>(GetArena());
  }
  return _impl_.command_.polyline_;
}
inline ::net::messages::Polyline* DrawMessage::mutable_polyline() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::net::messages::Polyline* _msg = _internal_mutable_polyline();
  // @@protoc_insertion_point(field_mutable:net.messages.DrawMessage.polyline)
  return _msg;
}

// .net.messages.LogText log_text = 5;
inline bool DrawMessage::has_log_text() const {
  return command_case() == kLogText;
}
inline bool DrawMessage::_internal_has_log_text() const {
  return command_case() == kLogText;
}
inline void DrawMessage::set_has_log_text() {
  _impl_._oneof_case_[0] = kLogText;
}
inline void DrawMessage::clear_log_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (command_case() == kLogText) {
    if (GetArena() == nullptr) {
      delete _impl_.command_.log_text_;
    }
    clear_has_command();
  }
}
inline ::net::messages::LogText* DrawMessage::release_log_text() {
  // @@protoc_insertion_point(field_release:net.messages.DrawMessage.log_text)
  if (command_case() == kLogText) {
    clear_has_command();
    auto* temp = _impl_.command_.log_text_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.log_text_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::net::messages::LogText& DrawMessage::_internal_log_text() const {
  return command_case() == kLogText ? *_impl_.command_.log_text_ : reinterpret_cast<::net::messages::LogText&>(::net::messages::_LogText_default_instance_);
}
inline const ::net::messages::LogText& DrawMessage::log_text() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:net.messages.DrawMessage.log_text)
  return _internal_log_text();
}
inline ::net::messages::LogText* DrawMessage::unsafe_arena_release_log_text() {
  // @@protoc_insertion_point(field_unsafe_arena_release:net.messages.DrawMessage.log_text)
  if (command_case() == kLogText) {
    clear_has_command();
    auto* temp = _impl_.command_.log_text_;
    _impl_.command_.log_text_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DrawMessage::unsafe_arena_set_allocated_log_text(::net::messages::LogText* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_command();
  if (value) {
    set_has_log_text();
    _impl_.command_.log_text_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:net.messages.DrawMessage.log_text)
}
inline ::net::messages::LogText* DrawMessage::_internal_mutable_log_text() {
  if (command_case() != kLogText) {
    clear_command();
    set_has_log_text();
    _impl_.command_.log_text_ = CreateMaybeMessage<::net::messages::LogText>(GetArena());
  }
  return _impl_.command_.log_text_;
}
inline ::net::messages::LogText* DrawMessage::mutable_log_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::net::messages::LogText* _msg = _internal_mutable_log_text();
  // @@protoc_insertion_point(field_mutable:net.messages.DrawMessage.log_text)
  return _msg;
}

// .net.messages.Popup popup = 6;
inline bool DrawMessage::has_popup() const {
  return command_case() == kPopup;
}
inline bool DrawMessage::_internal_has_popup() const {
  return command_case() == kPopup;
}
inline void DrawMessage::set_has_popup() {
  _impl_._oneof_case_[0] = kPopup;
}
inline void DrawMessage::clear_popup() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (command_case() == kPopup) {
    if (GetArena() == nullptr) {
      delete _impl_.command_.popup_;
    }
    clear_has_command();
  }
}
inline ::net::messages::Popup* DrawMessage::release_popup() {
  // @@protoc_insertion_point(field_release:net.messages.DrawMessage.popup)
  if (command_case() == kPopup) {
    clear_has_command();
    auto* temp = _impl_.command_.popup_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.popup_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::net::messages::Popup& DrawMessage::_internal_popup() const {
  return command_case() == kPopup ? *_impl_.command_.popup_ : reinterpret_cast<::net::messages::Popup&>(::net::messages::_Popup_default_instance_);
}
inline const ::net::messages::Popup& DrawMessage::popup() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:net.messages.DrawMessage.popup)
  return _internal_popup();
}
inline ::net::messages::Popup* DrawMessage::unsafe_arena_release_popup() {
  // @@protoc_insertion_point(field_unsafe_arena_release:net.messages.DrawMessage.popup)
  if (command_case() == kPopup) {
    clear_has_command();
    auto* temp = _impl_.command_.popup_;
    _impl_.command_.popup_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DrawMessage::unsafe_arena_set_allocated_popup(::net::messages::Popup* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_command();
  if (value) {
    set_has_popup();
    _impl_.command_.popup_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:net.messages.DrawMessage.popup)
}
inline ::net::messages::Popup* DrawMessage::_internal_mutable_popup() {
  if (command_case() != kPopup) {
    clear_command();
    set_has_popup();
    _impl_.command_.popup_ = CreateMaybeMessage<::net::messages::Popup>(GetArena());
  }
  return _impl_.command_.popup_;
}
inline ::net::messages::Popup* DrawMessage::mutable_popup() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::net::messages::Popup* _msg = _internal_mutable_popup();
  // @@protoc_insertion_point(field_mutable:net.messages.DrawMessage.popup)
  return _msg;
}

// .net.messages.PopupRound popup_round = 7;
inline bool DrawMessage::has_popup_round() const {
  return command_case() == kPopupRound;
}
inline bool DrawMessage::_internal_has_popup_round() const {
  return command_case() == kPopupRound;
}
inline void DrawMessage::set_has_popup_round() {
  _impl_._oneof_case_[0] = kPopupRound;
}
inline void DrawMessage::clear_popup_round() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (command_case() == kPopupRound) {
    if (GetArena() == nullptr) {
      delete _impl_.command_.popup_round_;
    }
    clear_has_command();
  }
}
inline ::net::messages::PopupRound* DrawMessage::release_popup_round() {
  // @@protoc_insertion_point(field_release:net.messages.DrawMessage.popup_round)
  if (command_case() == kPopupRound) {
    clear_has_command();
    auto* temp = _impl_.command_.popup_round_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.popup_round_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::net::messages::PopupRound& DrawMessage::_internal_popup_round() const {
  return command_case() == kPopupRound ? *_impl_.command_.popup_round_ : reinterpret_cast<::net::messages::PopupRound&>(::net::messages::_PopupRound_default_instance_);
}
inline const ::net::messages::PopupRound& DrawMessage::popup_round() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:net.messages.DrawMessage.popup_round)
  return _internal_popup_round();
}
inline ::net::messages::PopupRound* DrawMessage::unsafe_arena_release_popup_round() {
  // @@protoc_insertion_point(field_unsafe_arena_release:net.messages.DrawMessage.popup_round)
  if (command_case() == kPopupRound) {
    clear_has_command();
    auto* temp = _impl_.command_.popup_round_;
    _impl_.command_.popup_round_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DrawMessage::unsafe_arena_set_allocated_popup_round(::net::messages::PopupRound* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_command();
  if (value) {
    set_has_popup_round();
    _impl_.command_.popup_round_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:net.messages.DrawMessage.popup_round)
}
inline ::net::messages::PopupRound* DrawMessage::_internal_mutable_popup_round() {
  if (command_case() != kPopupRound) {
    clear_command();
    set_has_popup_round();
    _impl_.command_.popup_round_ = CreateMaybeMessage<::net::messages::PopupRound>(GetArena());
  }
  return _impl_.command_.popup_round_;
}
inline ::net::messages::PopupRound* DrawMessage::mutable_popup_round() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::net::messages::PopupRound* _msg = _internal_mutable_popup_round();
  // @@protoc_insertion_point(field_mutable:net.messages.DrawMessage.popup_round)
  return _msg;
}

// .net.messages.Options options = 8;
inline bool DrawMessage::has_options() const {
  return command_case() == kOptions;
}
inline bool DrawMessage::_internal_has_options() const {
  return command_case() == kOptions;
}
inline void DrawMessage::set_has_options() {
  _impl_._oneof_case_[0] = kOptions;
}
inline void DrawMessage::clear_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (command_case() == kOptions) {
    if (GetArena() == nullptr) {
      delete _impl_.command_.options_;
    }
    clear_has_command();
  }
}
inline ::net::messages::Options* DrawMessage::release_options() {
  // @@protoc_insertion_point(field_release:net.messages.DrawMessage.options)
  if (command_case() == kOptions) {
    clear_has_command();
    auto* temp = _impl_.command_.options_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::net::messages::Options& DrawMessage::_internal_options() const {
  return command_case() == kOptions ? *_impl_.command_.options_ : reinterpret_cast<::net::messages::Options&>(::net::messages::_Options_default_instance_);
}
inline const ::net::messages::Options& DrawMessage::options() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:net.messages.DrawMessage.options)
  return _internal_options();
}
inline ::net::messages::Options* DrawMessage::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_unsafe_arena_release:net.messages.DrawMessage.options)
  if (command_case() == kOptions) {
    clear_has_command();
    auto* temp = _impl_.command_.options_;
    _impl_.command_.options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DrawMessage::unsafe_arena_set_allocated_options(::net::messages::Options* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_command();
  if (value) {
    set_has_options();
    _impl_.command_.options_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:net.messages.DrawMessage.options)
}
inline ::net::messages::Options* DrawMessage::_internal_mutable_options() {
  if (command_case() != kOptions) {
    clear_command();
    set_has_options();
    _impl_.command_.options_ = CreateMaybeMessage<::net::messages::Options>(GetArena());
  }
  return _impl_.command_.options_;
}
inline ::net::messages::Options* DrawMessage::mutable_options() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::net::messages::Options* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:net.messages.DrawMessage.options)
  return _msg;
}

// .net.messages.Map map = 9;
inline bool DrawMessage::has_map() const {
  return command_case() == kMap;
}
inline bool DrawMessage::_internal_has_map() const {
  return command_case() == kMap;
}
inline void DrawMessage::set_has_map() {
  _impl_._oneof_case_[0] = kMap;
}
inline void DrawMessage::clear_map() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (command_case() == kMap) {
    if (GetArena() == nullptr) {
      delete _impl_.command_.map_;
    }
    clear_has_command();
  }
}
inline ::net::messages::Map* DrawMessage::release_map() {
  // @@protoc_insertion_point(field_release:net.messages.DrawMessage.map)
  if (command_case() == kMap) {
    clear_has_command();
    auto* temp = _impl_.command_.map_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::net::messages::Map& DrawMessage::_internal_map() const {
  return command_case() == kMap ? *_impl_.command_.map_ : reinterpret_cast<::net::messages::Map&>(::net::messages::_Map_default_instance_);
}
inline const ::net::messages::Map& DrawMessage::map() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:net.messages.DrawMessage.map)
  return _internal_map();
}
inline ::net::messages::Map* DrawMessage::unsafe_arena_release_map() {
  // @@protoc_insertion_point(field_unsafe_arena_release:net.messages.DrawMessage.map)
  if (command_case() == kMap) {
    clear_has_command();
    auto* temp = _impl_.command_.map_;
    _impl_.command_.map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DrawMessage::unsafe_arena_set_allocated_map(::net::messages::Map* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_command();
  if (value) {
    set_has_map();
    _impl_.command_.map_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:net.messages.DrawMessage.map)
}
inline ::net::messages::Map* DrawMessage::_internal_mutable_map() {
  if (command_case() != kMap) {
    clear_command();
    set_has_map();
    _impl_.command_.map_ = CreateMaybeMessage<::net::messages::Map>(GetArena());
  }
  return _impl_.command_.map_;
}
inline ::net::messages::Map* DrawMessage::mutable_map() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::net::messages::Map* _msg = _internal_mutable_map();
  // @@protoc_insertion_point(field_mutable:net.messages.DrawMessage.map)
  return _msg;
}

// .net.messages.EndFrame end_frame = 10;
inline bool DrawMessage::has_end_frame() const {
  return command_case() == kEndFrame;
}
inline bool DrawMessage::_internal_has_end_frame() const {
  return command_case() == kEndFrame;
}
inline void DrawMessage::set_has_end_frame() {
  _impl_._oneof_case_[0] = kEndFrame;
}
inline void DrawMessage::clear_end_frame() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (command_case() == kEndFrame) {
    if (GetArena() == nullptr) {
      delete _impl_.command_.end_frame_;
    }
    clear_has_command();
  }
}
inline ::net::messages::EndFrame* DrawMessage::release_end_frame() {
  // @@protoc_insertion_point(field_release:net.messages.DrawMessage.end_frame)
  if (command_case() == kEndFrame) {
    clear_has_command();
    auto* temp = _impl_.command_.end_frame_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.end_frame_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::net::messages::EndFrame& DrawMessage::_internal_end_frame() const {
  return command_case() == kEndFrame ? *_impl_.command_.end_frame_ : reinterpret_cast<::net::messages::EndFrame&>(::net::messages::_EndFrame_default_instance_);
}
inline const ::net::messages::EndFrame& DrawMessage::end_frame() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:net.messages.DrawMessage.end_frame)
  return _internal_end_frame();
}
inline ::net::messages::EndFrame* DrawMessage::unsafe_arena_release_end_frame() {
  // @@protoc_insertion_point(field_unsafe_arena_release:net.messages.DrawMessage.end_frame)
  if (command_case() == kEndFrame) {
    clear_has_command();
    auto* temp = _impl_.command_.end_frame_;
    _impl_.command_.end_frame_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DrawMessage::unsafe_arena_set_allocated_end_frame(::net::messages::EndFrame* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_command();
  if (value) {
    set_has_end_frame();
    _impl_.command_.end_frame_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:net.messages.DrawMessage.end_frame)
}
inline ::net::messages::EndFrame* DrawMessage::_internal_mutable_end_frame() {
  if (command_case() != kEndFrame) {
    clear_command();
    set_has_end_frame();
    _impl_.command_.end_frame_ = CreateMaybeMessage<::net::messages::EndFrame>(GetArena());
  }
  return _impl_.command_.end_frame_;
}
inline ::net::messages::EndFrame* DrawMessage::mutable_end_frame() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::net::messages::EndFrame* _msg = _internal_mutable_end_frame();
  // @@protoc_insertion_point(field_mutable:net.messages.DrawMessage.end_frame)
  return _msg;
}

inline bool DrawMessage::has_command() const {
  return command_case() != COMMAND_NOT_SET;
}
inline void DrawMessage::clear_has_command() {
  _impl_._oneof_case_[0] = COMMAND_NOT_SET;
}
inline DrawMessage::CommandCase DrawMessage::command_case() const {
  return DrawMessage::CommandCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace messages
}  // namespace net


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_net_2fproto_5fbuf_2fmessages_2eproto_2epb_2eh
